{
  "id": "KWcVEiwEzuiDsTqLn6LojC9X2yBX45N36DRtYHsFby6oiM4t597YhKBSdxr5wqMdj8kvSgDuiUuV6yvogw",
  "title": "GitHub All Languages Daily Trending",
  "displayTitle": "Github Trending",
  "url": "https://mshibanami.github.io/GitHubTrendingRSS/daily/all.xml",
  "feedLink": "http://mshibanami.github.io/GitHubTrendingRSS",
  "isQuery": false,
  "isEmpty": false,
  "isHidden": false,
  "itemCount": 8,
  "items": [
    {
      "title": "xai-org/grok-1",
      "url": "https://github.com/xai-org/grok-1",
      "date": 1769094695,
      "author": "",
      "guid": 37895,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "tobi/try",
      "url": "https://github.com/tobi/try",
      "date": 1769094695,
      "author": "",
      "guid": 37896,
      "unread": true,
      "content": "<p>fresh directories for every vibe</p><p><em>Your experiments deserve a home.</em> üè†</p><blockquote><p>For everyone who constantly creates new projects for little experiments, a one-file Ruby script to quickly manage and navigate to keep them somewhat organized</p></blockquote><p>Ever find yourself with 50 directories named , , , , scattered across your filesystem? Or worse, just coding in  and losing everything?</p><p> is here for your beautifully chaotic mind.</p><p>Instantly navigate through all your experiment directories with:</p><ul><li> that just works</li><li> - recently used stuff bubbles to the top</li><li> - creates directories like <code>2025-08-17-redis-experiment</code></li><li> - just one Ruby file, no dependencies</li></ul><pre><code># Bash/Zsh - add to .zshrc or .bashrc\neval \"$(try init)\"\n\n# Fish - add to config.fish\neval (try init | string collect)\n</code></pre><pre><code>curl -sL https://raw.githubusercontent.com/tobi/try/refs/heads/main/try.rb &gt; ~/.local/try.rb\n\n# Make \"try\" executable so it can be run directly\nchmod +x ~/.local/try.rb\n\n# Add to your shell (bash/zsh)\necho 'eval \"$(ruby ~/.local/try.rb init ~/src/tries)\"' &gt;&gt; ~/.zshrc\n\n# for fish shell users\necho 'eval (~/.local/try.rb init ~/src/tries | string collect)' &gt;&gt; ~/.config/fish/config.fish\n</code></pre><p>You're learning Redis. You create . Then . Then <code>~/projects/testing-redis-again</code>. Three weeks later you can't find that brilliant connection pooling solution you wrote at 2am.</p><p>All your experiments in one place, with instant fuzzy search:</p><pre><code>$ try pool\n‚Üí 2025-08-14-redis-connection-pool    2h, 18.5\n  2025-08-03-thread-pool              3d, 12.1\n  2025-07-22-db-pooling               2w, 8.3\n  + Create new: pool\n</code></pre><p>Type, arrow down, enter. You're there.</p><p>Not just substring matching - it's smart:</p><ul><li> matches </li><li>Recent stuff scores higher</li><li>Shorter names win on equal matches</li></ul><ul><li>Shows how long ago you touched each project</li><li>Recently accessed directories float to the top</li><li>Perfect for \"what was I working on yesterday?\"</li></ul><ul><li>Highlights matches as you type</li><li>Shows scores so you know why things are ranked</li><li>Dark mode by default (because obviously)</li></ul><ul><li>Everything lives in  (configurable via )</li><li>Auto-prefixes with dates: </li><li>Skip the date prompt if you already typed a name</li></ul><ul><li><pre><code># default is ~/src/tries\neval \"$(~/.local/try.rb init)\"\n# or pick a path\neval \"$(~/.local/try.rb init ~/src/tries)\"\n</code></pre></li><li><pre><code>eval (~/.local/try.rb init | string collect)\n# or pick a path\neval (~/.local/try.rb init ~/src/tries | string collect)\n</code></pre></li></ul><ul><li>The runtime commands printed by  are shell-neutral (absolute paths, quoted). Only the small wrapper function differs per shell.</li></ul><pre><code>try                                          # Browse all experiments\ntry redis                                    # Jump to redis experiment or create new\ntry new api                                  # Start with \"2025-08-17-new-api\"\ntry . [name]                                   # Create a dated worktree dir for current repo\ntry ./path/to/repo [name]                      # Use another repo as the worktree source\ntry worktree dir [name]                        # Same as above, explicit CLI form\ntry clone https://github.com/user/repo.git  # Clone repo into date-prefixed directory\ntry https://github.com/user/repo.git        # Shorthand for clone (same as above)\ntry --help                                   # See all options\n</code></pre><p>Notes on worktrees ( / ):</p><ul><li>With a custom [name], uses that; otherwise uses cwd‚Äôs basename. Both are prefixed with today‚Äôs date.</li><li>Inside a Git repo: adds a detached HEAD git worktree to the created directory.</li><li>Outside a repo: simply creates the directory and changes into it.</li></ul><p> can automatically clone git repositories into properly named experiment directories:</p><pre><code># Clone with auto-generated directory name\ntry clone https://github.com/tobi/try.git\n# Creates: 2025-08-27-tobi-try\n\n# Clone with custom name\ntry clone https://github.com/tobi/try.git my-fork\n# Creates: my-fork\n\n# Shorthand syntax (no need to type 'clone')\ntry https://github.com/tobi/try.git\n# Creates: 2025-08-27-tobi-try\n</code></pre><p>Supported git URI formats:</p><ul><li><code>https://github.com/user/repo.git</code> (HTTPS GitHub)</li><li><code>git@github.com:user/repo.git</code> (SSH GitHub)</li><li><code>https://gitlab.com/user/repo.git</code> (GitLab)</li><li><code>git@host.com:user/repo.git</code> (SSH other hosts)</li></ul><p>The  suffix is automatically removed from URLs when generating directory names.</p><ul><li> or  - Navigate</li><li> - Delete character</li><li> - Delete directory (with confirmation)</li></ul><p>Set  to change where experiments are stored:</p><pre><code>export TRY_PATH=~/code/sketches\n</code></pre><pre><code>nix run github:tobi/try\nnix run github:tobi/try -- --help\nnix run github:tobi/try init ~/my-tries\n</code></pre><pre><code>{\n  inputs.try.url = \"github:tobi/try\";\n  \n  imports = [ inputs.try.homeManagerModules.default ];\n  \n  programs.try = {\n    enable = true;\n    path = \"~/experiments\";  # optional, defaults to ~/src/tries\n  };\n}\n</code></pre><pre><code>brew tap tobi/try https://github.com/tobi/try\nbrew install try\n</code></pre><p>After installation, add to your shell:</p><ul><li><pre><code># default is ~/src/tries\neval \"$(try init)\"\n# or pick a path\neval \"$(try init ~/src/tries)\"\n</code></pre></li><li><pre><code>eval \"(try init | string collect)\"\n# or pick a path\neval \"(try init ~/src/tries | string collect)\"\n</code></pre></li></ul><ul><li>One file, no dependencies</li><li>Works on any system with Ruby (macOS has it built-in)</li><li>Fast enough for thousands of directories</li></ul><p>Your brain doesn't work in neat folders. You have ideas, you try things, you context-switch like a caffeinated squirrel. This tool embraces that.</p><p>Every experiment gets a home. Every home is instantly findable. Your 2am coding sessions are no longer lost to the void.</p><p><strong>Q: Why not just use  and ?</strong> A: Because you have 200 directories and can't remember if you called it , , or .</p><p> A: fzf is great for files. This is specifically for project directories, with time-awareness and auto-creation built in.</p><p><strong>Q: Can I use this for real projects?</strong> A: You can, but it's designed for experiments. Real projects deserve real names in real locations.</p><p><strong>Q: What if I have thousands of experiments?</strong> A: First, welcome to the club. Second, it handles it fine - the scoring algorithm ensures relevant stuff stays on top.</p><p>It's one file. If you want to change something, just edit it. Send a PR if you think others would like it too.</p><p>MIT - Do whatever you want with it.</p><p><em>Built for developers with ADHD by developers with ADHD.</em></p><p><em>Your experiments deserve a home.</em> üè†</p>",
      "contentLength": 5992,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "EveryInc/compound-engineering-plugin",
      "url": "https://github.com/EveryInc/compound-engineering-plugin",
      "date": 1769094695,
      "author": "",
      "guid": 37897,
      "unread": true,
      "content": "<p>Official Claude Code compound engineering plugin</p><p>A Claude Code plugin marketplace featuring the <strong>Compound Engineering Plugin</strong> ‚Äî tools that make each unit of engineering work easier than the last.</p><pre><code>/plugin marketplace add https://github.com/kieranklaassen/compound-engineering-plugin\n/plugin install compound-engineering\n</code></pre><h2>OpenCode + Codex support (experimental)</h2><p>This repo includes a Bun/TypeScript CLI that converts Claude Code plugins to OpenCode and Codex.</p><pre><code># convert the compound-engineering plugin into OpenCode format\nbunx @every-env/compound-plugin install compound-engineering --to opencode\n\n# convert to Codex format\nbunx @every-env/compound-plugin install compound-engineering --to codex\n</code></pre><pre><code>bun run src/index.ts install ./plugins/compound-engineering --to opencode\n</code></pre><p>OpenCode output is written to  by default, with  at the root and , , and  alongside it. Both provider targets are experimental and may change as the formats evolve. Codex output is written to  and , with each Claude command converted into both a prompt and a skill (the prompt instructs Codex to load the corresponding skill). Generated Codex skill descriptions are truncated to 1024 characters (Codex limit).</p><pre><code>Plan ‚Üí Work ‚Üí Review ‚Üí Compound ‚Üí Repeat\n</code></pre><table><tbody><tr><td>Turn feature ideas into detailed implementation plans</td></tr><tr><td>Execute plans with worktrees and task tracking</td></tr><tr><td>Multi-agent code review before merging</td></tr><tr><td>Document learnings to make future work easier</td></tr></tbody></table><p>Each cycle compounds: plans inform future plans, reviews catch more issues, patterns get documented.</p><p><strong>Each unit of engineering work should make subsequent units easier‚Äînot harder.</strong></p><p>Traditional development accumulates technical debt. Every feature adds complexity. The codebase becomes harder to work with over time.</p><p>Compound engineering inverts this. 80% is in planning and review, 20% is in execution:</p><ul><li>Plan thoroughly before writing code</li><li>Review to catch issues and capture learnings</li><li>Codify knowledge so it's reusable</li><li>Keep quality high so future changes are easy</li></ul>",
      "contentLength": 1958,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "microsoft/agent-lightning",
      "url": "https://github.com/microsoft/agent-lightning",
      "date": 1769094695,
      "author": "",
      "guid": 37898,
      "unread": true,
      "content": "<p>The absolute trainer to light up AI agents.</p><p><strong>The absolute trainer to light up AI agents.</strong></p><ul><li>Turn your agent into an optimizable beast with  (almost)! üí§</li><li>Build with  agent framework (LangChain, OpenAI Agent SDK, AutoGen, CrewAI, Microsoft Agent Framework...); or even WITHOUT agent framework (Python OpenAI). You name it! ü§ñ</li><li> optimize one or more agents in a multi-agent system. üéØ</li><li>Embraces  like Reinforcement Learning, Automatic Prompt Optimization, Supervised Fine-tuning and more. ü§ó</li></ul><pre><code>pip install agentlightning\n</code></pre><p>For the latest nightly build (cutting-edge features), you can install from Test PyPI:</p><pre><code>pip install --upgrade --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ --pre agentlightning\n</code></pre><p>Agent Lightning keeps the moving parts to a minimum so you can focus on your idea, not the plumbing. Your agent continues to run as usual; you can still use any agent framework you like; you drop in the lightweight  helper, or let the tracer collect every prompt, tool call, and reward. Those events become structured spans that flow into the LightningStore, a central hub that keeps tasks, resources, and traces in sync.</p><p>On the other side of the store sits the algorithm you choose, or write yourself. The algorithm reads spans, learns from them, and posts updated resources such as refined prompt templates or new policy weights. The Trainer ties it all together: it streams datasets to runners, ferries resources between the store and the algorithm, and updates the inference engine when improvements land. You can either stop there, or simply let the same loop keep turning.</p><p>No rewrites, no lock-in, just a clear path from first rollout to steady improvement.</p><p>If you find Agent Lightning useful in your research or projects, please cite our paper:</p><pre><code>@misc{luo2025agentlightningtrainai,\n      title={Agent Lightning: Train ANY AI Agents with Reinforcement Learning},\n      author={Xufang Luo and Yuge Zhang and Zhiyuan He and Zilong Wang and Siyun Zhao and Dongsheng Li and Luna K. Qiu and Yuqing Yang},\n      year={2025},\n      eprint={2508.03680},\n      archivePrefix={arXiv},\n      primaryClass={cs.AI},\n      url={https://arxiv.org/abs/2508.03680},\n}\n</code></pre><p>This project welcomes contributions and suggestions. Start by reading the <a href=\"https://raw.githubusercontent.com/microsoft/agent-lightning/main/docs/community/contributing.md\">Contributing Guide</a> for recommended contribution points, environment setup, branching conventions, and pull request expectations. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit <a href=\"https://cla.opensource.microsoft.com\">https://cla.opensource.microsoft.com</a>.</p><p>When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.</p><p>This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow <a href=\"https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general\">Microsoft's Trademark &amp; Brand Guidelines</a>. Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party's policies.</p><p>This project has been evaluated and certified to comply with the Microsoft Responsible AI Standard. The team will continue to monitor and maintain the repository, addressing any severe issues, including potential harms, if they arise.</p><p>This project is licensed under the MIT License. See the <a href=\"https://raw.githubusercontent.com/microsoft/agent-lightning/main/LICENSE\">LICENSE</a> file for details.</p>",
      "contentLength": 3641,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "VectifyAI/PageIndex",
      "url": "https://github.com/VectifyAI/PageIndex",
      "date": 1769094695,
      "author": "",
      "guid": 37899,
      "unread": true,
      "content": "<p>üìë PageIndex: Document Index for Vectorless, Reasoning-based RAG</p><p>Are you frustrated with vector database retrieval accuracy for long professional documents? Traditional vector-based RAG relies on semantic  rather than true . But  ‚Äî what we truly need in retrieval is , and that requires . When working with professional documents that demand domain expertise and multi-step reasoning, similarity search often falls short.</p><p>Inspired by AlphaGo, we propose  ‚Äî a ,  system that builds a  from long documents and uses LLMs to  for <strong>agentic, context-aware retrieval</strong>. It simulates how  navigate and extract knowledge from complex documents through , enabling LLMs to  and  their way to the most relevant document sections. PageIndex performs retrieval in two steps:</p><ol><li>Generate a ‚ÄúTable-of-Contents‚Äù  of documents</li><li>Perform reasoning-based retrieval through </li></ol><p>Compared to traditional vector-based RAG,  features:</p><ul><li>: Uses document structure and LLM reasoning for retrieval, instead of vector similarity search.</li><li>: Documents are organized into natural sections, not artificial chunks.</li><li>: Simulates how human experts navigate and extract knowledge from complex documents.</li><li><strong>Better Explainability and Traceability</strong>: Retrieval is based on reasoning ‚Äî traceable and interpretable, with page and section references. No more opaque, approximate vector search (‚Äúvibe retrieval‚Äù).</li></ul><p>PageIndex powers a reasoning-based RAG system that achieved <a href=\"https://github.com/VectifyAI/Mafin2.5-FinanceBench\">98.7% accuracy</a> on FinanceBench, demonstrating superior performance over vector-based RAG solutions in professional document analysis (see our <a href=\"https://vectify.ai/blog/Mafin2.5\">blog post</a> for details).</p><p>The PageIndex service is available as a ChatGPT-style <a href=\"https://chat.pageindex.ai\">chat platform</a>, or can be integrated via <a href=\"https://pageindex.ai/mcp\">MCP</a> or <a href=\"https://docs.pageindex.ai/quickstart\">API</a>.</p><ul><li>Self-host ‚Äî run locally with this open-source repo.</li></ul><ul><li>Try the <a href=\"https://github.com/VectifyAI/PageIndex/raw/main/cookbook/pageindex_RAG_simple.ipynb\"></a> notebook ‚Äî a , hands-on example of reasoning-based RAG using PageIndex.</li></ul><p>PageIndex can transform lengthy PDF documents into a semantic , similar to a  but optimized for use with Large Language Models (LLMs). It's ideal for: financial reports, regulatory filings, academic textbooks, legal or technical manuals, and any document that exceeds LLM context limits.</p><pre><code>...\n{\n  \"title\": \"Financial Stability\",\n  \"node_id\": \"0006\",\n  \"start_index\": 21,\n  \"end_index\": 22,\n  \"summary\": \"The Federal Reserve ...\",\n  \"nodes\": [\n    {\n      \"title\": \"Monitoring Financial Vulnerabilities\",\n      \"node_id\": \"0007\",\n      \"start_index\": 22,\n      \"end_index\": 28,\n      \"summary\": \"The Federal Reserve's monitoring ...\"\n    },\n    {\n      \"title\": \"Domestic and International Cooperation and Coordination\",\n      \"node_id\": \"0008\",\n      \"start_index\": 28,\n      \"end_index\": 31,\n      \"summary\": \"In 2023, the Federal Reserve collaborated ...\"\n    }\n  ]\n}\n...\n</code></pre><p>You can generate the PageIndex tree structure with this open-source repo, or use our <a href=\"https://docs.pageindex.ai/quickstart\">API</a></p><p>You can follow these steps to generate a PageIndex tree from a PDF document.</p><pre><code>pip3 install --upgrade -r requirements.txt\n</code></pre><h3>2. Set your OpenAI API key</h3><p>Create a  file in the root directory and add your API key:</p><pre><code>CHATGPT_API_KEY=your_openai_key_here\n</code></pre><h3>3. Run PageIndex on your PDF</h3><pre><code>python3 run_pageindex.py --pdf_path /path/to/your/document.pdf\n</code></pre><p><a href=\"https://vectify.ai/mafin\">Mafin 2.5</a> is a reasoning-based RAG system for financial document analysis, powered by . It achieved a state-of-the-art <a href=\"https://vectify.ai/blog/Mafin2.5\"></a> on the <a href=\"https://arxiv.org/abs/2311.11944\">FinanceBench</a> benchmark, significantly outperforming traditional vector-based RAG systems.</p><p>PageIndex's hierarchical indexing and reasoning-driven retrieval enable precise navigation and extraction of relevant context from complex financial reports, such as SEC filings and earnings disclosures.</p><ul><li>üß™ <a href=\"https://docs.pageindex.ai/cookbook/vectorless-rag-pageindex\">Cookbooks</a>: hands-on, runnable examples and advanced use cases.</li><li>üìñ <a href=\"https://docs.pageindex.ai/doc-search\">Tutorials</a>: practical guides and strategies, including  and .</li><li>üìù <a href=\"https://pageindex.ai/blog\">Blog</a>: technical articles, research insights, and product updates.</li></ul><p>Leave us a star üåü if you like our project. Thank you!</p>",
      "contentLength": 3790,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "twitter/the-algorithm",
      "url": "https://github.com/twitter/the-algorithm",
      "date": 1769094695,
      "author": "",
      "guid": 37900,
      "unread": true,
      "content": "<p>Source code for the X Recommendation Algorithm</p><p>X's Recommendation Algorithm is a set of services and jobs that are responsible for serving feeds of posts and other content across all X product surfaces (e.g. For You Timeline, Search, Explore, Notifications). For an introduction to how the algorithm works, please refer to our <a href=\"https://blog.x.com/engineering/en_us/topics/open-source/2023/twitter-recommendation-algorithm\">engineering blog</a>.</p><p>Product surfaces at X are built on a shared set of data, models, and software frameworks. The shared components included in this repository are listed below:</p><table><tbody><tr><td>Core service that handles the reading and writing of post data.</td></tr><tr><td>Centralized platform to retrieve explicit (e.g. likes, replies) and implicit (e.g. profile visits, tweet clicks) user signals.</td></tr><tr><td>Community detection and sparse embeddings into those communities.</td></tr><tr><td>Dense knowledge graph embeddings for Users and Posts.</td></tr><tr><td>Model to predict the likelihood of an X User interacting with another User.</td></tr><tr><td>Page-Rank algorithm for calculating X User reputation.</td></tr><tr><td>Serves graph features for a directed pair of users (e.g. how many of User A's following liked posts from User B).</td></tr><tr><td>Compute scores between pairs of entities (Users, Posts, etc.) using embedding similarity.</td></tr><tr><td>High performance, machine learning model serving written in Rust.</td></tr><tr><td>Legacy machine learning framework built on TensorFlow v1.</td></tr></tbody></table><p>The product surfaces currently included in this repository are the For You Timeline and Recommended Notifications.</p><p>The diagram below illustrates how major services and jobs interconnect to construct a For You Timeline.</p><p>The core components of the For You Timeline included in this repository are listed below:</p><table><tbody><tr><td>Find and rank In-Network posts. ~50% of posts come from this candidate source.</td></tr><tr><td>Coordination layer for fetching Out-of-Network tweet candidates from underlying compute services.</td></tr><tr><td>Maintains an in memory User to Post interaction graph, and finds candidates based on traversals of this graph. This is built on the <a href=\"https://github.com/twitter/GraphJet\">GraphJet</a> framework. Several other GraphJet based features and candidate sources are located <a href=\"https://raw.githubusercontent.com/twitter/the-algorithm/main/src/scala/com/twitter/recos\">here</a>.</td></tr><tr><td>Light Ranker model used by search index (Earlybird) to rank posts.</td></tr><tr><td>Neural network for ranking candidate posts. One of the main signals used to select timeline posts post candidate sourcing.</td></tr><tr><td>Main service used to construct and serve the Home Timeline. Built on <a href=\"https://raw.githubusercontent.com/twitter/the-algorithm/main/product-mixer/README.md\">product-mixer</a>.</td></tr><tr><td>Responsible for filtering X content to support legal compliance, improve product quality, increase user trust, protect revenue through the use of hard-filtering, visible product treatments, and coarse-grained downranking.</td></tr><tr><td>Legacy service which provides relevance-scored posts from the Earlybird Search Index and UTEG service.</td></tr></tbody></table><h3>Recommended Notifications</h3><p>The core components of Recommended Notifications included in this repository are listed below:</p><table><tbody><tr><td>Main recommendation service at X used to surface recommendations to our users via notifications.</td></tr><tr><td>Light Ranker model used by pushservice to rank posts. Bridges candidate generation and heavy ranking by pre-selecting highly-relevant candidates from the initial huge candidate pool.</td></tr><tr><td>Multi-task learning model to predict the probabilities that the target users will open and engage with the sent notifications.</td></tr></tbody></table><p>We include Bazel BUILD files for most components, but not a top-level BUILD or WORKSPACE file. We plan to add a more complete build and test system in the future.</p><p>We invite the community to submit GitHub issues and pull requests for suggestions on improving the recommendation algorithm. We are working on tools to manage these suggestions and sync changes to our internal repository. Any security concerns or issues should be routed to our official <a href=\"https://hackerone.com/x\">bug bounty program</a> through HackerOne. We hope to benefit from the collective intelligence and expertise of the global community in helping us identify issues and suggest improvements, ultimately leading to a better X.</p><p>Read our blog on the open source initiative <a href=\"https://blog.x.com/en_us/topics/company/2023/a-new-era-of-transparency-for-twitter\">here</a>.</p>",
      "contentLength": 3802,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "tambo-ai/tambo",
      "url": "https://github.com/tambo-ai/tambo",
      "date": 1769094695,
      "author": "",
      "guid": 37901,
      "unread": true,
      "content": "<p>Generative UI SDK for React</p><div align=\"center\"><img src=\"https://raw.githubusercontent.com/tambo-ai/tambo/main/assets/octo-white-background-rounded.png\" width=\"150\"><p>Build apps that adapt to your users.</p></div><p>Tambo is a generative UI SDK for React. Register your components, and the AI decides which ones to render based on natural language conversations.</p><p>Most software is built around a one-size-fits-all mental model that doesn't fit every user.</p><p><strong>Users shouldn't have to learn your app.</strong> Generative UI shows the right components based on what someone is trying to do. First-time users and power users see different things.</p><p><strong>Users shouldn't have to click through your workflows.</strong> \"Show me sales from last quarter grouped by region\" should just work. The AI translates what users want into the right interface.</p><pre><code>const components: TamboComponent[] = [{\n  name: \"Graph\",\n  description: \"Displays data as charts\",\n  component: Graph,\n  propsSchema: z.object({ data: z.array(...), type: z.enum([\"line\", \"bar\", \"pie\"]) })\n}];\n</code></pre><pre><code>npx tambo create-app my-tambo-app\ncd my-tambo-app\nnpx tambo init      # choose cloud or self-hosted\nnpm run dev\n</code></pre><p> is a free hosted backend.  runs on your own infrastructure.</p><p>Tambo supports two kinds of components.</p><p> render once in response to a message. Charts, summaries, data visualizations.</p><p> persist and update as users refine requests. Shopping carts, spreadsheets, task boards.</p><p>Tell the AI which components it can use. Zod schemas define the props.</p><pre><code>// Generative: AI creates on-demand\nconst components: TamboComponent[] = [\n  {\n    name: \"Graph\",\n    description: \"Displays data as charts using Recharts library\",\n    component: Graph,\n    propsSchema: z.object({\n      data: z.array(z.object({ name: z.string(), value: z.number() })),\n      type: z.enum([\"line\", \"bar\", \"pie\"]),\n    }),\n  },\n];\n\n// Interactable: persists and updates by ID\nconst InteractableNote = withInteractable(Note, {\n  componentName: \"Note\",\n  description: \"A note supporting title, content, and color modifications\",\n  propsSchema: z.object({\n    title: z.string(),\n    content: z.string(),\n    color: z.enum([\"white\", \"yellow\", \"blue\", \"green\"]).optional(),\n  }),\n});\n</code></pre><p>Wrap your app with .</p><pre><code>&lt;TamboProvider\n  apiKey={process.env.NEXT_PUBLIC_TAMBO_API_KEY!}\n  components={components}\n&gt;\n  &lt;Chat /&gt;\n  &lt;InteractableNote id=\"note-1\" title=\"My Note\" content=\"Start writing...\" /&gt;\n&lt;/TamboProvider&gt;\n</code></pre><p>For apps with signed-in users, pass a per-user  (OAuth access token) to  to enable per-user auth and connect Tambo to your app's end-user identity. See <a href=\"https://docs.tambo.co/concepts/user-authentication\">User Authentication</a> for details.</p><p>Send messages with .  handles streaming, including props for generated components and tool calls.</p><pre><code>const { value, setValue, submit, isPending } = useTamboThreadInput();\n\n&lt;input value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt;\n&lt;button onClick={() =&gt; submit()} disabled={isPending}&gt;Send&lt;/button&gt;\n</code></pre><pre><code>const { thread } = useTamboThread();\n\n{\n  thread.messages.map((message) =&gt; (\n    &lt;div key={message.id}&gt;\n      {Array.isArray(message.content) ? (\n        message.content.map((part, i) =&gt;\n          part.type === \"text\" ? &lt;p key={i}&gt;{part.text}&lt;/p&gt; : null,\n        )\n      ) : (\n        &lt;p&gt;{String(message.content)}&lt;/p&gt;\n      )}\n      {message.renderedComponent}\n    &lt;/div&gt;\n  ));\n}\n</code></pre><p>Track streaming status if you want progressive loading:</p><pre><code>const { streamStatus, propStatus } = useTamboStreamStatus();\n\nif (!streamStatus.isSuccess) return &lt;Spinner /&gt;;\n{\n  propStatus[\"title\"]?.isSuccess &amp;&amp; &lt;h3&gt;{title}&lt;/h3&gt;;\n}\n</code></pre><p>Connect to Linear, Slack, databases, or your own MCP servers. Tambo supports the full MCP protocol: tools, prompts, elicitations, and sampling.</p><pre><code>import { MCPTransport } from \"@tambo-ai/react/mcp\";\n\nconst mcpServers = [\n  {\n    name: \"filesystem\",\n    url: \"http://localhost:8261/mcp\",\n    transport: MCPTransport.HTTP,\n  },\n];\n\n&lt;TamboProvider components={components} mcpServers={mcpServers}&gt;\n  &lt;App /&gt;\n&lt;/TamboProvider&gt;;\n</code></pre><p>Supports the full MCP protocol: tools, prompts, elicitations, and sampling.</p><p>Sometimes you need functions that run in the browser. DOM manipulation, authenticated fetches, accessing React state. Define them as tools and the AI can call them.</p><pre><code>const tools: TamboTool[] = [\n  {\n    name: \"getWeather\",\n    description: \"Fetches weather for a location\",\n    tool: async (location: string) =&gt;\n      fetch(`/api/weather?q=${encodeURIComponent(location)}`).then((r) =&gt;\n        r.json(),\n      ),\n    toolSchema: z\n      .function()\n      .args(z.string())\n      .returns(\n        z.object({\n          temperature: z.number(),\n          condition: z.string(),\n          location: z.string(),\n        }),\n      ),\n  },\n];\n\n&lt;TamboProvider tools={tools} components={components}&gt;\n  &lt;App /&gt;\n&lt;/TamboProvider&gt;;\n</code></pre><h3>Context, Auth, and Suggestions</h3><p> lets you pass metadata to give the AI better responses. User state, app settings, current page.  passes tokens from your auth provider.  generates prompts users can click based on what they're doing.</p><pre><code>&lt;TamboProvider\n  userToken={userToken}\n  contextHelpers={{\n    selectedItems: () =&gt; ({\n      key: \"selectedItems\",\n      value: selectedItems.map((i) =&gt; i.name).join(\", \"),\n    }),\n    currentPage: () =&gt; ({ key: \"page\", value: window.location.pathname }),\n  }}\n/&gt;\n</code></pre><pre><code>const { suggestions, accept } = useTamboSuggestions({ maxSuggestions: 3 });\n\nsuggestions.map((s) =&gt; (\n  &lt;button key={s.id} onClick={() =&gt; accept(s)}&gt;\n    {s.title}\n  &lt;/button&gt;\n));\n</code></pre><p>OpenAI, Anthropic, Cerebras, Google Gemini, Mistral, and any OpenAI-compatible provider. <a href=\"https://docs.tambo.co/models\">Full list</a>. Missing one? <a href=\"https://github.com/tambo-ai/tambo/issues\">Let us know</a>.</p><table><thead><tr></tr></thead><tbody><tr><td>AI decides which components to render</td><td>Manual tool-to-component mapping</td><td>Via agent frameworks (LangGraph)</td></tr><tr></tr><tr><td><strong>Persistent stateful components</strong></td></tr><tr><td><strong>Client-side tool execution</strong></td></tr><tr></tr><tr></tr><tr><td>Streaming and tool abstractions</td></tr></tbody></table><p>Free forever. MIT licensed. 5-minute Docker setup.</p><pre><code>npx tambo init\n# Select \"Self-hosted\"\n</code></pre><p>Free tier, then pay as you grow.</p><ul><li>: 10,000 messages/month</li><li>: $25/mo for 200k messages + email support</li><li>: Custom volume, SLA, SOC 2, HIPAA</li></ul><p>This Turborepo hosts the React SDK ecosystem and Tambo Cloud platform.</p><p> has the web dashboard (Next.js), the API (NestJS), and MCP services.</p><p> has shared code. Database schema (Drizzle), LLM helpers, pure utilities, and tooling configs.</p><p>The root holds framework packages: , , , , .</p><p>You'll need Node.js 22+, npm 11+, and optionally Docker.</p><pre><code>git clone https://github.com/tambo-ai/tambo.git\ncd tambo\nnpm install\nnpm run dev        # apps/web + apps/api\n</code></pre><pre><code>npm run build        # Build everything\nnpm run lint         # Lint (lint:fix to autofix)\nnpm run check-types  # Type check\nnpm test             # Run tests\n</code></pre><p>Database (requires Docker):</p><pre><code>npm run db:generate  # Generate migrations\nnpm run db:migrate   # Apply migrations\nnpm run db:studio    # Open Drizzle Studio\n</code></pre><p>Unless otherwise noted in a workspace (app or package), code in this repo is licensed under MIT (see the root <a href=\"https://raw.githubusercontent.com/tambo-ai/tambo/main/LICENSE\">LICENSE</a>).</p><p>Some workspaces are licensed under Apache-2.0; see the accompanying  and  files in those workspaces.</p>",
      "contentLength": 6707,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "microsoft/Data-Science-For-Beginners",
      "url": "https://github.com/microsoft/Data-Science-For-Beginners",
      "date": 1769094695,
      "author": "",
      "guid": 37902,
      "unread": true,
      "content": "<p>10 Weeks, 20 Lessons, Data Science for All!</p><p>Azure Cloud Advocates at Microsoft are pleased to offer a 10-week, 20-lesson curriculum all about Data Science. Each lesson includes pre-lesson and post-lesson quizzes, written instructions to complete the lesson, a solution, and an assignment. Our project-based pedagogy allows you to learn while building, a proven way for new skills to 'stick'.</p><h4>Supported via GitHub Action (Automated &amp; Always Up-to-Date)</h4><blockquote><p>This repository includes 50+ language translations which significantly increases the download size. To clone without translations, use sparse checkout:</p><pre><code>git clone --filter=blob:none --sparse https://github.com/microsoft/Data-Science-For-Beginners.git\ncd Data-Science-For-Beginners\ngit sparse-checkout set --no-cone '/*' '!translations' '!translated_images'\n</code></pre><p>This gives you everything you need to complete the course with a much faster download.</p></blockquote><p><strong>If you wish to have additional translations languages supported are listed <a href=\"https://github.com/Azure/co-op-translator/raw/main/getting_started/supported-languages.md\">here</a></strong></p><p>We have a Discord learn with AI series ongoing, learn more and join us at <a href=\"https://aka.ms/learnwithai/discord\">Learn with AI Series</a> from 18 - 30 September, 2025. You will get tips and tricks of using GitHub Copilot for Data Science.</p><p>Get started with the following resources:</p><ul><li><a href=\"https://docs.microsoft.com/en-gb/learn/student-hub?WT.mc_id=academic-77958-bethanycheum\">Student Hub page</a> In this page, you will find beginner resources, Student packs and even ways to get a free cert voucher. This is one page you want to bookmark and check from time to time as we switch out content at least monthly.</li></ul><blockquote><p>: New to data science? Start with our <a href=\"https://raw.githubusercontent.com/microsoft/Data-Science-For-Beginners/main/examples/README.md\">beginner-friendly examples</a>! These simple, well-commented examples will help you understand the basics before diving into the full curriculum. : to use this curriculum on your own, fork the entire repo and complete the exercises on your own, starting with a pre-lecture quiz. Then read the lecture and complete the rest of the activities. Try to create the projects by comprehending the lessons rather than copying the solution code; however, that code is available in the /solutions folders in each project-oriented lesson. Another idea would be to form a study group with friends and go through the content together. For further study, we recommend <a href=\"https://docs.microsoft.com/en-us/users/jenlooper-2911/collections/qprpajyoy3x0g7?WT.mc_id=academic-77958-bethanycheum\">Microsoft Learn</a>.</p></blockquote><blockquote><p>üé• Click the image above for a video about the project the folks who created it!</p></blockquote><p>We have chosen two pedagogical tenets while building this curriculum: ensuring that it is project-based and that it includes frequent quizzes. By the end of this series, students will have learned basic principles of data science, including ethical concepts, data preparation, different ways of working with data, data visualization, data analysis, real-world use cases of data science, and more.</p><p>In addition, a low-stakes quiz before a class sets the intention of the student towards learning a topic, while a second quiz after class ensures further retention. This curriculum was designed to be flexible and fun and can be taken in whole or in part. The projects start small and become increasingly complex by the end of the 10 week cycle.</p><ul><li>Optional supplemental video</li><li>For project-based lessons, step-by-step guides on how to build the project</li></ul><blockquote><p>: All quizzes are contained in the Quiz-App folder, for 40 total quizzes of three questions each. They are linked from within the lessons, but the quiz app can be run locally or deployed to Azure; follow the instruction in the  folder. They are gradually being localized.</p></blockquote><h2>üéì Beginner-Friendly Examples</h2><p> We've created a special <a href=\"https://raw.githubusercontent.com/microsoft/Data-Science-For-Beginners/main/examples/README.md\">examples directory</a> with simple, well-commented code to help you get started:</p><ul><li>üåü  - Your first data science program</li><li>üìÇ  - Learn to read and explore datasets</li><li>üìä  - Calculate statistics and find patterns</li><li>üìà  - Create charts and graphs</li><li>üî¨  - Complete workflow from start to finish</li></ul><p>Each example includes detailed comments explaining every step, making it perfect for absolute beginners!</p><table><thead><tr></tr></thead><tbody><tr><td align=\"center\">Learn the basic concepts behind data science and how it‚Äôs related to artificial intelligence, machine learning, and big data.</td></tr><tr><td align=\"center\">Introduction to Statistics &amp; Probability</td><td align=\"center\">The mathematical techniques of probability and statistics to understand data.</td></tr><tr><td align=\"center\">Working with Relational Data</td><td align=\"center\">Introduction to relational data and the basics of exploring and analyzing relational data with the Structured Query Language, also known as SQL (pronounced ‚Äúsee-quell‚Äù).</td></tr><tr><td align=\"center\">Introduction to non-relational data, its various types and the basics of exploring and analyzing document databases.</td></tr><tr><td align=\"center\">Basics of using Python for data exploration with libraries such as Pandas. Foundational understanding of Python programming is recommended.</td></tr><tr><td align=\"center\">Topics on data techniques for cleaning and transforming the data to handle challenges of missing, inaccurate, or incomplete data.</td></tr><tr><td align=\"center\">Visualizing Relationships</td><td align=\"center\">Visualizing connections and correlations between sets of data and their variables.</td></tr><tr><td align=\"center\">Meaningful Visualizations</td><td align=\"center\">Techniques and guidance for making your visualizations valuable for effective problem solving and insights.</td></tr><tr><td align=\"center\">Introduction to the Data Science lifecycle</td><td align=\"center\">Introduction to the data science lifecycle and its first step of acquiring and extracting data.</td></tr><tr><td align=\"center\">This phase of the data science lifecycle focuses on techniques to analyze data.</td></tr><tr><td align=\"center\">This phase of the data science lifecycle focuses on presenting the insights from the data in a way that makes it easier for decision makers to understand.</td></tr></tbody></table><p>Follow these steps to open this sample in a Codespace:</p><ol><li>Click the Code drop-down menu and select the Open with Codespaces option.</li></ol><h2>VSCode Remote - Containers</h2><p>Follow these steps to open this repo in a container using your local machine and VSCode using the VS Code Remote - Containers extension:</p><ol><li>If this is your first time using a development container, please ensure your system meets the pre-reqs (i.e. have Docker installed) in <a href=\"https://code.visualstudio.com/docs/devcontainers/containers#_getting-started\">the getting started documentation</a>.</li></ol><p>To use this repository, you can either open the repository in an isolated Docker volume:</p><p>: Under the hood, this will use the Remote-Containers: <strong>Clone Repository in Container Volume...</strong> command to clone the source code in a Docker volume instead of the local filesystem. <a href=\"https://docs.docker.com/storage/volumes/\">Volumes</a> are the preferred mechanism for persisting container data.</p><p>Or open a locally cloned or downloaded version of the repository:</p><ul><li>Clone this repository to your local filesystem.</li><li>Press F1 and select the <strong>Remote-Containers: Open Folder in Container...</strong> command.</li><li>Select the cloned copy of this folder, wait for the container to start, and try things out.</li></ul><p>You can run this documentation offline by using <a href=\"https://docsify.js.org/#/\">Docsify</a>. Fork this repo, <a href=\"https://docsify.js.org/#/quickstart\">install Docsify</a> on your local machine, then in the root folder of this repo, type . The website will be served on port 3000 on your localhost: .</p><blockquote><p>Note, notebooks will not be rendered via Docsify, so when you need to run a notebook, do that separately in VS Code running a Python kernel.</p></blockquote><p>Our team produces other curricula! Check out:</p><h3>Azure / Edge / MCP / Agents</h3><p>If you get stuck or have any questions about building AI apps. Join fellow learners and experienced developers in discussions about MCP. It's a supportive community where questions are welcome and knowledge is shared freely.</p><p>If you have product feedback or errors while building visit:</p>",
      "contentLength": 6998,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    }
  ],
  "tags": []
}