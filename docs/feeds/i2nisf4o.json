{
  "id": "i2nisf4o",
  "title": "Reddit",
  "displayTitle": "Reddit",
  "url": "",
  "feedLink": "",
  "isQuery": true,
  "isEmpty": false,
  "isHidden": false,
  "itemCount": 175,
  "items": [
    {
      "title": "Deleted my GPT account and ported my AI game project to Claude. Wow!",
      "url": "https://www.reddit.com/r/artificial/comments/1rhqqtw/deleted_my_gpt_account_and_ported_my_ai_game/",
      "date": 1772349003,
      "author": "/u/Necessary-Court2738",
      "guid": 49325,
      "unread": true,
      "content": "<p>I had been working since GPT very first allowed agents to create gaming agents capable of narrating and dreaming up complex game systems while following a verbal command line with minimal hard code. Something a little more involved than a D&amp;D style emulator. My game is called ‚ÄúBioChomps‚Äù a Pok√©mon-esque turn battler where you collect animal parts and merge them into a stronger and stronger abomination. You complete missions to fulfill the progress of becoming the world‚Äôs craziest mad scientist. It features a functional stat system alongside turn-based combat and with abilities narrated by the Ai. There is a Lab-Crawl narrative dungeon crawling option where you take your monster on a narrated journey through a grid dungeon where you encounter all kinds of crazy mad-science hullabaloo. You collect wacky special mutations and animal parts with the risk of being unable to escape the deeper you delve.</p><p>When I learned of the news and with long-standing dissatisfaction with the quality of GPT‚Äôs dreamed up outputs I immediately swapped and deleted my account. Claude was quick on the uptake and with no additional changes to my previous project‚Äôs source files and code, it operates the game at a much higher level with fairly minimal breakdown of content. I help it avoid hallucinations using a code system that prints data every generation with updates from the previous generation.</p><p>The game itself requires a lot of work and I intend to continue, but I wanted to share the first test run of the game outside of the previous network.</p>",
      "contentLength": 1550,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "What the fuck is happening in california?! They're trying to ban Linux to \"Protect the kids\", what?",
      "url": "https://www.reddit.com/r/linux/comments/1rhpxua/what_the_fuck_is_happening_in_california_theyre/",
      "date": 1772346210,
      "author": "/u/Rabbidraccoon18",
      "guid": 49317,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "I built a Claude system prompt that automatically populates NotebookLM notebooks",
      "url": "https://www.reddit.com/r/artificial/comments/1rhpoml/i_built_a_claude_system_prompt_that_automatically/",
      "date": 1772345334,
      "author": "/u/Particular-Welcome-1",
      "guid": 49318,
      "unread": true,
      "content": "<p>I've been using NotebookLM heavily for research and got tired of manually hunting down and adding sources. So I wrote a system prompt that hands the whole process off to Claude.</p><p>When you give it a topic, Claude starts by creating the notebook and drafting a structured research plan for your approval ‚Äî organized into thematic phases and prioritizing academic and institutional sources (arXiv, PubMed, government reports, technical standards) over generic web content. It validates every URL before adding it, fetching and inspecting each one to catch silent 404s, paywalls, and login walls that NotebookLM would otherwise silently accept.</p><p>State is persisted across sessions using notes inside the notebook itself, so when Claude hits its session limit you just start a new conversation, paste the notebook URL, and it picks up where it left off. When the notebook is complete, Claude writes a full  note documenting every source added, skipped, or recommended.</p><p>Happy to answer questions about how it works or how I built it.</p>",
      "contentLength": 1024,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "\"You are humanity personified in 2076\"",
      "url": "https://www.reddit.com/r/artificial/comments/1rhp3xc/you_are_humanity_personified_in_2076/",
      "date": 1772343409,
      "author": "/u/IngenuitySome5417",
      "guid": 49316,
      "unread": true,
      "content": "<p>A continuation of the first time I did this with a narrative of humanity since the dawn of civilization. Really starting to get into these sort of experiments now their compute has been cut. Creative writing has possibly boosted.</p><p>Its 6x LLM outputs that don't fit in here. So... </p>",
      "contentLength": 278,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "[Tutorial] Managing Helm Charts with MCP Server",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rhoffh/tutorial_managing_helm_charts_with_mcp_server/",
      "date": 1772341269,
      "author": "/u/veena_talkops",
      "guid": 49315,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Simple Made Inevitable: The Economics of Language Choice in the LLM Era",
      "url": "https://felixbarbalet.com/simple-made-inevitable-the-economics-of-language-choice-in-the-llm-era/",
      "date": 1772336718,
      "author": "/u/alexdmiller",
      "guid": 49292,
      "unread": true,
      "content": "<p>Two years ago, I <a href=\"https://felixbarbalet.com/leveraging-polylith-to-improve-consistency-reduce-complexity-and-increase-changeability/\" rel=\"noreferrer\">wrote about managing twenty microservices at Qantas</a> with a small team. The problem was keeping services in sync, coordinating changes across system boundaries, fighting the  of a codebase that grew faster than our ability to reason about it. </p><p>Many years before my time, someone had chosen Clojure to build these systems. I suggested we add Polylith - this was a powerful combination because it enabled us to attack that \"entropy\" directly. Composition over coordination. Data over ceremony. Simplicity over familiarity.</p><p>I described it at the time as a \"fight against accidental complexity\" - the stuff that isn't the problem itself, but the overhead imposed by our tools and processes. The stuff that accretes.</p><p>Fast forward to today - I've been watching LLM coding agents struggle with the exact same fight, and I think the choice of language matters far more than most people realise. </p><p>I've used Clojure for a decade, and I'm biased. But I think the  have shifted in ways that make my bias look less like preference and more like - well, let's call it a \"fortunate capital allocation\".</p><h2>The distinction that matters</h2><p>Fred Brooks drew the line in 1986. In \"<a href=\"https://en.wikipedia.org/wiki/No_Silver_Bullet?ref=felixbarbalet.com\" rel=\"noreferrer\">No Silver Bullet</a>,\" he separated the difficulty of software into two categories:  - fundamental to the problem, irreducible - and  - imposed by our tools, languages, and processes. </p><p>Brooks argued that no tool would deliver an order-of-magnitude improvement because most of programming's difficulty is essential. But he also argued that accidental complexity was the  part amenable to radical improvement.</p><p>Rich Hickey picked up that thread and built a programming language around it (Clojure).</p><p>In his 2011 talk \"<a href=\"https://www.youtube.com/watch?v=SxdOUGdseq4&amp;ref=felixbarbalet.com\" rel=\"noreferrer\">Simple Made Easy</a>,\" Hickey drew a distinction that the industry has spent fifteen years : the difference between  (objectively unentangled, not braided together) and  (familiar, near to hand, comfortable). The industry systematically confuses the two. We choose languages because they're easy - because the syntax looks familiar, because we can find developers on LinkedIn, because there are ten thousand Stack Overflow answers for every error message. </p><p>Not many people choose languages because they're simple.</p><p>Hickey's word for accidental complexity is \"incidental.\" As he puts it: \"Incidental is Latin for .\"</p><p>He catalogued the sources with uncomfortable precision. State complects everything it touches. Objects complect state, identity, and value. Methods complect function and state. Syntax complects meaning and order. Inheritance complects types. Every one of these entanglements is a source of accidental complexity that has nothing to do with the problem you're trying to solve.</p><p>Clojure was designed to avoid these entanglements. Immutable data by default. Plain maps instead of class hierarchies. Functions instead of methods. Composition instead of inheritance. It was, and is, a language that optimises for simplicity over ease.</p><p>For fifteen years, the response has been: \"Sure, but the learning curve.\", or \"Sure, but we can't hire Clojure developers, it's too niche.\"</p><p>And there it is. The objections that no longer hold.</p><h2>The learning curve is dead</h2><p>Nathan Marz <a href=\"https://x.com/nathanmarz/status/2022035827103347124?ref=felixbarbalet.com\" rel=\"noreferrer\">recently described building a complex distributed system</a> with Claude Code using Rama, a Clojure framework. Claude absorbed the framework's patterns through a few corrections and some documentation, and then wrote load modules, transaction handlers, and query topologies fluently. </p><p>Marz's conclusion is worth reading carefully:</p><blockquote>\"If AI can absorb a framework's semantics quickly, then the right framework to choose is the one with the best actual abstractions - the one that eliminates the most accidental complexity - regardless of how 'easy to learn' it is for a human picking it up on a weekend. Developer familiarity stops being the dominant selection criterion.\"</blockquote><p>Read that again. <em>Developer familiarity stops being the dominant selection criterion.</em></p><p>Wes McKinney - the creator of pandas, a developer who knows something about language ecosystems - demonstrates this from the other direction. He writes in his recent essay \"<a href=\"https://wesmckinney.com/blog/mythical-agent-month/?ref=felixbarbalet.com\" rel=\"noreferrer\">The Mythical Agent-Month</a>\" that he \"basically does not write code anymore, and now writes tons of code in a language (Go) I have never written by hand.\"</p><p>The barrier to entry for all languages has collapsed. An LLM doesn't look at Clojure's parentheses and feel intimidated. It doesn't need a weekend tutorial. It doesn't care whether the syntax resembles what it learned in university. The \"easy\" axis - familiarity, comfort, prior experience - has been zeroed out.</p><p>What remains is the \"simple\" axis. <strong>The intrinsic quality of the abstractions.</strong></p><p>Thinking like an economist: the learning curve was always a switching cost, not a measure of the language's value. It's easy to confuse the price of entry with the value of the asset. Now, LLMs have driven that switching cost toward zero. What's left is the underlying return on investment - and that's where Clojure was built to compete.</p><p>McKinney's essay contains what I think is the most important observation about LLM-assisted development written so far:</p><blockquote>\"I am already dealing with this problem as I begin to reach the 100 KLOC mark and watch the agents begin to chase their own tails and contextually choke on the bloated codebases they have generated.\"</blockquote><p>He calls this \"technical debt on an unprecedented scale, accrued at machine speed.\"</p><p>Stop me if you've heard this one before. Systems grow and age, they accrete, they accumulate stuff. The accidental complexity compounds until the codebase becomes too large and too tangled for anyone (human or machine) to navigate effectively. I described this at Qantas as a problem of coordination overhead and context-switching costs. McKinney is describing the same phenomenon, accelerated by an order of magnitude.</p><p>The mechanism is straightforward. LLMs are, as McKinney puts it, \"probably the most powerful tool ever created to tackle accidental complexity.\" They can refactor, write tests, clean up messes. But they also  new accidental complexity as a byproduct: \"large amounts of defensive boilerplate that is rarely needed in real-world use,\" \"overwrought solutions to problems when a simple solution would do just fine.\"</p><p>Brooks predicted this. His \"No Silver Bullet\" argument is that agents are brilliant at accidental complexity but struggle with essential design problems - and worse, they can't reliably tell the difference. They attack the accidental complexity with extraordinary capability while simultaneously producing more of it.</p><p>This is where language choice becomes a <strong>capital allocation decision</strong> with compounding returns. The brownfield barrier isn't about whether an LLM  write Python or Go or JavaScript - of course it can. It's about what happens at scale. The cost of a language choice isn't visible in the first ten thousand lines. It's visible at a hundred thousand, when the compounding effects of accidental complexity become the dominant cost. </p><p>Classic economics where marginal cost curves that look flat early and then inflect sharply.</p><h2>Why Clojure pushes the barrier further</h2><p>Clojure attacks this \"brownfield barrier\" from multiple directions simultaneously, and the effects compound.</p><p><a href=\"https://martinalderson.com/posts/which-programming-languages-are-most-token-efficient/?ref=felixbarbalet.com\" rel=\"noreferrer\">Martin Alderson's analysis</a> of Rosetta Code tasks across nineteen popular languages found Clojure to be the most token-efficient. Not by a trivial margin:</p><p>These aren't obscure comparisons. Python, JavaScript, and Java are the three most used languages in the world. Clojure expresses the same logic in roughly a fifth fewer tokens than Python and a third fewer than JavaScript or Java.</p><p>Why does this matter? Because context windows are a hard constraint, and they degrade non-linearly. <a href=\"https://arxiv.org/abs/2307.03172?ref=felixbarbalet.com\" rel=\"noreferrer\">Research from Stanford and Berkeley</a> shows that LLM performance drops by more than 30% when relevant information falls in the middle of the context window. Factory.ai <a href=\"https://factory.ai/news/context-window-problem?ref=felixbarbalet.com\" rel=\"noreferrer\">found</a> that models claiming 200,000 tokens of context become unreliable around 130,000 - a sharp cliff, not a gentle slope. Anthropic <a href=\"https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents?ref=felixbarbalet.com\" rel=\"noreferrer\">describes</a> context engineering as a first-class discipline, noting that \"structured data like code consumes disproportionately more tokens.\"</p><p>If 80% of a coding agent's context window is code - reads, edits, diffs - then Clojure's 19% token advantage over Python translates to roughly 15% more room for actual problem context. Against JavaScript or Java, it's nearly 30% more room. Over a long session with multiple file reads and iterative edits, this compounds. The agent that runs out of useful context first loses.</p><p>And these are just the token-level numbers. At the program level, the difference is starker. Anthony Marcar at WalmartLabs <a href=\"https://devm.io/java/clojure-alternative-java-169315?ref=felixbarbalet.com\" rel=\"noreferrer\">reported that</a> \"Clojure shrinks our code base to about one-fifth the size it would be if we had written in Java.\" A fifth. McKinney's 100 KLOC brownfield barrier in Go could be structurally unreachable in Clojure - not because the agent is smarter, but because there's less accidental complexity for it to choke on.</p><h3><strong>Immutability eliminates defensive boilerplate</strong></h3><p>McKinney specifically identifies that agents \"tend to introduce unnecessary complexity, generating large amounts of defensive boilerplate.\" Null checks. Defensive copies. Synchronisation guards. Clojure's immutable data structures eliminate entire categories of this bloat. The agent literally cannot generate certain kinds of accidental complexity because the language makes it unnecessary.</p><p>As Hickey puts it: \"Values support reproducible results. If you define a function in terms of values, every time you call that function with the same values, will you get the same answer? Yes.\"</p><p>An LLM reasoning about immutable code doesn't need to track  a variable was modified or . It can reason algebraically: this function takes X and returns Y. Full stop. No temporal reasoning required. That's fewer balls to juggle - and as Hickey reminds us, even the best juggler in the world maxes out at about twelve.</p><p>Stuart Halloway made this point devastatingly in his talk \"<a href=\"https://www.youtube.com/watch?v=Qx0-pViyIDU&amp;ref=felixbarbalet.com\" rel=\"noreferrer\">Running With Scissors.</a>\" When you use typed structs or classes, \"all of your data manipulation scissors are gone. You do not have generic data any more. Each one of these structs requires its own custom special scissors to manipulate it.\"</p><p>With Clojure's maps, the LLM learns one toolkit - , , , ,  - that works on  data. With an object-oriented language, the LLM must learn a different API for every class. That's the difference between O(n) and O(n^2) in what the agent must hold in context. As the codebase grows, this gap widens.</p><h3><strong>The REPL closes the feedback loop</strong></h3><p>Halloway's formulation is the best I've seen: \"REPL + Functional = faster bricks. Things that you understand how they are going to work. They always work the same way, and you can compose them to build your system.\" And the dark corollary: \"REPL + imperative = faster spaghetti. If you are a net negative producing developer and we speed you up... we have just made things worse.\"</p><p>An LLM agent at a Clojure REPL can evaluate any expression in the running system, inspect the result, and adjust. No compilation step. No build system. No waiting. The feedback loop is as tight as it gets.</p><p>I should note that the major coding agents today - Claude Code, Codex, Cursor - don't use REPLs. They use file-edit, compile-or-test, read-errors, iterate loops. The industry has implicitly chosen compiler-style feedback. This is worth engaging with honestly.</p><p>But the evidence is more nuanced than it appears. Research on <a href=\"https://genai-evaluation-kdd2024.github.io/genai-evalution-kdd2024/assets/papers/GenAI_Evaluation_KDD2024_paper_25.pdf?ref=felixbarbalet.com\" rel=\"noreferrer\">CodePatchLLM (KDD 2024)</a> found that compiler feedback improves Java and Kotlin code generation by 45% - but provides  improvement for Python, because there's no compiler feedback to give. Dynamic languages get nothing from the compile loop. Replit Agent, <a href=\"https://blog.replit.com/automated-self-testing?ref=felixbarbalet.com\" rel=\"noreferrer\">notably</a>,  use a REPL-based verification system and reports results three times faster and ten times cheaper than previous approaches.</p><p>And Halloway's distinction cuts precisely here. A Python or JavaScript REPL creates exactly the temporal coupling problem that critics identify - mutable state accumulating in the session, order-dependent evaluation, \"faster spaghetti.\" Clojure's REPL evaluates expressions that return immutable values. Data in, data out. No temporal coupling. The REPL provides richer feedback than a compiler - actual return values, not just \"compiled\" or \"didn't\" - while Clojure's immutability means it doesn't create the stateful mess that imperative REPLs do. Clojure-MCP bridges the remaining gap: the agent writes to files and validates in the REPL. Bille reported tasks completing in hours instead of days.</p><p>There's a revealing irony buried in the data. McKinney chose Go for his new projects - a language famous for its simplicity. He writes it via LLM agents and hits the brownfield barrier at 100 KLOC.</p><p>But Go's simplicity is an  simplicity in Hickey's sense. It's familiar. It's readable. You can hire for it. It achieves this through verbosity: explicit error handling on every function call, no generics until recently, no macros, no metaprogramming. For human programmers, this verbosity is a feature - it makes code predictable and reviewable.</p><p>For LLM agents, it's a tax.</p><p>Alderson's data shows Go as one of the more token-inefficient popular languages. Every <code>if err != nil { return err }</code> consumes tokens that could be used for problem context. The language chosen for  simplicity creates  problems. Go is optimised for human-readable code; Clojure is optimised for expressing ideas with minimal ceremony. The LLM era rewards the latter.</p><p>There's a seductive counter argument here: that Go's verbosity actually  the model reason. Verbose output as chain-of-thought scaffolding - the same mechanism that helps LLMs solve maths problems. More tokens, more thinking.</p><p>It's wrong, and the architecture tells you why.</p><p>Modern reasoning models - o1, o3, Claude with extended thinking - do their reasoning in hidden tokens that are discarded after generation. The thinking has already happened before the model outputs a single character of code. Go's <code>if err != nil { return err }</code> is output tokens, not reasoning tokens. It doesn't expand the model's thinking budget. It spends the context budget.</p><p>The empirical evidence is decisive. Research <a href=\"https://proceedings.mlr.press/v267/liu25ah.html?ref=felixbarbalet.com\" rel=\"noreferrer\">presented at ICML 2025</a> found that generating code , then reasoning, yielded a 9.86% improvement over the traditional reason-then-code order. If verbose output were serving as reasoning scaffolding, the opposite should be true. The <a href=\"https://arxiv.org/abs/2512.08266?ref=felixbarbalet.com\" rel=\"noreferrer\">Token Sugar paper (ICSE 2025)</a> systematically compressed high-frequency verbose patterns - exactly the kind Go generates - and achieved up to 15.1% token reduction with near-identical correctness scores. If the boilerplate were contributing to correctness, removing it would degrade performance. It didn't.</p><p>Worse, context dilution research shows that repetitive, low-information tokens actively harm performance by diluting the model's finite attention budget - accuracy drops of 13.9 - 85%. </p><p>Every  repeated fifty times across a codebase isn't scaffolding. It's noise competing for the model's attention with the actual problem.</p><p>Let's assess some of the arguments against my thesis above - some of which are genuinely strong.</p><h3><strong>LLMs are measurably worse at Clojure</strong></h3><p>This is the big one. The <a href=\"https://arxiv.org/abs/2601.02060?ref=felixbarbalet.com\" rel=\"noreferrer\">FPEval benchmark</a> found that GPT-5 generates code with 94% imperative patterns in Scala, 88% in Haskell, and 80% in OCaml. LLMs don't just write worse functional code - they write imperative code  as functional code, and the prevalence of non-idiomatic patterns actually  alongside gains in functional correctness. <a href=\"https://jackpal.github.io/2025/02/03/Solving_AoC_Multiple_Languages.html?ref=felixbarbalet.com\" rel=\"noreferrer\">Jack Palvich's Gemini experiments</a> across twenty-four languages found that \"the Lisps suffer from paren mis-matches and mistakes using standard library functions.\" The <a href=\"https://github.com/nuprl/MultiPL-E?ref=felixbarbalet.com\" rel=\"noreferrer\">MultiPL-E benchmark</a> shows performance correlating with language popularity. And the \"<a href=\"https://arxiv.org/abs/2503.17181?ref=felixbarbalet.com\" rel=\"noreferrer\">LLMs Love Python</a>\" paper found that models default to Python in 93-97% of language-agnostic problems.</p><p>This is real. I'm not going to pretend it isn't.</p><p>But notice what's actually being measured. These benchmarks measure whether the LLM can generate a  in language X. They don't measure whether the resulting  - the codebase at 50 or 100 KLOC - is maintainable, navigable, or tractable for future agent sessions. \"Better at generating Python\" and \"Python generates better systems\" are different claims.</p><p>And the FPEval result is, if you squint, actually evidence  the thesis. If LLMs default to imperative patterns even when writing in functional languages, then the language's  matter more, not less. Clojure's immutability isn't a suggestion - it's a default. The language itself acts as a guardrail. An LLM generating Clojure has fewer ways to produce the kind of stateful, tangled code that compounds into the brownfield barrier. You can't mutate what the language won't let you mutate.</p><p>The parenthesis problem is real but solvable. Julien Bille <a href=\"https://medium.com/@_jba/my-experience-with-cursor-and-clojure-mcp-6e323b90a6f3?ref=felixbarbalet.com\" rel=\"noreferrer\">documented</a> his experience with Clojure-MCP: initially \"simple things took way too long\" and the AI was \"unable to get parentheses right.\" But after integrating s-expression-aware tooling, \"the agent experience got much better\" and \"it goes a LOT faster to write good code solutions.\" The parenthesis issue is a tooling gap, not a fundamental limitation.</p><p>And the training data argument is about the , not the . Models are improving rapidly. The accidental complexity argument is about permanent properties of the language. One is a snapshot; the other is a trajectory.</p><p>And the snapshot is less damning than it looks. <a href=\"https://arxiv.org/abs/2208.08227?ref=felixbarbalet.com\" rel=\"noreferrer\">Cassano et al.'s MultiPL-E study (IEEE TSE, 2023)</a> found that model perplexity - how uncertain the model is when predicting the next token - is not strongly correlated with the correctness of generated code. Codex's perplexity (uncertainty) was highest for JavaScript and TypeScript, yet it performed best on those languages. Some niche languages performed as well as popular ones. Training data volume is not the determinant the gravity well argument assumes.</p><p><a href=\"https://arxiv.org/abs/2308.09895?ref=felixbarbalet.com\" rel=\"noreferrer\">MultiPL-T (OOPSLA, 2024)</a> went further: fine-tuning on automatically translated data closed the gap entirely. Lua exceeded base Python performance after targeted fine-tuning. Julia saw 67% relative improvement. The gap isn't a permanent feature of the landscape - it's bridgeable engineering.</p><p>There's also the question of cross-lingual transfer. Research on scaling laws for code found that training on one language improves performance on related languages. Clojure sits on the JVM. The massive Java training corpus isn't irrelevant - it's a shared ecosystem, shared libraries, shared concepts. </p><h3><strong>Static type systems provide a feedback loop Clojure lacks</strong></h3><p>Also strong. Research <a href=\"https://arxiv.org/abs/2504.09246?ref=felixbarbalet.com\" rel=\"noreferrer\">from ETH Zurich (PLDI 2025)</a> shows that type-constrained decoding reduces compilation errors by more than half and increases functional correctness by 3.5-5.5%. TypeScript advocates report 90% reductions in certain bug categories. Rust's strict compiler creates tight generate-compile-fix loops.</p><p>I'll grant it: types help LLMs get individual functions right. The evidence is clear.</p><p>But types also create coupling. As Hickey argues: \"Statically typed languages yield much more heavily coupled systems. Flowing type information is a major source of coupling in programs.\" Types help the LLM write correct function A. But they also create structural dependencies between A, B, C, and D that make the  harder to reason about as it grows. The question is which effect dominates at scale - and McKinney's brownfield barrier suggests that system-level coupling is the bigger problem.</p><p>Clojure offers a middle path. Spec and <a href=\"https://github.com/metosin/malli?ref=felixbarbalet.com\" rel=\"noreferrer\">Malli</a> provide optional schema validation - type-like constraints when you want them, without the token overhead and coupling when you don't. And the REPL provides a runtime feedback loop that is arguably faster than a compilation cycle: the agent evaluates an expression, sees the result or the error, and corrects immediately.</p><p>This is how I'm leveraging Clojure (and Polylith) while I'm building AXONLORE - components with Malli function schema on every interface, enforced at testing and development time.</p><p>It's also worth noting Alderson's data: Haskell and F#, typed languages with strong inference, are nearly as token-efficient as Clojure. If the type system feedback loop is your priority, those are better choices than TypeScript or Rust, both of which are significantly more token-heavy. But Haskell and F# have their own ecosystem and adoption challenges. There's no free lunch.</p><h3><strong>The ecosystem is small and hiring is hard</strong></h3><p>This is the objection I've spent a decade fielding, and it cuts differently now. If developers aren't writing code by hand, \"knowing Clojure\" matters less than having good design taste - which McKinney identifies as the scarce resource: \"Design talent and good taste are the most scarce resources, and now with agents doing all of the coding labor, I argue that these skills matter more now than ever.\"</p><p>The hiring bottleneck shifts from language fluency to architectural judgement. Clojure developers tend to be more senior and more experienced. That's exactly the profile McKinney says will thrive.</p><p>And on ecosystem: Clojure has access to the entire JVM ecosystem through Java interop. The \"small ecosystem\" argument was always about discoverability for humans - and LLMs don't need Stack Overflow. </p><p>There's one more structural advantage worth noting. Hickey argued in his talk \"<a href=\"https://www.youtube.com/watch?v=oyLBGkS5ICk&amp;ref=felixbarbalet.com\" rel=\"noreferrer\">Spec-ulation</a>\" that \"dependency hell is not a different thing than mutability hell. It IS mutability hell. It is just at this scale.\"</p><p>LLMs are trained on vast codebases. Breaking changes in a language ecosystem mean that the training data contains conflicting information about the same names.  has meant the same thing for seventeen years. Compare that with Python 2 versus 3, React class components versus hooks versus server components, Angular.js versus Angular, or JavaScript's shifting parade of module systems.</p><p>Stability means consistent training signal. Consistent signal means more reliable output. This isn't a flashy advantage, but it's a durable one. When an LLM generates Clojure, it's drawing on seventeen years of consistent semantics. When it generates React, it's navigating a minefield of deprecated patterns, version-specific APIs, and conflicting idioms from different eras of the framework.</p><p>Erik Bernhardsson built a tool called <a href=\"https://github.com/erikbern/git-of-theseus?ref=felixbarbalet.com\" rel=\"noreferrer\">Git of Theseus</a> - after the philosophical paradoxabout the ship whose planks are replaced one by one until nothing original remains. Run it<p>against a Git repository and it shows you what percentage of each year's code survives into</p>the present. The half-life of a line of code in Angular is 0.32 years. In Rails, 2.43<p>years. In Linux, 6.6 years. Linux's longevity, Bernhardsson notes, comes from its</p>modularity - drivers and architecture support scale linearly because they have well-defined<p>interfaces. Each marginal feature takes roughly the same amount of code. Bad projects, on the other hand, scale superlinearly - every marginal feature takes more and more code.</p></p><p>Rich Hickey published code retention charts for Clojure in his ACM paper \"<a href=\"https://docdrop.org/download_annotation_doc/3386321-trk2f.pdf?ref=felixbarbalet.com\" rel=\"noreferrer\">AHistory of Clojure.</a>\" The Clojure chart is nearly flat - almost all code from every releasesurvives into the current version. </p><p>For an LLM, this is the difference between signal and noise. Every breaking change in alanguage's history creates conflicting training data - the same function name meaning<p>different things in different eras. Every renamed API, every deprecated pattern, every</p>framework migration is a source of confusion that the model must navigate<p>probabilistically. Clojure's stability means the probability mass is concentrated. There's</p>one way to use map, one way to use assoc, and that's been true since 2007. The model<p>doesn't have to guess which era of the language it's generating for.</p></p><p>I'm not arguing that Clojure is perfect. I'm arguing that the selection criteria have changed, and we haven't updated our decision-making frameworks to match.</p><p>The industry has - until now - selected languages for human convenience: familiar syntax, large hiring pools, abundant tutorials, massive ecosystems of libraries with thousands of GitHub stars. These were rational criteria when humans wrote the code. They optimised for the dominant constraint.</p><p>But the dominant constraint has shifted. Humans increasingly don't write the code. Machines do. And machines have different constraints: context windows, token efficiency, the ability to reason about entangled state, the compounding cost of accidental complexity at scale.</p><p>The question you should ask is: what's the time horizon?</p><p>If you're building a prototype that needs to work next week, use Python. The LLM is better at it today, the ecosystem is massive, and the brownfield barrier is someone else's problem (perhaps future you?). This is the savings account - safe, familiar, reliable returns.</p><p>If you're building something you plan to maintain for five years, the calculation changes. The language that generates the most maintainable codebase - <strong>the one that produces the least accidental complexity per unit of work</strong>, that fits more meaning into fewer tokens, that constrains the agent away from its worst impulses - that's the language with the higher compounding return. Even if the individual function quality is lower today.</p><p>There's also an uncomfortable possibility lurking here: <strong>that the best language for LLMs might not be any existing language at all</strong>. Perhaps we'll see languages designed from scratch for machine cognition - token-efficient, structurally regular, with built-in verification. But if we're choosing among what exists today, the properties Hickey optimised for seventeen years ago - simplicity, immutability, data orientation, homoiconicity, stability - happen to be exactly what machines need.</p><p>There's an obvious outcome though, at least while humans still choose the tools. Developer preference, hiring committees, LinkedIn keyword searches - these are powerful forces, and they don't evaporate just because the code is being written by a machine. The industryhas spent decades optimising for human convenience, and switching costs are real. It's entirely possible we stick with the popular languages for another decade, not because they're the most efficient allocation of capital, but because the humans holding the cheque books are comfortable with them.</p><p>My bet is on the other outcome. An industry that chose languages for humans will eventually notice that the humans have left the keyboard. And when the constraint you optimised for no longer binds, the economics eventually catch up. They always do.</p>",
      "contentLength": 26310,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rhmyf9/simple_made_inevitable_the_economics_of_language/"
    },
    {
      "title": "Use Fly.io to power Kubernetes LoadBalancer services",
      "url": "https://github.com/zhming0/fly-tunnel-operator",
      "date": 1772332360,
      "author": "/u/zhming0",
      "guid": 49277,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/kubernetes/comments/1rhlh7i/use_flyio_to_power_kubernetes_loadbalancer/"
    },
    {
      "title": "Why does everything gets removed here?",
      "url": "https://www.reddit.com/r/golang/comments/1rhk451/why_does_everything_gets_removed_here/",
      "date": 1772328502,
      "author": "/u/o82",
      "guid": 49276,
      "unread": true,
      "content": "<p>Sorry, this post has been removed by moderators of <a href=\"https://www.reddit.com/r/golang\">r/golang</a>.</p><p>Seriously, what is wrong with the mods of this community?</p><p>I keep finding interesting posts, leaving them open to read later, and when I come back - gone. No explanation. No discussion. Just removed.</p><p>Anything that mentions another language alongside Go? Removed. Any criticism - even constructive, technical criticism? Removed. Comparisons? Tradeoffs? Real-world frustrations? Also removed.</p><p>What's the point of a discussion forum where discussion itself is unwelcome?</p><p>I'm not talking about spam or low-effort posts - obviously that should be moderated. But when normal conversations disappear just because they're not pure praise, it stops feeling like a community and starts feeling like a curated promo page.</p><p>People learn by comparing tools. People improve things by criticizing them. That's how engineering works. Pretending a language has no downsides doesn't make it better - it just makes the conversation worse.</p><p>Threads are vanishing faster than anyone can actually participate in them. It's exhausting.</p><p>I want to enjoy reading and participating here, but what's the point if everything remotely interesting gets wiped?</p><p>Anyone else noticing this, or is it just me?</p>",
      "contentLength": 1222,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "I built go-date-fns: 140+ date utility functions for Go, inspired by date-fns",
      "url": "https://www.reddit.com/r/golang/comments/1rhianu/i_built_godatefns_140_date_utility_functions_for/",
      "date": 1772323566,
      "author": "/u/LazyDog80",
      "guid": 49270,
      "unread": true,
      "content": "<p>I got tired of writing boilerplate date logic in every Go project, so I built</p><p>go-date-fns ‚Äî a comprehensive date utility library inspired by the popular</p><p>JavaScript date-fns library.</p><p>- 140+ pure, immutable functions</p><p>- Business days, ISO weeks, interval utilities</p><p>- FormatDistance (\"about 2 hours ago\")</p><p>- Timezone-aware operations</p><p>- Zero external dependencies</p><p>import \"github.com/chmenegatti/go-date-fns/dateutils\"</p><p>// Add 5 business days (skips weekends)</p><p>deadline := dateutils.AddBusinessDays(time.Now(), 5)</p><p>// Human-readable relative time</p><p>fmt.Println(dateutils.FormatDistanceToNow(deadline, &amp;dateutils.FormatDistanceOptions{AddSuffix: true}))</p><p>Coming from JavaScript? The API will feel very familiar.</p>",
      "contentLength": 686,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Data Range intersection Lib",
      "url": "https://www.reddit.com/r/golang/comments/1rhhv7m/data_range_intersection_lib/",
      "date": 1772322478,
      "author": "/u/Obvious-Image-9688",
      "guid": 49266,
      "unread": true,
      "content": "<p>Implements the universal span intersection algorithm. The algorithm represents a unified way to find intersections and overlaps of \"one dimensional spans\" of any data type. The package is built around the SpanUtil[E any] struct, and the manipulation of the SpanBoundry[E any] interface.</p><p>The SpanUtils[E any] struct requires 2 methods be passed to the constructor in order to implement the algorithm:</p><ul><li>A \"Next\" function, takes a given value and returns next value. The next value must be greater than the input value</li></ul><p>The algorithm is primarily implemented by 3 methods of the SpanUtil[E] struct:</p><ul><li>FirstSpan, finds the initial data span intersection.</li><li>NextSpan, finds all subsequent data span intersections.</li><li>CreateOverlapSpan, finds the most common intersection of all overlapping spans.</li></ul><p>Other features of this package:</p><ul><li>Provide ways to consolidate overlaps.</li><li>Iterate through intersections of multiple data sets.</li></ul><p>In this example we will find the intersections of 3 sets of integers. The full example can be found: <a href=\"https://github.com/akalinux/span-tools/blob/main/examples/example01/example01.go\">here</a>.</p><p><strong>Setup the package and imports:</strong></p><p>We will need to import our \"st\" package along with the \"fmt\" and \"cmp\" packages in order to process the example data sets.</p><pre><code>import ( \"github.com/akalinux/span-tools\" \"fmt\" \"cmp\" ) </code></pre><p><strong>Create our SpanUtil[E] instance:</strong></p><p>We will use the factory interface NewSpanUtil to generate our SpanUtil[int] instance for these examples. This ensures that the Validate and Sort options are by set to true for all base examples.</p><pre><code>var u=st.NewSpanUtil( // use the standard Compare function cmp.Compare, // Define our Next function func(e int) int { return e+1}, ) </code></pre><p><strong>Find our the initial SpanBoundry intersection:</strong></p><p>We need to find the initial intersection, before we can iterate through of these data sets. The initial SpanBoundry is found by making a call to u.FirstSapn(list).</p><pre><code>// Create our initial span var span,ok=u.FirstSpan(list) // Denote our overlap set position var count=0 </code></pre><p><strong>Iterate through all of our SpanBoundry intersections:</strong></p><p>We can now step through each data intersection point and output the results. Each subsequent intersection is found by making a call to u.NextSpan(span,list).</p><pre><code>for ok { // Get the indexes of the columns this overlap relates to var sources=u.GetOverlapIndexes(span,list) // output our intersection data fmt.Printf(\"Overlap Set: %d, Span: %v, Columns: %v\\n\",count,span,sources) // update our overlap set count++ // get our next set span,ok=u.NextSpan(span,list) } </code></pre><pre><code>Overlap Set: 0, Span: &amp;{1 1}, Columns: &amp;[0] Overlap Set: 1, Span: &amp;{2 2}, Columns: &amp;[0 1] Overlap Set: 2, Span: &amp;{3 5}, Columns: &amp;[1 2] Overlap Set: 3, Span: &amp;{6 7}, Columns: &amp;[1 2] Overlap Set: 4, Span: &amp;{8 11}, Columns: &amp;[2] </code></pre>",
      "contentLength": 2621,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "pending: minimal pure-Go deferred task scheduler (ID debounce + cancel + graceful shutdown)",
      "url": "https://www.reddit.com/r/golang/comments/1rhdj9c/pending_minimal_purego_deferred_task_scheduler_id/",
      "date": 1772311571,
      "author": "/u/Hungry-Plantain-1008",
      "guid": 49256,
      "unread": true,
      "content": "<div><p>I released pending, a tiny scheduler for in-memory deferred work in Go:</p><ul><li>ID-based scheduling and debouncing (reschedule same ID)</li><li>concurrency limits: StrategyBlock / StrategyDrop</li><li>zero dependencies (stdlib only)</li></ul><p>It‚Äôs deliberately not cron syntax or persistent job storage. Target use case is process-local deferred actions.</p><p>Would love feedback on API design and edge cases I should harden.</p></div>   submitted by   <a href=\"https://www.reddit.com/user/Hungry-Plantain-1008\"> /u/Hungry-Plantain-1008 </a>",
      "contentLength": 426,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "How suitable is Golang for building an eCommerce website?",
      "url": "https://www.reddit.com/r/golang/comments/1rhdfon/how_suitable_is_golang_for_building_an_ecommerce/",
      "date": 1772311336,
      "author": "/u/Worth-Leader3219",
      "guid": 49257,
      "unread": true,
      "content": "<p>How suitable is Golang for building an eCommerce website?</p><p>I‚Äôve been searching online but haven‚Äôt found any ready-to-use frameworks or boilerplates specifically for building eCommerce websites with Golang.</p><p>Do you have any experience building eCommerce sites with Golang?</p><p>I‚Äôm also interested to know whether it‚Äôs possible to build both the backend and frontend using pure Golang and Go libraries only, instead of separating the frontend into another language or framework?</p>",
      "contentLength": 475,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Segment Anything with One mouse click",
      "url": "https://eranfeit.net/one-click-segment-anything-in-python-sam-vit-h/",
      "date": 1772309264,
      "author": "/u/Feitgemel",
      "guid": 49271,
      "unread": true,
      "content": "<p>Last Updated on 30/01/2026 by Eran Feit</p><h2></h2><p><code>Segment Anything in Python lets you segment any object with a single click using SAM ViT-H, delivering three high-quality masks instantly.</code><code>In this tutorial, you‚Äôll set up the environment, load the checkpoint, click a point, and export overlays‚Äîclean, practical code included.</code><code>Whether you‚Äôre labeling datasets or prototyping, this one-click workflow is quick, reliable, and easy to reuse.</code></p><p>Segment Anything in Python builds on a powerful promptable segmentation pipeline: a ViT-H image encoder extracts features once, a lightweight prompt encoder turns your click into guidance, and a mask decoder returns multiple high-quality candidates. This tutorial shows the exact flow‚Äîload the checkpoint, set the image, provide a single positive point, and review three masks with scores‚Äîso you can pick the cleanest boundary without manual tracing.</p><p>Segment Anything in Python is also practical beyond demos: you‚Äôll learn how to avoid OpenCV headless conflicts, run on CPU/GPU/MPS, and export overlays for quick sharing. We also cover adding negative points to suppress spillover, saving binary masks for downstream tasks, and keeping your run reproducible with clear paths and model_type matching. Use it to bootstrap datasets, refine labels, or prototype segmentations in seconds.</p>\n\n\n\nFor a deeper dive into automatic mask creation from detections, see my post on <a href=\"https://eranfeit.net/yolov8-object-detection-with-jetson-nano-and-opencv/\">YOLOv8 object detection with Jetson Nano and OpenCV</a>.\n\n\n\n<p>üöÄ Want to get started with Computer Vision or take your skills to the next level ?</p><h2></h2><p>Create a conda environment, install PyTorch (CUDA optional), and add the key libraries: , , and .These steps make your runtime stable and reproducible.</p><p>You‚Äôre creating an isolated Python 3.9 environment, ensuring compatible PyTorch/CUDA, installing OpenCV + Matplotlib, and pulling SAM directly from the official repo.</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p> after this step, your machine is ready to run SAM and display interactive windows.</p><h2></h2><p>Import NumPy, PyTorch, Matplotlib, OpenCV, then add three tiny helpers to draw masks, points, and boxes.<p>These functions make SAM‚Äôs results easy to see.</p></p><p>You‚Äôll visualize the clicked point (green star), optional negatives (red), and overlay semi-transparent masks on the image.</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p> your visual overlays are ready‚Äîclicks and masks will be easy to inspect.</p>\n\n\n\nIf you prefer a full framework, check out <a href=\"https://eranfeit.net/detectron2-panoptic-segmentation-made-easy-for-beginners/\">Detectron2 panoptic segmentation made easy for beginners</a> for training-ready pipelines.\n\n\n\n<h2></h2><p>Load an image, open an OpenCV window, and  the object once.Press  to confirm and capture the coordinates.</p><p>You‚Äôll build a tiny helper function that returns the (x, y) coordinates of your click‚ÄîSAM‚Äôs only required input in this flow.</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p> you now have a single (x, y) pointing to the object‚ÄîSAM will do the rest.</p>\n\n\n\nWant point-based interaction in videos? See <a href=\"https://eranfeit.net/segment-anything-python-no-training-image-masks/\">Segment Anything in Python ‚Äî no training, instant masks</a> for more live demos.\n\n\n\n<h2></h2><p>Load the SAM checkpoint (ViT-H), move it to GPU if available, and attach a .Then set the current image so SAM can compute features.</p><p>This step binds the model + image together and readies the predictor for your single click.</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p> SAM is loaded, on the right device, and primed with your image.</p>\n\n\n\nIf you‚Äôre exploring medical or structured masks, compare with <a href=\"https://eranfeit.net/u-net-medical-segmentation-with-tensorflow-and-keras-polyp-segmentation/\">U-Net medical segmentation with TensorFlow &amp; Keras</a>.\n\n\n\n<h2></h2><p>Turn your (x, y) into SAM inputs, get , show them, and save each result.You‚Äôll see mask scores to help you pick your favorite.</p><p>You‚Äôll get three high-quality segmentations and PNGs saved to disk for later use.</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p> you now have three crisp segmentations saved‚Äîchoose the best and keep creating.</p>\n\n\n\nNext, try improving mask quality with post-processing or super-resolution: <a href=\"https://eranfeit.net/upscale-your-images-and-videos-using-super-resolution/\">upscale your images and videos using super-resolution</a>.\n\n\n\n<div itemscope=\"\" itemtype=\"https://schema.org/FAQPage\"><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><h3 itemprop=\"name\"></h3><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">SAM is a general-purpose segmentation model that returns object masks from simple prompts like a single click. It‚Äôs ideal for fast labeling and prototyping.</p></div></div><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><h3 itemprop=\"name\"></h3><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">Use ViT-H for best quality. Use ViT-L/B for lower memory. Match model_type to your checkpoint name.</p></div></div><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">No, but GPU or Apple MPS speeds up inference significantly. CPU works, just slower.</p></div></div><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><h3 itemprop=\"name\"></h3><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">Compare the three candidates by score and visual quality. Choose the one that cleanly captures your object.</p></div></div><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><h3 itemprop=\"name\"></h3><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">Yes. Label 0 for background to suppress unwanted regions. Mix positives and negatives for precision.</p></div></div><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><h3 itemprop=\"name\"></h3><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">Use opencv-python (GUI) instead of the headless build. The post includes a cleanup step.</p></div></div><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><h3 itemprop=\"name\"></h3><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">Anywhere. Update the code‚Äôs path_for_sam_model to match your file location.</p></div></div><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><h3 itemprop=\"name\"></h3><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">Yes. The code saves overlay images. You can also save binary masks by converting to 0/255 and writing with OpenCV.</p></div></div><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">Yes. SAM accepts points and bounding boxes. Boxes help guide segmentation when objects are crowded.</p></div></div><div itemscope=\"\" itemprop=\"mainEntity\" itemtype=\"https://schema.org/Question\"><h3 itemprop=\"name\"></h3><div itemscope=\"\" itemprop=\"acceptedAnswer\" itemtype=\"https://schema.org/Answer\"><p itemprop=\"text\">Absolutely. One-click masks are a quick way to bootstrap datasets or refine labels with minimal effort.</p></div></div></div><p>You‚Äôve just built a complete  tool around  in Python.The workflow is intentionally lightweight: create an environment, install SAM, click a point, and export masks.<p>Because SAM generalizes broadly, it‚Äôs excellent for new domains where you don‚Äôt have labeled data yet.</p>From here, you can add negative clicks for refinement, use bounding boxes, or integrate with super-resolution and post-processing to lift mask quality even further.</p><p>If you plan to use this in production, consider wrapping the flow in a small GUI, storing your clicks/masks, and adding batch processing for entire image sets.For research, this pipeline is a fantastic way to prototype and compare segmentations across different scenes quickly.</p>",
      "contentLength": 5455,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rhckl3/segment_anything_with_one_mouse_click/"
    },
    {
      "title": "How do you handle all these AI subscribtions?",
      "url": "https://www.reddit.com/r/artificial/comments/1rhbyyd/how_do_you_handle_all_these_ai_subscribtions/",
      "date": 1772307856,
      "author": "/u/tdjordash",
      "guid": 49289,
      "unread": true,
      "content": "<p>how do you guys handle all these AI subscriptions? CLAUDE, ChatGpt, Gemini, Grok, Perplexity,Poe... they're all like $20/mo each do you just pick one? Or pay for 2 or more? Or use something that combines them.?...is it even worth paing for any of these? What's your setup?</p>",
      "contentLength": 272,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "A Rabbit Hole Called WebGL (8-part series on the technical background of a WebGL application w/ functional demo)",
      "url": "https://www.hendrik-erz.de/post/a-rabbit-hole-called-webgl",
      "date": 1772306089,
      "author": "/u/nathan_lesage",
      "guid": 49237,
      "unread": true,
      "content": "<p>I have this tradition. At least, it appears like a tradition, because it happens with frightening regularity. Every one to two years, as Christmas draws close, I get this urge to do something new. In 2017, I released a tiny tool that has turned into one of the go-to solutions for hundreds of thousands of people to write, <a href=\"https://www.zettlr.com/\">Zettlr</a>. In 2019, I wrote my first <a href=\"https://github.com/nathanlesage/visualizrs\">Rust program</a>. In 2021, I did a <a href=\"https://www.hendrik-erz.de/post/analyse-koalitionsvertrag-2021-spd-grune-fdp-ampel\">large-scale analysis of the coalition agreement</a> of the German ‚ÄúTraffic light‚Äù government. During the pandemic, I built a bunch of mechanical keyboards (because  I did). In 2023, I didn‚Äôt really do much, but in 2024, I wrote a <a href=\"https://www.hendrik-erz.de/post/localchat-chat-with-an-ai-assistant-on-your-computer\">local LLM application</a>. So okay, it‚Äôs not necessarily every year, but if you search this website, you‚Äôll find many tiny projects that I used to distract myself from especially dire stretches in my PhD education.</p><p>Now, is it a good use of my time to spend it on some weird technical topics instead of doing political sociology? I emphatically say yes. If you are a knowledge-worker, you need to keep your muscles moving. Even as a researcher, if you do too much of the same thing, you become less of a knowledge-worker, and more of a secretary. Call it an artistic outlet, that just so happens to make my research job . The last time I had to think about wrong data structures in my analytical code or when running some linear regression was ‚Ä¶ let‚Äôs say a long time ago. The more I know about software and hardware, the more I can actually focus on my research questions when I turn to the next corpus of text data.</p><p>But alright, you didn‚Äôt click on this article because you wanted to hear me rationalize my questionable life choices, you want to read up on the next rabbit hole I fell into: OpenGL and WebGL. In the following, I want to walk you through the core aspects of what WebGL is and what you can do with it, what I actually did with it, and what the end result was. If you‚Äôre not into technical topics (which, given the history of articles here, I actually have to start to doubt at this point), <a href=\"https://nathanlesage.github.io/iris-indicator/\">click here to see the full glory of my recent escapade</a>.</p><blockquote><p>Note: In the following, I will skip over a lot of basics, and merely explain some interesting bits of the source code (<a href=\"https://github.com/nathanlesage/iris-indicator\">which you can find here</a>), central decisions I took, and things I learned. I don‚Äôt verbatim copy the entire code that you can find <a href=\"https://github.com/nathanlesage/iris-indicator\">in the repository</a>. The entire thing is still insanely long and will span multiple articles, even though I try to leave out a lot which you can learn via, e.g., <a href=\"https://webgl2fundamentals.org/\">WebGLFundamentals</a>, which I recommend you read to learn more.</p></blockquote><p>First, some context. At the end of 2024, <a href=\"https://github.com/Zettlr/Zettlr/issues/5414\">someone complained</a> that project exports in my app, Zettlr, were lacking any visual indication of their progress. As a quick primer: Zettlr uses Pandoc to convert Markdown to whichever format you choose. However, especially for long projects, exporting may take quite some time, during which the app looks as if it‚Äôs doing nothing. You can still work with the app, and do things, but it‚Äôs hard to know when Zettlr is actually done performing the project export. The biggest issue was less finding a way to just  users which background tasks are currently running, and more how to adequately visualize this to them. For quite a bit of time, my brain kept churning idea after idea in the search for a cool way to visualize ‚Äúsomething is happening in the background.‚Äù You can read up on many discussions that I‚Äôve had with Artem in the <a href=\"https://github.com/Zettlr/Zettlr/issues/5414\">corresponding issue</a> on the issue tracker.</p><p>Indeed, the task was quite massive, because the requirements were so odd:</p><ul><li>The indication should convey a sense of ‚Äúsomething is happening‚Äù without actually knowing the precise progress of the task being performed.</li><li>It should quickly and easily convey how many tasks are currently running in the background, and what their status is.</li><li>It should be so compact that it fits into a toolbar icon.</li><li>It should absolutely avoid giving people the impression that something might be stuck.</li></ul><p>At some point, I had my  moment: Why not produce an iris-like visualization? Intuitively, it ticked all the boxes: One can animate the picture to convey a sense of movement without looking like a run-of-the-mill loading spinner that we have collectively come to dread; by coloring its segments, one can include several ‚Äúthings‚Äù with different status; and by toggling between an ‚Äúon‚Äù- and ‚Äúoff‚Äù-state, one could indicate whether something is running, or not.</p><p>I currently suspect that my brain simple mangled together the circular appearance of a loading spinner and the <a href=\"https://www.3blue1brown.com/\">logo of 3Blue1Brown</a> into a contraption that would prove to be insanely difficult to create.</p><p>Because I wanted to convey a lot of subtle movement, I opted to choose WebGL to implement it, using all the fanciness of graphics processing. My thinking was as follows: I could combine something I‚Äôd have to do at some point anyway with something new to learn. I thought: ‚ÄúHow hard can it be to learn some shader programming on the side?‚Äù</p><p>‚Ä¶ well, if you‚Äôve read until here, you know that I was  so wrong with my estimate of how long it would take as this time. What started as a ‚Äúlet me hack something together in two Christmas afternoons‚Äù ended up being an almost two-week intensive endeavor that has had my partner get  mad at me for spending so much time in front of my computer.</p><p>But now, it is done, and I have succeeded in achieving exactly what I had imagined weeks ago. To salvage what I can, I am writing these lines to let you partake in my experience, and maybe you find understanding the guts of GPU-accelerated rendering on the web even intriguing!</p><p>On the page, there are four sections: Some settings, configuration for the segments, a frame counter, and the actual animation below that.</p><p>Let me guide you through the settings first:</p><ul><li>: This setting sets how long it takes for the indicator to rotate once around. By default it is set to 120 seconds, so two minutes, but you can turn it down to increase its speed. The minimum setting is 10 seconds which is quite fast.</li><li>: This setting determines how fast the individual rays will increase and shrink in size. It is pre-set to five seconds for one full movement, but you can turn it down to increase their speed. The minimum is 100ms, which is stupidly fast.</li><li>: This enables or disabled multi-sample antialiasing. If disabled, the animation can look very rugged and pixelated.</li><li>: This setting enables or disables the bloom effect which makes the entire indicator ‚Äúglow.‚Äù This can actually reduce the performance of the animation quite a bit, but it also has a great visual impact.</li><li>: This effectively allows you to determine how much blurring will be applied to the image. It is preset to 2√ó, which is a good default. You can reduce it to 1√ó which will make the effect more subtle. A setting of 8√ó may be a bit much, but I decided to leave it in since I feel it is instructive.</li><li>: This setting determines how detailed the resolution is. It is preset with whatever device pixel ratio your display has. If you‚Äôre opening the website on a modern phone or on a MacBook, it will probably be preset to 2√ó, but on other displays, it will be 1√ó. It has a moderate performance impact.</li><li><strong>Segment adjustment step duration</strong>: This setting determines how fast the segment colors adjust when you change the segment counts in the next section.</li></ul><p>The next section allows you to determine the segments that will be displayed. As a reminder: The whole intention of this project was to visualize the status of running tasks, which might be successful, unsuccessful, or still en route. You have four segments available, and can determine how many tasks are in each segment, alongside their color. The colors are hard-coded because this way I can ensure that they all fit and blend together well.</p><p>By default, the demonstration page will auto-simulate changes to the segments so that you don‚Äôt have to click around. When the simulation is active it will, each second, determine what to do. There is a 30% chance each that one of the first three segments will be incremented by one. Further, there is a 10% chance that the simulation will reset everything to zero and start again.</p><p>The last section includes settings for the frame rate. The frame rate simply means how often the entire animation will be re-drawn (hence, frames-per-second). At the top, it displays the current frame rate. The frame rate is bound to your display, so on a MacBook (which has a refresh rate of 120 Hz), the frame rate will be at most 120 frames per second. On my secondary display, the frame rate is 75 Hz.</p><p>By default, I have implemented a frame limit of at most 30 frames per second. This ensures that the animation is still smooth without being too demanding on your computer or phone. However, you can change the frame rate to, e.g., 60 fps. This will render the animation twice as frequently. Especially if you turn the rotation speed to the max, you actually want to increase the frame limit, because on 30 frames per second, it can indeed look very stuttery.</p><p>Feel free to play around with the settings to see how they change the animation. Again, you can also go through <a href=\"https://github.com/nathanlesage/iris-indicator\">the source code of the animation</a> to learn how it works.</p><h2>About This Article Series</h2><p>Over the next three months, I will publish one part per week on how I finally managed to achieve this feat. The logic behind it is very complex, and it takes a lot of research to understand how to achieve the various effects. The articles will be as follows:</p><p>In the next article, I will introduce you to WebGL, OpenGL, and how to set everything up to actually start doing things with WebGL. I will talk about the basic architectural decisions I took, and how code can be properly organized. I will also introduce you to OpenGL‚Äôs rendering pipeline, and how it works.</p><p>In article three, I will guide you to drawing the rays that make up the iris. You will learn about how to provide data to OpenGL, and how the drawing actually works.</p><p>In the fourth installment, I will talk through how to add two of the three animations that make up the iris: rotation, and the movement of the rays. This article almost exclusively focuses on JavaScript, and contains minimal changes to the shaders, because movement is mostly a thing of JavaScript.</p><p>In article five, I will introduce you to the algorithm I designed to both color the segments of the iris according to the number of running tasks, i.e., the main goal of the entire endeavor. I will also explain the final, third animation that the indicator includes: animating the colors of the iris.</p><p>This article will be more in-depth and explain another big part of OpenGL‚Äôs rendering pipeline. It explains how to enable a renderer to perform post-processing. It also adds one post-processing step: tone-mapping.</p><p>Article seven focuses on the centerpiece of the animation, the one big part that would not have been possible using other techniques such as SVG. I explain how to add a bloom post-processing step in between the ray rendering and the output, and how bloom actually works. (It‚Äôs surprisingly simple!)</p><h3>Adding Multi-Sample Antialiasing</h3><p>In the eight and final practical article in this series, I explain MSAA a bit more in detail, why it sometimes works, and sometimes doesn‚Äôt, and how to actually add it to the animation. I also explain the final piece of the OpenGL Rendering pipeline that you probably need to know to understand what is happening.</p><p>When I set out to create this animation, I imagined it would take me maybe two days ‚Äî nothing to write home about (literally). However, I was wrong, and, to the contrary, we are now looking towards an astonishing nine (!) articles just to explain what has happened here.</p><p>I found the journey extremely rewarding, even though it ate up my winter holidays. I want to let you partake in what I learned, and I hope you stick along for the ride.</p><p>So, please, come back next Friday for part two: Setting everything up!</p><p>Jump directly to an article that piques your interest.</p>",
      "contentLength": 11959,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rhb89v/a_rabbit_hole_called_webgl_8part_series_on_the/"
    },
    {
      "title": "MQTT: The Protocol Behind Every Smart Device (Golang)",
      "url": "https://youtu.be/S64crfW9tQU",
      "date": 1772305420,
      "author": "/u/huseyinbabal",
      "guid": 49236,
      "unread": true,
      "content": "<!DOCTYPE html>",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rhaxyp/mqtt_the_protocol_behind_every_smart_device_golang/"
    },
    {
      "title": "MQTT: The Protocol Behind Every Smart Device (Golang)",
      "url": "https://youtu.be/S64crfW9tQU",
      "date": 1772305374,
      "author": "/u/huseyinbabal",
      "guid": 49235,
      "unread": true,
      "content": "<!DOCTYPE html>",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rhax97/mqtt_the_protocol_behind_every_smart_device_golang/"
    },
    {
      "title": "I built a tool to automate your workflow after recording yourself doing the task once (Open Source)",
      "url": "https://v.redd.it/6q1swgl96amg1",
      "date": 1772304282,
      "author": "/u/bullmeza",
      "guid": 49293,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rhag6l/i_built_a_tool_to_automate_your_workflow_after/"
    },
    {
      "title": "Exclusive interview: Anthropic CEO Dario Amodei on Pentagon feud",
      "url": "https://youtu.be/MPTNHrq_4LU",
      "date": 1772303766,
      "author": "/u/CBSnews",
      "guid": 49234,
      "unread": true,
      "content": "<!DOCTYPE html>",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rha87x/exclusive_interview_anthropic_ceo_dario_amodei_on/"
    },
    {
      "title": "I built a 1 GiB/s file encryption CLI using io_uring, O_DIRECT, and a lock-free triple buffer",
      "url": "https://www.reddit.com/r/rust/comments/1rh9tj5/i_built_a_1_gibs_file_encryption_cli_using_io/",
      "date": 1772302816,
      "author": "/u/supergari",
      "guid": 49239,
      "unread": true,
      "content": "<p>I got frustrated with how slow standard encryption tools (like GPG or age) get when you throw a massive 50GB database backup or disk image at them. They are incredibly secure, but their core ciphers are largely single-threaded, usually topping out around 200-400 MiB/s.</p><p>I wanted to see if I could saturate a Gen4 NVMe drive while encrypting, so I built .</p><p>I started out just mapping files into memory, but to hit multi-gigabyte/s throughput without locking up the CPU or thrashing the kernel page cache, the architecture evolved into something pretty crazy:</p><ul><li><strong>Lock-Free Triple-Buffering:</strong> Instead of using async MPSC channels (which introduced severe lock contention on small chunks), I built a 3-stage rotating state machine. While io_uring writes batch N-2 to disk, Rayon encrypts batch N-1 across all 12 CPU cores, and io_uring reads batch N.</li><li> I wrote a custom 4096-byte aligned memory allocator using std::alloc. This pads the header and chunk slots so the Linux kernel can bypass the page cache entirely and DMA straight to the drive.</li><li> It uses ring for assembly-optimized AES-256-GCM and ChaCha20-Poly1305. To prevent chunk-reordering attacks, it uses a TLS 1.3-style nonce derivation (base_nonce XOR chunk_index).</li><li> The full serialized file header (which contains the Argon2id parameters, salt, and base nonce) plus an is_final flag are bound into every single chunk's AAD. This mathematically prevents truncation and append attacks.</li></ul><p>It reliably pushes  entirely CPU-bound, and scales beautifully with cores.</p><p>The README has a massive deep-dive into the binary file format, the memory alignment math, and the threat model. I'd love for the community to tear into the architecture or the code and tell me what I missed.</p><p>Let me know what you think!</p>",
      "contentLength": 1737,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Yes, and...",
      "url": "https://htmx.org/essays/yes-and/",
      "date": 1772301689,
      "author": "/u/BinaryIgor",
      "guid": 49238,
      "unread": true,
      "content": "<p>I teach computer science at <a rel=\"noopener\" target=\"_blank\" href=\"https://www.cs.montana.edu\">Montana State University</a>.  I am the father of three sons who\nall know I am a computer programmer and one of whom, at least, has expressed interest in the field.  I love computer\nprogramming and try to communicate that love to my sons, the students in my classes and anyone else who will listen.</p><p>A question I am increasingly getting from relatives, friends and students is:</p><blockquote><p>Given AI, should I still consider becoming a computer programmer?</p></blockquote><p>My response to this is: ‚ÄúYes, and‚Ä¶‚Äù</p><p>Computer programming is, fundamentally, about two things:</p><ul><li>Problem-solving using computers</li><li>Learning to control complexity while solving these problems</li></ul><p>I have a hard time imagining a future where knowing how to solve problems with computers and how to control the complexity\nof those solutions is  valuable than it is today, so I think it will continue to be a viable career even with the\nadvent of AI tools.</p><p>That being said, I view AI as very dangerous for junior programmers because it  able to effectively generate code for\nmany problems.  If a junior programmer does not learn to write code and simply generates it, they are robbing\nthemselves of the opportunity to develop the visceral understanding of code that comes with being down in the trenches.</p><p>Because of this, I warn my students:</p><p>‚ÄúYes, AI can generate the code for this assignment. Don‚Äôt let it. You  to write the code.‚Äù</p><p>I explain that, if they don‚Äôt write the code, they will not be able to effectively  the code.  The ability to\nread code is certainly going to be valuable, maybe  valuable, in an AI-based coding future.</p><p>I do not agree with this simile.</p><p>Compilers are, for the most part, deterministic in a way that current AI tools are not.  Given a high-level programming\nlanguage construct such as a for loop or if statement, you can, with reasonable certainty, say what the generated\nassembly will look like for a given computer architecture (at least pre-optimization).</p><p>The same cannot be said for an LLM-based solution to a particular prompt.</p><p>High level programming languages are a  way to create highly specified solutions to problems\nusing computers with a minimum of text in a way that assembly was not.  They eliminated a lot of\n<a rel=\"noopener\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/No_Silver_Bullet\">accidental complexity</a>, leaving (assuming the code was written\nreasonably well) mostly necessary complexity.</p><p>LLM generated code, on the other hand, often does not eliminate accidental complexity and, in fact, can add\nsignificant accidental complexity by choosing inappropriate approaches to problems, taking shortcuts, etc.</p><p>If you can‚Äôt read the code, how can you tell?</p><p>And if you want to read the code you must write the code.</p><p>Another thing that I tell my students is that AI, used properly, is a tremendously effective TA.  If you don‚Äôt use it\nas a code-generator but rather as a partner to help you understand concepts and techniques, it can provide a huge boost\nto your intellectual development.</p><p>One of the most difficult things when learning computer programming is getting ‚Äústuck‚Äù.  You just don‚Äôt see the trick\nor know where to even start well enough to make progress.</p><p>Even worse is when you get stuck due to accidental complexity: you don‚Äôt know how to work with a particular tool chain\nor even what a tool chain is.</p><p>This isn‚Äôt a problem with , this is a problem with your environment.  Getting stuck pointlessly robs you of time to\nactually be learning and often knocks people out of computer science.</p><p>(I got stuck trying to learn Unix on my own at Berkeley, which is one reason I dropped out of the computer science\nprogram there.)</p><p>AI can help you get past these roadblocks, and can be a great TA if used correctly.  I have posted an\n<a rel=\"noopener\" target=\"_blank\" href=\"https://gist.github.com/1cg/a6c6f2276a1fe5ee172282580a44a7ac\">AGENTS.md</a> file that I provide to my students to configure\ncoding agents to behave like a great TA, rather than a code generator, and I encourage them to use AI in this role.</p><p>AI doesn‚Äôt  to be a detriment to your ability to grow as a computer programmer, so long as it is used\nappropriately.</p><p>I do think AI is going to change computer programming.  Not as dramatically as some people think, but in some\nfundamental ways.</p><p>It may be that the  of coding will lose  value.</p><p>I regard this as too bad: I usually like the act of coding, it is fun to make something do something with your\n(metaphorical) bare hands.  There is an art and satisfaction to writing code well, and lots of aesthetic decisions to be\nmade doing it.</p><p>However, it does appear that raw code writing prowess may be less important in the future.</p><p>As this becomes relatively less important, it seems to me that other skills will become more important.</p><p>For example, the ability to write, think and communicate clearly, both with LLMs and humans seems likely to be much more\nimportant in the future.  Many computer programmers have a literary bent anyway, and this is a skill that will likely\nincrease in value over time and is worth working on.</p><p>Reading books and writing essays/blog posts seem like activities likely to help in this regard.</p><p>Another thing you can work on is turning some of your mental energy towards understanding a business (or government\nrole, etc) better.</p><p>Computer programming is about solving problems with computers and businesses have plenty of both of these.</p><p>Some business folks look at AI and say ‚ÄúGreat, we don‚Äôt need programmers!‚Äù, but it seems just as plausible to me that\na programmer might say ‚ÄúGreat, we don‚Äôt need business people!‚Äù</p><p>I think both of these views are short-sighted, but I do think that AI can give programmers the ability to continue\nfundamentally working as a programmer while  investing more time in understanding the real-world problems (business or\notherwise) that they are solving.</p><p>This dovetails well with improving communication skills.</p><p>Like many computer programmers, I am ambivalent towards the term ‚Äúsoftware architect.‚Äù  I have seen\n<a rel=\"noopener\" target=\"_blank\" href=\"https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/\">architect astronauts</a> inflict\na lot of pain on the world.</p><p>For lack of a better term, however, I think software architecture will become a more important skill over time: the\nability to organize large software systems effectively and, crucially, to control the complexity of those systems.</p><p>A tough part of this for juniors is that traditionally the ability to architect larger solutions well has come from\nexperience building smaller parts of systems, first poorly then, over time, more effectively.</p><p>Most bad architects I have met were either bad coders or simply didn‚Äôt have much coding experience at all.</p><p>If you let AI take over as a code generator for the ‚Äúsimple‚Äù stuff, how are you going to develop the intuitions necessary\nto be an effective architect?</p><p>This is why, again, you must write the code.</p><p>Another skill that seems likely to increase in value (obviously) is knowing how to use LLMs effectively.  I think that\ncurrently we are still in the process of figuring out what that means.</p><p>I also think that what this means varies by experience level.</p><p>Senior programmers who already have a lot of experience from the pre-AI era are in a good spot to use LLMs effectively:\nthey know what ‚Äúgood‚Äù code looks like, they have experience with building larger systems and know what matters and\nwhat doesn‚Äôt.  The danger with senior programmers is that they stop programming entirely and start suffering from\n<a rel=\"noopener\" target=\"_blank\" href=\"https://www.media.mit.edu/publications/your-brain-on-chatgpt/\">brain rot</a>.</p><p>Particularly dangerous is firing off prompts and then getting sucked into\n<a rel=\"noopener\" target=\"_blank\" href=\"https://theneverendingstory.fandom.com/wiki/The_Nothing\">The Eternal Scroll</a> while waiting.</p><p>I typically try to use LLMs in the following way:</p><ul><li>To analyze existing code to better understand it and find issues and inconsistencies in it</li><li>To help organize my thoughts for larger projects I want to take on</li><li>To generate relatively small bits of code for systems I am working on</li><li>To generate code that I don‚Äôt enjoy writing (e.g. regular expressions &amp; CSS)</li><li>To generate demos/exploratory code that I am willing to throw away or don‚Äôt intend to maintain deeply</li><li>To suggest tests for a particular feature I am working on</li></ul><p>I try not to use LLMs to generate full solutions that I am going to need to support.  I will sometimes use LLMs alongside\nmy manual coding as I build out a solution to help me understand APIs and my options while coding.</p><p>I never let LLMs design the APIs to the systems I am building.</p><p>Juniors are in a tougher spot.  I will say it again: you must write the code.</p><p>The temptation to vibe your way through problems is very, very high, but you will need to fight against that temptation.</p><p>Peers  be vibing their way through things and that will be annoying: you will need to work harder than they do,\nand you may be criticized for being slow.  The work dynamics here are important to understand: if your company\nprioritizes speed over understanding (as many are currently) you need to accept that and not get fired.</p><p>However, I think that this is a temporary situation and that soon companies are going to realize that vibe coding at\nspeed suffers from worse complexity explosion issues than well understood, deliberate coding does.</p><p>At that point I expect slower, more deliberate coding with AI assistance will be understood as the best way to utilize\nthis new technology.</p><p>Where AI  help juniors is in accelerating the road to senior developer by eliminating accidental complexity that often\ntrips juniors up.  As I said above, viewing AI as a useful although sometimes overly-eager helper rather than a servant\ncan be very effective in understanding the shape of code bases, what the APIs and techniques available for a particular\nproblem are, how a given build system or programming language works, etc.</p><p>But you must write the code.</p><p>And companies: you must let juniors write the code.</p><p>The questions I get around AI and programming fundamentally revolve around getting a decent job.</p><p>It is no secret that the programmer job market is bad right now, and I am seeing good CS students struggle to find\npositions programming.</p><p>While I do not have a crystal ball, I believe this is a temporary rather than permanent situation.  The computer\nprogrammer job market tends to be cyclical with booms and busts, and I believe we will recover from the current bust\nat some point.</p><p>That‚Äôs cold comfort to someone looking for a job now, however, so I want to offer the specific job-seeking advice that\nI give to my students.</p><p>I view the online job sites as mostly pointless, especially for juniors.  They are a lottery and the chances of finding\na good job through them are low.  Since they are free they are probably still worth using, but they are not worth\ninvesting a lot of time in.</p><p>A better approach is the four F‚Äôs: Family, Friends &amp; Family of Friends.  Use your personal connections to find positions\nat companies in which you have a competitive advantage of knowing people in the company.  Family is the strongest\npossibility.  Friends are often good too.  Family of friends is weaker, but also worth asking about.  If you know or\nare only a few degrees separated from someone at a company you have a much stronger chance of getting a job at that\ncompany.</p><p>I stress to many students that this doesn‚Äôt mean your family has to work for Google or some other big tech company.</p><p> companies of any significant size have problems that need to be solved using computers.  Almost every company over 100\npeople has some sort of development group, even if they don‚Äôt call it that.</p><p>As an example, I had a student who was struggling to find a job.  I asked what their parent did, and they said they worked\nfor Costco corporate.</p><p>I told them that they were in fact extremely lucky and that this was their ticket into a great company.</p><p>Maybe they don‚Äôt start as a ‚Äúcomputer programmer‚Äù there, maybe they start as an analyst or some other role.  But the\nability to program on top of that role will be very valuable and likely set up a great career.</p><p>So I still think pursuing computer programming as a career is a good idea.  The current job market is bad, no doubt, but\nI think this is temporary.</p><p>I do think how computer programming is done is changing, and programmers should look at building up skills beyond\n‚Äúpure‚Äù code-writing.  This has always been a good idea.</p><p>I don‚Äôt think programming is changing as dramatically as some people claim and I think the fundamentals of programming,\nparticularly writing good code and controlling complexity, will be perennially important.</p><p>I hope this essay is useful in answering that question, especially for junior programmers, and helps people feel\nmore confident entering a career that I have found very rewarding and expect to continue to do for a long time.</p><p>And companies: let the juniors write at least some of the code.  It is in your interest.</p>",
      "contentLength": 12488,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rh9bnw/yes_and/"
    },
    {
      "title": "Servo v0.0.5 released",
      "url": "https://github.com/servo/servo/releases/tag/v0.0.5",
      "date": 1772300688,
      "author": "/u/Right-Grapefruit-507",
      "guid": 49230,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/rust/comments/1rh8w41/servo_v005_released/"
    },
    {
      "title": "Alliance of Open Media is working on Open Audio Codec, based on libopus & meant to succeed Opus",
      "url": "https://github.com/AOMediaCodec/oac",
      "date": 1772299745,
      "author": "/u/TheTwelveYearOld",
      "guid": 49226,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rh8hn1/alliance_of_open_media_is_working_on_open_audio/"
    },
    {
      "title": "AMD Prepares Linux For Instruction-Based Sampling Improvements With Zen 6",
      "url": "https://www.phoronix.com/news/Linux-Perf-AMD-IBS-Zen-6",
      "date": 1772299285,
      "author": "/u/somerandomxander",
      "guid": 49290,
      "unread": true,
      "content": "<p>Michael Larabel is the principal author of Phoronix.com and founded the site in 2004 with a focus on enriching the Linux hardware experience. Michael has written more than 20,000 articles covering the state of Linux hardware support, Linux performance, graphics drivers, and other topics. Michael is also the lead developer of the Phoronix Test Suite, Phoromatic, and OpenBenchmarking.org automated benchmarking software. He can be followed via <a href=\"https://twitter.com/MichaelLarabel\">Twitter</a>, <a href=\"https://www.linkedin.com/in/michaellarabel/\">LinkedIn</a>, or contacted via <a href=\"https://www.michaellarabel.com/\">MichaelLarabel.com</a>.</p>",
      "contentLength": 500,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rh8akv/amd_prepares_linux_for_instructionbased_sampling/"
    },
    {
      "title": "ssh honeypot",
      "url": "https://www.reddit.com/r/golang/comments/1rh856c/ssh_honeypot/",
      "date": 1772298937,
      "author": "/u/KitchenBlackberry332",
      "guid": 49217,
      "unread": true,
      "content": "   submitted by   <a href=\"https://www.reddit.com/user/KitchenBlackberry332\"> /u/KitchenBlackberry332 </a>",
      "contentLength": 43,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "[R] Tiny transformers (<100 params) can add two 10-digit numbers to 100% accuracy",
      "url": "https://github.com/anadim/AdderBoard",
      "date": 1772298905,
      "author": "/u/LetsTacoooo",
      "guid": 49228,
      "unread": true,
      "content": "<p>Really interesting project. Crazy you can get such good performance. A key component is that they are digit tokens. Floating math will be way tricker. </p>",
      "contentLength": 151,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/MachineLearning/comments/1rh84o0/r_tiny_transformers_100_params_can_add_two/"
    },
    {
      "title": "Linux 6.19.4 regression may cause failure to suspend properly on certain AMD hardware",
      "url": "https://lore.kernel.org/all/aW3d4B3xMwe-pyzJwFnM7q4q5WjOjAajU2c6gk65arrBx5-soWv9AAZPzZHxAiX1XOxILELauRQdnxGxMectmmW76xfxyQyErVEH8nR_iyw=@protonmail.com/T/#u",
      "date": 1772297601,
      "author": "/u/anh0516",
      "guid": 49268,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rh7k8i/linux_6194_regression_may_cause_failure_to/"
    },
    {
      "title": "Servo v0.0.5 released",
      "url": "https://github.com/servo/servo/releases/tag/v0.0.5",
      "date": 1772297037,
      "author": "/u/Right-Grapefruit-507",
      "guid": 49267,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rh7btj/servo_v005_released/"
    },
    {
      "title": "Coming from Python - How do experienced Go developers navigate codebases with distributed method definitions?",
      "url": "https://www.reddit.com/r/golang/comments/1rh6yea/coming_from_python_how_do_experienced_go/",
      "date": 1772296150,
      "author": "/u/SevenIsMyTherapist",
      "guid": 49294,
      "unread": true,
      "content": "<p>I'm a senior developer who's built full-stack projects with Python backends (FastAPI, Pydantic, mypy) and TypeScript frontends. Python is my backend language of choice, but I'm frustrated by its loose typing, even with strict mypy enforcement, it's not quite the same as true static typing.</p><p>Go appeals to me because it handles natively what I have to work hard to enforce in Python. However, I'm struggling with code navigation patterns that feel counterintuitive coming from Python.</p><p>In Python, when I jump to a function or class definition, it takes me to a single location where I can see all methods and understand the structure. In Go, \"go to definition\" often takes me to an interface, and methods can be defined anywhere by adding a receiver. This distribution of code makes it harder to get a complete picture of a type's capabilities.</p><p>This is especially painful with third-party libraries. The only way I know to discover all methods on a type is to type a dot and wait for autocomplete suggestions, which feels like I'm missing something fundamental.</p><ul><li>How do experienced Go developers navigate codebases efficiently?</li><li>Is there a better way to see all methods attached to a particular type without relying on autocomplete?</li><li>Are there IDE features, tools, or mental models I should be using to work more effectively with Go's approach to organizing code?</li></ul><p>I suspect I'm approaching this with Python patterns when I should be thinking differently. Any guidance would be appreciated.</p>",
      "contentLength": 1477,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "[D] AI/ML PhD Committee",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rh6v3s/d_aiml_phd_committee/",
      "date": 1772295929,
      "author": "/u/dead_CS",
      "guid": 49291,
      "unread": true,
      "content": "<p>Hey all ‚Äî quick question for senior PhD folks.</p><p>I‚Äôm finalizing my Plan of Study and trying to decide on my committee composition. There‚Äôs a professor in our department whose work is aligned with mine and who has strong industry ties (split appointment). I‚Äôve always admired their work and initially wanted them on my committee.</p><p>The challenge is availability ‚Äî they‚Äôre very hard to reach and not very present on campus. I also haven‚Äôt worked directly with them, so they wouldn‚Äôt be in a position to write a strong letter. For those further along: how much does committee composition actually matter for jobs (industry RS roles or academia)? Does having a recognizable name help meaningfully, or is it better to prioritize accessibility and engagement i.e. I look for a more accessible professor?</p><p>Would really appreciate any honest thoughts.</p>",
      "contentLength": 851,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Servo Browser Engine Starts 2026 With Many Notable Improvements",
      "url": "https://www.phoronix.com/news/Servo-January-2026",
      "date": 1772293949,
      "author": "/u/anh0516",
      "guid": 49219,
      "unread": true,
      "content": "\nThe Servo project has issued their January 2026 development report that highlights all the interesting changes they made to this open-source browser layout engine last month. With Servo 0.0.5 they have landed many improvements to this engine and also continuing to enhance its ability to embed Servo inside other applications.\n<p>Some of the recent improvements to Servo include:\n</p><p>- Support for playing Ogg audio files via the audio HTML tag.\n</p><p>- Support for cursor-color, content: image, and other CSS features.\n</p><p>- Improved support for mixed content protections.\n</p><p>- Servo now leads other browsers in supporting new Web Cryptography algorithms in now supporting ML-KEM, ML-DSA, and improved AES-GCM support.\n</p><p>- Improved support for JavaScript module loading.\n</p><p>- Improved support for IndexedDB.\n</p><p>- A lot of work on text input fields support.\n</p><p>- Support for cross-compiling Servo using Microsoft Windows as the host.\n</p><p>- Various performance and stability enhancements.\n</p>More details on the recent Servo improvements via the <a href=\"https://servo.org/blog/2026/02/28/january-in-servo/\">Servo.org blog</a>.",
      "contentLength": 1023,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rh61a0/servo_browser_engine_starts_2026_with_many/"
    },
    {
      "title": "One-Click EKS Upgrades? The Reality Behind the Button",
      "url": "https://www.reddit.com/r/golang/comments/1rh5s1a/oneclick_eks_upgrades_the_reality_behind_the/",
      "date": 1772293338,
      "author": "/u/Downtown-Warning6818",
      "guid": 49216,
      "unread": true,
      "content": "<p>Managing multiple AWS EKS clusters lifecycle without proper EOL dashboard is very difficult, here <a href=\"https://kubefront.net/devops/one-click-eks-upgrades-reality-behind/\">blog post</a> I shared my experience,</p><p>EKS has auto upgrades feature, but it will only update AWS control plane and AWs addons. To solve this problem, we build our own Golang Prometheus exporter for custom metrices</p>",
      "contentLength": 306,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "gobench.dev - Comparisons of different stdlib features",
      "url": "https://www.reddit.com/r/golang/comments/1rh5ry4/gobenchdev_comparisons_of_different_stdlib/",
      "date": 1772293332,
      "author": "/u/MarvinJWendt",
      "guid": 49218,
      "unread": true,
      "content": "<p>The purpose of the site is to compare different functions in the standard library that achieve the same result. It helps you see how they perform in terms of speed, memory usage, and allocations, across different amounts of CPU cores used. I hope this helps someone!</p><p>Please let me know if the charts are easy to understand and if you have ideas for improvements!</p>",
      "contentLength": 361,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Pumba v1.0 ‚Äî chaos testing for containerd nodes (no Docker daemon needed)",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rh4ojy/pumba_v10_chaos_testing_for_containerd_nodes_no/",
      "date": 1772290604,
      "author": "/u/alexei_led",
      "guid": 49209,
      "unread": true,
      "content": "<p>I've maintained Pumba since 2016. It's a chaos testing CLI that kills containers, injects network delays, drops packets, and stress-tests resources at the container runtime level ‚Äî not the Kubernetes API level. Think Chaos Monkey, but for individual containers. Named after the Lion King warthog because a tool that intentionally breaks things should at least have a sense of humor.</p><p> Kubernetes dropped dockershim in v1.24. Containerd is now the dominant CRI (53% of clusters, up from 23% the year before). Pumba only spoke Docker. On containerd-only nodes, it was a paperweight. I've been watching issues about this pile up for two years.</p><p> Direct gRPC to . Three flags:</p><p><code>bash pumba --runtime containerd --containerd-namespace k8s.io \\ netem --duration 5m delay --time 3000 my-service </code></p><p><strong>Everything works on containerd:</strong> kill, stop, pause, restart, remove, netem (delay/loss/duplicate/corrupt/rate), iptables filtering with IP/port targeting, stress testing, exec.</p><p><strong>The interesting part under the hood:</strong> Docker gives you  for network namespace sharing. One flag. Containerd has no such abstraction ‚Äî you build OCI-spec sidecar containers, bind them to , manage the full task lifecycle, and make sure cleanup happens even when your parent context gets cancelled. If your containers don't have  installed (most don't),  spawns a nettools sidecar:</p><p><code>bash pumba --runtime containerd netem \\ --tc-image ghcr.io/alexei-led/pumba-alpine-nettools:latest \\ --duration 5m delay --time 3000 my-minimal-container </code></p><ul><li>cgroups v2 stress testing ‚Äî no privileged containers, no SYS_ADMIN</li><li>Real OOM kill testing ‚Äî  shares the target's cgroup, triggers actual kernel OOM via  (not simulated SIGKILL ‚Äî different container state, different K8s events, different recovery paths)</li><li> ships inside the <code>ghcr.io/alexei-led/stress-ng</code> scratch image ‚Äî minimal, no shell</li><li>K8s container name resolution from labels ( format, no SHA256 hunting)</li><li>40 advanced Go integration tests ‚Äî crash recovery under OOM, sidecar lifecycle, network verification, concurrent chaos</li><li>80+ bats integration tests for containerd</li></ul><p><strong>Why container-level instead of pod-level?</strong> Chaos Mesh and Litmus are great for pod-level chaos through K8s CRDs. Pumba does something different: if you need to delay one specific container in a multi-container pod, run chaos outside K8s entirely, or trigger a real OOM kill ‚Äî you need runtime access.</p><p>Happy to answer questions about containerd's API, the OCI sidecar pattern, or the cgroup injection approach.</p>",
      "contentLength": 2469,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Low-Latency Python: Separating Signal from Noise",
      "url": "https://open.substack.com/pub/lucisqr/p/low-latency-python-separating-signal?utm_campaign=post-expanded-share&amp;utm_medium=web",
      "date": 1772288949,
      "author": "/u/OkSadMathematician",
      "guid": 49220,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rh418l/lowlatency_python_separating_signal_from_noise/"
    },
    {
      "title": "Understanding RabbitMQ in simple terms",
      "url": "https://sushantdhiman.dev/understanding-rabbitmq/",
      "date": 1772288125,
      "author": "/u/Sushant098123",
      "guid": 49229,
      "unread": true,
      "content": "<p>Hi, I hope you all are doing well. Recently I was exploring RabbitMQ, and I found it fascinating. Previously I've used Kafka. RabbitMQ is very different from Kafka. This article is mostly useful for beginners or people who haven't used RabbitMQ. If you are an experienced developer, you might not find anything new in this post.</p><p>RabbitMQ (Rabbit Message Queueing) is an Open Source message broker. It is used by applications to interact asynchronously. Simplest use case of RabbitMQ can be establishing a communication between multiple micro-services.</p><p>Those who are new to message brokers or message queue read this to understand them. Experienced persons can skip.</p><p>Let's say you need an e-commerce solution. When any user places an order, 3 things happen: checkout handling, email sending and inventory update. You have a monolithic system where all 3 things happen sequentially, and on average it takes 5 seconds. Your user needs to hang on for 5 seconds. Later you decide to address this problem and break your system into 3 microservices.</p><ol></ol><p>Now each service will handle a particular thing. But the user still needs 5+ seconds because things will still happen sequentially. This is where the message broker/message queue comes into play. You will modify your application in this way:</p><ol><li>When the checkout service confirms payment, just return success to the user.</li><li>Publish a message with order details in a message queue.</li><li>Email &amp; Inventory service will continuously wait for messages in the queue.</li><li>Both microservices will do their task in the background without forcing the user to wait.</li></ol><p>Message Queues provide a reliable way for micro-services to communicate with each other.</p><p>These are the services that send messages to RabbitMQ. In our example, the is the producer.</p><p>A  is just a packet of data sent by the producer. It has 2 parts: &amp; . Properties let us define delivery mode, content type, priority, expiration and much more functionality of a message.</p><p>These are the applications that receive message and process them.</p><p>Consumers can't directly receive messages from producers; instead, they look for messages in a queue. A queue is a place where messages are stored so that they can be consumed by consumers.</p><p>RabbitMQ is not a message queue; it is a message broker. Unlike other message queues that push messages to a particular queue, RabbitMQ sends messages to an exchange. This is the most important component of RabbitMQ.</p><p>We need to understand exchanges deeply. One thing to remember is that producers never produce messages directly to the queue. Instead, they send messages to an exchange, and an exchange decides which queue a message should go to.</p><p>You might doubt why RabbitMQ puts messages in exchanges and why not directly in queues. This is because RabbitMQ provides many more features to route messages based on specific conditions. Let's understand it.</p><p>At the end, messages will go to the queue. With Exchange you can decide which queue you want the message to go into. RabbitMQ will act as a router.</p><p>Binding connects to a. It is basically a . Binding tells RabbitMQ that a queue is interesting in receiving messages from a particular exchange.</p><p>A queue basically tells RabbitMQ:</p><blockquote>‚ÄúIf a message matching this rule comes to the exchange, send a copy to me.‚Äù</blockquote><p>Without binding, an exchange has no idea where to send the message.So the actual routing logic of RabbitMQ lives inside bindings.</p><ul><li>Binding key (routing rule)</li></ul><p>You have an  exchange. You create a queue : </p><blockquote>send messages with routing key  to this queue</blockquote><p>Now whenever a producer publishes a message with routing key , the email service queue will receive it.</p><p>Important thing:<strong>One exchange can send the same message to multiple queues.</strong></p><p><strong>So a single event can trigger:</strong></p><ul></ul><p>Without the checkout service even knowing those services exist. That is actually the real power of message queues.</p><p>RabbitMQ provides multiple exchange types because not every system routes messages the same way.</p><p>This is the simplest one. It matches messages using an .</p><p><code>routing key = order.created</code></p><p>If key matches ‚Üí message goes to that queue. If the key doesn‚Äôt match, the queue will not receive the message.</p><ul></ul><p>You can think of it as <strong>send this job to a specific worker type</strong></p><p>Fanout exchange ignores routing keys completely. It simply broadcasts messages to . So if 5 queues are bound to the exchange ‚Üí all 5 get the message. It is used for implementing broadcast mechanism.</p><p>This is where RabbitMQ becomes very powerful. Topic exchange routes messages using patterns.</p><pre><code>order.created.india\norder.created.us\norder.cancelled.india</code></pre><p>Now queues can subscribe using patterns:</p><pre><code>order.created.*\n*.india\norder.#</code></pre><p>*  = one word#  = zero or more words</p><blockquote>I only care about Indian orders.</blockquote><p><strong>This is very useful in real systems:</strong></p><ul><li>event-driven architecture</li></ul><p>Instead of routing key, RabbitMQ uses message headers.</p><p>x-tenant: premiumx-region: asia</p><p>Queues receive messages based on header matching. This is not used very commonly but useful in special cases like SaaS platforms.</p><p>This is one of the most important reliability features. When a consumer receives a message, RabbitMQ does <strong>NOT immediately delete it</strong>. RabbitMQ waits.</p><blockquote>Did you actually process the message?</blockquote><p>After processing, the consumer sends . If ACK is received message is removed. If consumer crashes before ACK than message goes back to queue. This prevents data loss.</p><p>Email service crashes while sending mail.</p><p>Email lost forever.</p><p>RabbitMQ gives the same message to another worker.</p><p>This is why message brokers are used in payment systems and email systems.</p><p>By default RabbitMQ can push many messages to a consumer.</p><ul><li>message processing takes 10 seconds?</li><li>worker receives 100 messages?</li></ul><p>The worker becomes overloaded. Prefetch fixes this. Prefetch tells RabbitMQ:</p><blockquote>Don‚Äôt send me more than N unprocessed messages.</blockquote><p>Worker receives only one message at a time. This ensures:</p><ul></ul><p>This is also called .</p><p>TTL means message expiration.</p><blockquote>If message is not consumed within X time, discard it.</blockquote><ul></ul><p>People implement  using TTL + dead letter queues. RabbitMQ does not have built-in delay queues, so this becomes a common production trick.</p><p>RabbitMQ uses a . You can run multiple workers consuming from the same queue. Example: You have 1 queue . You start 5 worker instances.</p><p>RabbitMQ distributes messages between them:</p><ul></ul><p>This is called .</p><p>Each message goes to only , not all. This gives you horizontal scaling without changing code. If traffic increases than just start more workers.</p><p>This is a concept beginners often ignore but it is very important in real systems.</p><p>A TCP connection between your application and RabbitMQ server. Connections are expensive. You should NOT open a new connection per request. This will crash your server under load.</p><p>A lightweight virtual connection inside a connection.</p><ul></ul><p>Your entire service usually shares one RabbitMQ connection and creates channels for publishing/consuming. Channels are cheap, connections are not.</p><p>At this point you should understand something important:</p><p>RabbitMQ is not just a queue.</p><p>It is a <strong>reliable message routing system</strong> that allows services to communicate asynchronously, scale independently and recover from failures.</p><p>Once you start using it in real systems (emails, notifications, retries, background jobs), you‚Äôll realize many backend problems become much easier to solve.</p><p>If you made it this far, I hope RabbitMQ feels less intimidating now.</p><p>I usually write about backend engineering, distributed systems, and things I learn while working on real problems. Not theory ‚Äî mostly practical stuff that I wish someone had explained to me earlier.</p><p>I run a free newsletter where I share these kinds of write-ups. No spam. Just occasional backend engineering notes.</p>",
      "contentLength": 7579,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rh3pul/understanding_rabbitmq_in_simple_terms/"
    },
    {
      "title": "[D] Works on flow matching where source distribution comes from dataset instead of Gaussian noise?",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rh3k0f/d_works_on_flow_matching_where_source/",
      "date": 1772287705,
      "author": "/u/fliiiiiiip",
      "guid": 49227,
      "unread": true,
      "content": "<p>Flow matching is often discussed in the context of image generation from Gaussian noise.</p><p>In principle, we could model the flow from a complicated image distribution into another complicated image distribution (image to image).</p><p>Is that possible / well-understood in theoretical sense? Or are limited to the case where the source distribution is simple e.g. Gaussian?</p>",
      "contentLength": 363,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Learning Go as a backend dev - what actually matters?",
      "url": "https://www.reddit.com/r/golang/comments/1rh1v79/learning_go_as_a_backend_dev_what_actually_matters/",
      "date": 1772283084,
      "author": "/u/eurz",
      "guid": 49151,
      "unread": true,
      "content": "<p>Coming from Python/Java and trying to pick up Go. There's so many tutorials out there but a lot of them feel like they just rehash the tour and call it a day.</p><p>For those who've made the switch, what actually helped you  Go beyond the syntax? Not just writing code that works, but writing code that feels like Go.</p><p>Also curious about what projects made things click. I've done a couple small APIs but feel like I'm just writing Python in Go syntax.</p><p>Any resources or approaches that actually worked?</p>",
      "contentLength": 492,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "gitcredits ‚Äî movie-style end credits for your git repo, built with Bubble Tea",
      "url": "https://www.reddit.com/r/golang/comments/1rh1j3s/gitcredits_moviestyle_end_credits_for_your_git/",
      "date": 1772282059,
      "author": "/u/Ts-ssh",
      "guid": 49150,
      "unread": true,
      "content": "<p>Small weekend project. Reads git log and GitHub metadata, then scrolls them like movie end credits with a starfield background in your terminal.</p><p>Just cd into any repo and run it. Single file, no config.</p><p>Built with Bubble Tea + Lip Gloss + x/term.</p>",
      "contentLength": 244,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "json-canon: Implementing Burger-Dybvig (IEEE 754 ‚Üí shortest decimal) in Go for RFC 8785",
      "url": "https://www.reddit.com/r/golang/comments/1rh0q0y/jsoncanon_implementing_burgerdybvig_ieee_754/",
      "date": 1772279501,
      "author": "/u/UsrnameNotFound-404",
      "guid": 49176,
      "unread": true,
      "content": "<p>This is Part 1 of a four-part series on building an RFC 8785 JSON Canonicalization library in Go ([github.com/lattice-substrate/json-canon](<a href=\"https://github.com/lattice-substrate/json-canon)\">https://github.com/lattice-substrate/json-canon)</a>). Parts 2‚Äì4 cover the strict RFC 8259 parser, infrastructure-grade design decisions, and evidence-based release engineering. </p><p>This article covers the hardest part: number formatting. RFC 8785 requires ECMA-262‚Äìcompatible output, which means you need the shortest decimal that round-trips to the original IEEE 754 bits, with even-digit tie-breaking. Go's `strconv.FormatFloat` is high quality but doesn't expose an ECMA-262 conformance contract, so I implemented Burger-Dybvig from scratch in 490 lines with `math/big`. Validated against 286K oracle vectors with SHA-256 pinned test data. Pure Go, zero deps. </p><p>Happy to discuss the algorithm, the testing approach, or the design tradeoffs.</p>",
      "contentLength": 878,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Searching 1GB JSON on a phone: 44s to 1.8s, a journey through every wrong approach",
      "url": "https://www.reddit.com/r/rust/comments/1rgzhhl/searching_1gb_json_on_a_phone_44s_to_18s_a/",
      "date": 1772275232,
      "author": "/u/kotysoft",
      "guid": 49137,
      "unread": true,
      "content": "<p>After further investigation with the  author <a href=\"https://www.reddit.com/user/burntsushi/\">burntsushi </a>:</p><p><strong>The results were specific to running inside an Android app (shared library).</strong> When I compiled the same benchmark as a standalone binary and ran it directly on the same device, Finder was actually  than FinderRev ‚Äî consistent with expected behavior.</p><pre><code>Standalone binary on S23 Ultra (1GB real JSON, mmap'd): Finder::find 28.3ms FinderRev::rfind 96.4ms (3.4x slower) </code></pre><p>The difference between my app and the standalone binary might be related to how Rust compiles shared libraries (cdylib with PIC) vs standalone executables ‚Äî possibly affecting SIMD inlining or dispatch. <strong>But we haven't confirmed the exact root cause yet.</strong></p><p>--------------------------------------------------</p><p><strong>I found the root cause of the 150x slowdown. And I am an absolute idiot.</strong> ü§¶‚Äç‚ôÇÔ∏è</p><p>I spent the entire day benchmarking CPU frequencies, checking memory maps, and building a standalone JNI benchmark app to prove that Android was killing SIMD performance.</p><p>The actual reason?<strong>My standalone binary was compiled in</strong><strong>. My Android JNI library was secretly compiling in</strong><strong>mode without optimizations.</strong></p><p>Once I fixed the compiler profile,  dropped from 4.2 seconds to ~30ms on the phone. The SIMD degradation doesn't exist. It was just me experiencing the sheer, unoptimized horror of Debug-mode Rust on a 1GB JSON file.</p><p><a href=\"https://www.reddit.com/user/burntsushi/\"></a> for raising an issue and questioning his crate when the problem was entirely my own build config!</p><p>Leaving this post up as a monument to my own stupidity and a reminder to always check your . Thank you all for the upvotes on my absolute hallucination of a bug! </p><p>--------------------------------------------------</p><p><strong>Before the roasting starts, yes I know, gigabyte JSON files shouldnt exist.</strong> People should fix their pipelines, use a database, normalize things. You're right. But this whole thing started as a \"can I even do this on a phone?\" challenge, and somewhere along the way I fell into the rabbit hole and just kept going. First app, solo dev, having way too much fun to stop.</p><p>So I was working on a search position indicator, a small status bar at the top that shows where the scan is in the file, kind of like a timeline. While testing it on a 1GB JSON I noticed the forward search took . Fourty four. On a flagship phone. Meanwhile the backward search, which I already had using , was done in about 2 seconds. Same file, same query, same everything. That drove me absolutely crazy.</p><p>First thing I tried was switching to , same thing I was already using for the COUNT feature. That brought it down to about 9 seconds, big improvement, but I still couldnt understand why backward was 5 times faster on the exact same data. That gap kept bugging me.</p><p>Here's the full journey from there.</p><p><strong>The original, memchr on the first byte, 44 seconds</strong></p><p>This was the code that started everything.  anchored on the first byte of the query, whatever that byte happend to be. No frequency analysis, nothing smart. In a 1GB JSON with millions of repeated keys and values, common bytes show up literally everywhere. The scanner was stopping billions of times at false positives, checking each one, moving on, stopping again.</p><p><strong>memmem::Finder with SIMD Two-Way, 9.4 seconds</strong></p><p>Switched to the proper algorithm. Good improvement over 44s but still nowhere close to the 1.9 seconds that  was doing backward. The prefilter uses byte frequency heuristics to find candidate positions, but on repetitive structured data like JSON it generates tons of false positives and keeps hitting the slow path.</p><p><strong>memmem::Finder with prefilter disabled, 9.2 seconds</strong></p><p>I thought the prefilter must be the problem. Disabled it via <code>FinderBuilder::new().prefilter(Prefilter::None)</code>. Same speed. Also lost cancellation support because  just blocks on the entire data slice until its done. No progress bar, no cancel button. Great.</p><p><strong>Rarest byte memchr, 6.3 seconds</strong></p><p>Went back to the memchr approach but smarter this time. Wrote a byte frequency table tuned for JSON (structural chars like  scored high, rare letters scored low) and picked the least common byte in the query as anchor. This actually beat memmem::Finder, which surprised me. But still 3x slower than backward.</p><p><strong>Two byte pair anchor, 6.2 seconds</strong></p><p>Instead of anchoring on one rare byte, pick the rarest two consecutive bytes from the needle. Use memchr on the first one, immediately check if the next byte matches before doing the full comparison. Barely any improvement. The problem wasnt the verification cost, it was that memchr itself was stopping about 2 million times at the anchor byte.</p><p><strong>Why is FinderRev so fast?</strong></p><p>After some digging, turns out  deliberately does not use the SIMD prefilter, <em>\"because it wasn't clear it was worth the extra code\"</em>. On structured data full of repetitive delimiters, the \"dumber\" algorithm just plows straight through without the overhead. The thing that was supposed to make forward search faster was actually making it slower on this kind of data.</p><p><strong>FinderRev powered forward search, 1.8 seconds</strong></p><p>At this point it was still annoying me. So I thought, if reverse is fast and forward is slow, why not just use reverse for forward? I process the file in 5MB chunks from the beginning to the end. For each chunk I call  as a quick existence check, is there any match in this chunk at all? If no, skip it, move to the next one. That rejection happens at about 533 MB/s. When rfind returns a hit, I know there is a match somewhere in that 5MB chunk, so I do a small  on just that chunk to locate the first occurrence.</p><p>In practice 99.9% of chunks have no match and get skipped at FinderRev speed. The one chunk that actually contains the result takes about 0.03 seconds for the forward scan. Total: 1.8 seconds for the entire 1GB file.</p><p>All benchmarks on Samsung Galaxy S23 Ultra, ARM64, 1GB JSON with about 50 million lines, case sensitive forward search for a unique 24 byte string.</p><p>Since last time the app also picked up a full API Client (Postman collection import, OAuth 2.0, AWS Sig V4), a HAR network analyzer, highlight keywords with color picker and pinch to zoom. Still one person, still Rust powered, still occasionally surprised when things actually work on a phone.</p><p><strong>Has anyone else hit this Finder vs FinderRev gap on non natural language data?</strong><strong>Curious if this is a known thing or if I just got lucky with my data pattern.</strong></p>",
      "contentLength": 6268,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "I really like Go‚Ä¶ but I‚Äôve never had a real reason to use it",
      "url": "https://www.reddit.com/r/golang/comments/1rgygvj/i_really_like_go_but_ive_never_had_a_real_reason/",
      "date": 1772271422,
      "author": "/u/AggravatingHome4193",
      "guid": 49124,
      "unread": true,
      "content": "<p>I come from a Node.js/TypeScript background, and I‚Äôve been learning Go on and off for a while now. And honestly‚Ä¶ I really like the language.</p><p>There‚Äôs something about its simplicity, the standard library, the tooling, the compilation speed, it just feels clean and pragmatic. It‚Äôs refreshing compared to the heavy ecosystem and abstraction layers I‚Äôm used to.</p><p>But here‚Äôs the thing: I‚Äôve never actually had a real-world project where Go was the obvious choice. Most of the things I build (APIs, SaaS backends, internal tools, etc.) are already comfortably handled with Node + TypeScript. So I haven‚Äôt yet had that ‚Äúthis must be written in Go‚Äù moment. So I‚Äôm curious:</p><p>For those who also came from Node/TS, what made you switch (or adopt Go seriously)?</p><p>Would love to hear your experiences</p>",
      "contentLength": 801,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "How I Taught a Dragonfly to Fuzz Itself",
      "url": "https://medium.com/@v.yavdoshenko/how-i-taught-a-dragonfly-to-fuzz-itself-879734578250",
      "date": 1772270444,
      "author": "/u/yavdoshenko",
      "guid": 49191,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgy7wq/how_i_taught_a_dragonfly_to_fuzz_itself/"
    },
    {
      "title": "sudo-rs shows password asterisks by default ‚Äì break with Unix tradition",
      "url": "https://www.heise.de/en/news/sudo-rs-shows-password-asterisks-by-default-break-with-Unix-tradition-11193037.html",
      "date": 1772268006,
      "author": "/u/FryBoyter",
      "guid": 49112,
      "unread": true,
      "content": "<p>The Rust implementation sudo-rs breaks with a decades-old Unix convention: by default, asterisks now appear on the screen when typing passwords. As can be seen from a <a href=\"https://github.com/trifectatechfoundation/sudo-rs/commit/fb51e41919c25e3b178c4f994e668a5fc80136ee\" rel=\"external noopener\" target=\"_blank\">commit in the GitHub repository</a>, the software has been activating the ‚Äúpwfeedback‚Äù option by default since mid-February 2026. Traditionally, for 46 years, sudo has provided no feedback when typing passwords ‚Äì a conscious design decision for security reasons.</p><p>The developers justify the change with usability improvements for new users. The commit message states that security is theoretically worse because password lengths would be visible to observers in the user's immediate vicinity. However, this minimal disadvantage is outweighed by significantly improved usability. In fact, sudo is thus one of the last Unix tools that provides no visual feedback at all when entering passwords; other applications have long shown placeholder characters.</p><p>The change affects Ubuntu users with all versions that use sudo-rs by default. In a <a href=\"https://bugs.launchpad.net/ubuntu/+source/rust-sudo-rs/+bug/2142721\" rel=\"external noopener\" target=\"_blank\">bug report</a>, at least one traditionally-minded user vehemently complained about the innovation: displaying asterisks violates decades of practice and reveals the password length to ‚Äúshoulder surfers‚Äù ‚Äì people looking over the user's shoulder. However, Ubuntu marked the bug report as ‚ÄúWon't Fix.‚Äù A rollback of the change is not planned.</p><h3>Simple deactivation possible</h3><p>Administrators who prefer the old behavior can deactivate the asterisk display. To achieve this, the line  must be inserted into the sudoers configuration file. For server environments, the change is likely less relevant, as SSH keys are typically used instead of passwords there.</p><p>sudo-rs is a complete reimplementation of the sudo command in the Rust programming language. The project aims to avoid the security issues that can arise from the original's 30-year-old C codebase. Rust, through its borrow checker, prevents entire classes of memory management errors such as buffer overflows. sudo-rs can now be used instead of the conventional sudo in many other distributions, although a transition comparable to Ubuntu has not yet occurred in other mainstream systems.</p><p>The Trifecta Tech Foundation, which develops sudo-rs, has had the project externally audited twice. The last audit in August 2025 found no security vulnerabilities. During the first audit in 2023, the auditors discovered a path traversal vulnerability, which also affected the original sudo. Ubuntu users can switch back to the classic sudo via  up to version 26.04.</p><div><div><p><em>This article was originally published in\n      \n        <a href=\"https://www.heise.de/news/sudo-rs-zeigt-Passwort-Sternchen-standardmaessig-Bruch-mit-Unix-Tradition-11192641.html\">German</a>.\n      \n      It was translated with technical assistance and editorially reviewed before publication.</em></p></div></div>",
      "contentLength": 2675,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rgxjcw/sudors_shows_password_asterisks_by_default_break/"
    },
    {
      "title": "I built a CLI tool with Go to visualize file trees with line counts",
      "url": "https://www.reddit.com/r/golang/comments/1rgwv8j/i_built_a_cli_tool_with_go_to_visualize_file/",
      "date": 1772265583,
      "author": "/u/Suitable_Jump_6465",
      "guid": 49089,
      "unread": true,
      "content": "   submitted by   <a href=\"https://www.reddit.com/user/Suitable_Jump_6465\"> /u/Suitable_Jump_6465 </a>",
      "contentLength": 41,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Washington Gaming Forum - Ultra Fast Open source Discussion Plataform",
      "url": "https://github.com/Quirson/washington-forum",
      "date": 1772262747,
      "author": "/u/Quirson_Ngale",
      "guid": 49086,
      "unread": true,
      "content": "<p>Washington Forum - Ultra-Fast Open Source Discussion Platform</p><p>Built with Go + React | Real-time | Production-Ready</p><p>Blazing Fast Performance While Node.js struggles with 400MB+ RAM usage on small projects, our Go backend sips resources at just 8MB even with millions of routes! That's 50x better memory efficiency </p><p>¬∑ Backend: Go (Golang) - Built for maximum performance ¬∑ Frontend: React + Vite - Lightning-fast UI ¬∑ Real-time: Instant updates, smooth user experience ¬∑ Live Demo: forum.washingtongaming.tech</p><p>Our forum is already running in production! Experience the speed yourself:</p><p>¬∑ Sub-second response times ¬∑ Real-time discussions ¬∑ Mobile-responsive design ¬∑ Production-tested performance</p><p>We're building something amazing and we need YOU! Whether you're:</p><p>¬∑ A Go enthusiast wanting to learn ¬∑ A React developer looking for a cool project ¬∑ A performance geek interested in optimization ¬∑ Just love open source!</p><p>Give us a star and let's build the fastest forum together!</p><p>I'm super open to collaboration! Found a bug? Want to add a feature? Have performance tips? Open an issue or PR! Let's make this project better together.</p><p>Open source with respect for contributors. Feel free to fork and improve, but please maintain proper attribution.</p><p>Ready to experience forum software done right?</p>",
      "contentLength": 1289,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rgw2ng/washington_gaming_forum_ultra_fast_open_source/"
    },
    {
      "title": "A Social Filesystem",
      "url": "https://overreacted.io/a-social-filesystem/",
      "date": 1772262691,
      "author": "/u/fagnerbrack",
      "guid": 49126,
      "unread": true,
      "content": "<p>You write a document, hit save, and the file is on your computer. It‚Äôs yours. You can inspect it, you can send it to a friend, and you can open it with other apps.</p><p>Files come from the paradigm of .</p><p>This post, however, isn‚Äôt about personal computing. What I want to talk about is ‚Äîapps like Instagram, Reddit, Tumblr, GitHub, and TikTok.</p><p>What do files have to do with social computing?</p><p>Historically, not a lot‚Äî</p><p>But first, a shoutout to files.</p><p>Files, as originally invented, were not meant to live  the apps.</p><p>Since files represent  creations, they should live somewhere that  control. Apps create and read your files on your behalf, but files don‚Äôt belong  the apps.</p><p>Files belong to you‚Äîthe person using those apps.</p><p>Apps (and their developers) may not own your files, but they do need to be able to  them. To do that reliably, apps need your files to be structured. This is why app developers, as part of creating apps, may invent and evolve .</p><p>A file format is like a language. An app might ‚Äúspeak‚Äù several formats. A single format can be understood by many apps. <strong>Apps and formats are many-to-many. File formats let different apps work together without knowing about each other.</strong></p><p>SVG is an open specification. This means that different developers agree on how to read and write SVG. I created this SVG file in <a target=\"_blank\" href=\"https://excalidraw.com/\">Excalidraw</a>, but I could have used Adobe Illustrator or Inkscape instead. Your browser already knew how to display this SVG. It didn‚Äôt need to hit any Excalidraw APIs or to ask permissions from Excalidraw to display this SVG. It doesn‚Äôt matter which app has created this SVG.</p><p><em>The file format is the API.</em></p><p>Of course, not all file formats are open or documented.</p><p>Some file formats are application-specific or even proprietary like . And yet, although  was undocumented, it didn‚Äôt stop motivated developers from reverse-engineering it and creating more software that reads and writes :</p><p>Another win for the files paradigm.</p><p>The files paradigm captures a real-world intuition about tools: what we make  a tool does not belong  the tool. A manuscript doesn‚Äôt stay inside the typewriter, a photo doesn‚Äôt stay inside the camera, and a song doesn‚Äôt stay in the microphone.</p><p><strong>Our memories, our thoughts, our designs  outlive the software we used to create them. An app-agnostic storage (the filesystem) enforces this separation.</strong></p><p>You may create a file in one app, but someone else can read it using another app. You may switch the apps you use, or use them together. You may convert a file from one format to another. As long as two apps correctly ‚Äúspeak‚Äù the same file format, they can work in tandem even if their developers hate each others‚Äô guts.</p><p>Someone could always create ‚Äúthe next app‚Äù for the files you already have:</p><p>Apps may come and go, but <a target=\"_blank\" href=\"https://stephango.com/file-over-app\">files stay</a>‚Äîat least, as long as our apps think in files.</p><p>When you think of social apps‚ÄîInstagram, Reddit, Tumblr, GitHub, TikTok‚Äîyou probably don‚Äôt think about files. Files are for  computing only, right?</p><p>A Tumblr post isn‚Äôt a file.</p><p>An Instagram follow isn‚Äôt a file.</p><p>A Hacker News upvote isn‚Äôt a file.</p><p>But what if they  as files‚Äîat least, in all the important ways? Suppose you had a folder that contained all of the things ever ed by your online persona:</p><p>It would include everything you‚Äôve created across different social apps‚Äîyour posts, likes, scrobbles, recipes, etc. Maybe we can call it your ‚Äúeverything folder‚Äù.</p><p>Of course, closed apps like Instagram aren‚Äôt built this way. But imagine they were. <strong>In that world, a ‚ÄúTumblr post‚Äù or an ‚ÄúInstagram follow‚Äù are social file formats:</strong></p><ul><li>You posting on Tumblr would create a  file in your folder.</li><li>You following on Instagram would put an  file into your folder.</li><li>You upvoting on Hacker News would add an  file to your folder.</li></ul><p>Note this folder is not some kind of an archive. It‚Äôs where your data actually lives:</p><p><strong>Files are the source of truth‚Äîthe apps would reflect whatever‚Äôs in your folder.</strong></p><p>Any writes to your folder would be synced to the interested apps. For example, deleting an  file would work just as well as unfollowing through the app. Crossposting to three Tumblr communities could be done by creating three  files. Under the hood, each app manages files in your folder.</p><p>In this paradigm, apps are  to files. Every app‚Äôs database mostly becomes derived data‚Äîan app-specific cached materialized view of everybody‚Äôs folders.</p><p>This might sound very hypothetical, but it‚Äôs not. What I‚Äôve described so far is the premise behind the <a target=\"_blank\" href=\"https://atproto.com/\">AT protocol</a>. It works in production at scale. <a target=\"_blank\" href=\"https://bsky.app/\">Bluesky</a>, <a target=\"_blank\" href=\"https://leaflet.pub/\">Leaflet</a>, <a target=\"_blank\" href=\"https://tangled.org/\">Tangled</a>, <a target=\"_blank\" href=\"https://semble.so/\">Semble</a>, and <a target=\"_blank\" href=\"https://wisp.place/\">Wisp</a> are some of the new open social apps built this way.</p><p>It doesn‚Äôt  different to use those apps. But by lifting user data out of the apps, we force the same separation as we‚Äôve had in personal computing: <strong>apps don‚Äôt trap what you make with them.</strong> Someone can always make a new app for old data:</p><p>Like before, app developers evolve their file formats. However, they can‚Äôt gatekeep who reads and writes files in those formats. Which apps to use is up to you.</p><p>Together, everyone‚Äôs folders form something like a distributed :</p><p>I‚Äôve previously written about the AT protocol in <a href=\"https://overreacted.io/open-social/\">Open Social</a>, looking at its model from a web-centric perspective. But I think that looking at it from the filesystem perspective is just as intriguing, so I invite you to take a tour of how it works.</p><p>A personal filesystem starts with a file.</p><p>What does a social filesystem start with?</p><p>Here is a typical social media post:</p><p>How would you represent it as a file?</p><p>It‚Äôs natural to consider JSON as a format. After all, that‚Äôs what you‚Äôd return if you were building an API. So let‚Äôs fully describe this post as a piece of JSON:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>However, if we want to store this post , it doesn‚Äôt make sense to embed the author information there. After all, if the author later changes their display name or avatar, we wouldn‚Äôt want to go through their every post and change them there.</p><p>So let‚Äôs assume their avatar and name live somewhere else‚Äîperhaps, in another file. We could leave  in the JSON but this is unnecessary too. Since this file lives inside the creator‚Äôs folder‚Äîit‚Äôs  post, after all‚Äîwe can always figure out the author based on  folder we‚Äôre currently looking at.</p><p>Let‚Äôs remove the  field completely:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>This seems like a good way to describe this post:</p><p>But wait, no, this is still wrong.</p><p>You see, , , and  are not really something that the post‚Äôs author has . These values are derived from the data created by other people‚Äî replies,  reposts,  likes. The app that displays this post will have to keep track of those somehow, but they aren‚Äôt  user‚Äôs data.</p><p>So really, we‚Äôre left with just this:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>That‚Äôs our post as a file!</p><p>Notice how it took some trimming to identify which parts of the data <em>actually belong in this file</em>. This is something that you have to be intentional about when creating apps with the AT protocol. My mental model for this is to think about the  request. When the user created this thing,  That‚Äôs likely close to what we‚Äôll want to store. That‚Äôs the stuff the user has just created.</p><p>Our social filesystem will be structured more rigidly than a traditional filesystem. For example, it will  consist of JSON files. To make this more explicit, we‚Äôll start introducing our new terminology. We‚Äôll call this kind of file a .</p><p>Now we need to give our record a name. There are no natural names for posts. Could we use sequential numbers? Our names need only be unique within a folder:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"fish\" data-theme=\"Overnight\"><code data-language=\"fish\" data-theme=\"Overnight\"></code></pre></figure><p>One downside is that we‚Äôd have to keep track of the latest one so there‚Äôs a risk of collisions when creating many files from different devices at the same time.</p><p>Instead, let‚Äôs use timestamps with some per-clock randomness mixed in:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"fish\" data-theme=\"Overnight\"><code data-language=\"fish\" data-theme=\"Overnight\"></code></pre></figure><p>This is nicer because these can be generated locally and will almost never collide.</p><p>We‚Äôll use these names in URLs so let‚Äôs encode them more compactly. We‚Äôll <a target=\"_blank\" href=\"https://atproto.com/specs/tid\">pick our encoding carefully</a> so that sorting alphabetically goes in the chronological order:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"fish\" data-theme=\"Overnight\"><code data-language=\"fish\" data-theme=\"Overnight\"></code></pre></figure><p>Now  gives us a reverse chronological timeline of posts! That‚Äôs neat. Also, since we‚Äôre sticking with JSON as our lingua franca, we don‚Äôt need file extensions.</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"fish\" data-theme=\"Overnight\"><code data-language=\"fish\" data-theme=\"Overnight\"></code></pre></figure><p>Not all records accumulate over time. For example, you can write many posts, but you only have one copy of profile information‚Äîyour avatar and display name. For ‚Äúsingleton‚Äù records, it makes sense to use a predefined name, like  or :</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"fish\" data-theme=\"Overnight\"><code data-language=\"fish\" data-theme=\"Overnight\"></code></pre></figure><p>By the way, let‚Äôs save this profile record to :</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>Note how, taken together,  and  let us reconstruct more of the UI we started with, although some parts are still missing:</p><p>Before we fill them in, though, we need to make our system sturdier.</p><p>This was the shape of our post record:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>And this was the shape of our profile record:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>Since these are stored as files, it‚Äôs important for the format not to drift.</p><p>Let‚Äôs write some type definitions:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>TypeScript seems convenient for this but it isn‚Äôt sufficient. For example, we can‚Äôt express constraints like ‚Äúthe  string should have at most 300 Unicode graphemes‚Äù, or ‚Äúthe  string should be formatted as datetime‚Äù.</p><p>We need a richer way to define social file formats.</p><p>We might shop around for existing options (<a target=\"_blank\" href=\"https://www.pfrazee.com/blog/why-not-rdf\">RDF? JSON Schema?</a>) but if nothing quite fits, we might as well design our own schema language explicitly geared towards the needs of our social filesystem. This is what our  looks like:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>We‚Äôll call this the Post  because it‚Äôs like a language our app wants to speak.</p><p>My first reaction was also ‚Äúouch‚Äù but it helped to think that conceptually it‚Äôs this:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>I used to yearn for a <a target=\"_blank\" href=\"https://mlf.lol/\">better</a><a target=\"_blank\" href=\"https://typelex.org/\">syntax</a> but I‚Äôve actually come around to hesitantly appreciate the JSON. It being trivial to parse makes it super easy to build tooling around it (more on that in the end). And of course, we can <a target=\"_blank\" href=\"https://www.npmjs.com/package/@atproto/lex\">make</a><a target=\"_blank\" href=\"https://tangled.org/nonbinary.computer/jacquard\">bindings</a> turning these into type definitions and validation code for any programming language.</p><p>Our social filesystem looks like this so far:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"fish\" data-theme=\"Overnight\"><code data-language=\"fish\" data-theme=\"Overnight\"></code></pre></figure><p>The  folder has records that satisfy the Post lexicon, and the  folder contains records (a single record, really) that satisfy the Profile lexicon.</p><p>This can be made to work well for a single app. But here‚Äôs a problem. What if there‚Äôs another app with its own notion of ‚Äúposts‚Äù and ‚Äúprofiles‚Äù?</p><p>Recall, each user has an ‚Äúeverything folder‚Äù with data from every app:</p><p>Different apps will likely disagree on what the format of a ‚Äúpost‚Äù is! For example, a microblog post might have a 300 character limit, but a proper blog post might not.</p><p>Can we get the apps to agree with each other?</p><p>We could try to put every app developer in the same room until they all agree on a perfect lexicon for a post. That would be an interesting use of everyone‚Äôs time.</p><p>For some use cases, like <a target=\"_blank\" href=\"https://standard.site/\">cross-site syndication</a>, a standard-ish jointly governed lexicon makes sense. For other cases, you really want the app to be in charge. It‚Äôs actually  that different products can disagree about what a post is! Different products, different vibes. We‚Äôd want to support that, not to fight it.</p><p>Really, we‚Äôve been asking the wrong question. We don‚Äôt need every app developer to agree on what a  is; we just need to  anyone ‚Äúdefine‚Äù their own .</p><p>We could try namespacing types of records by the app name:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"fish\" data-theme=\"Overnight\"><code data-language=\"fish\" data-theme=\"Overnight\"></code></pre></figure><p>But then, app names can also clash. Luckily, we already have a way to avoid conflicts‚Äîdomain names. A domain name is unique and implies ownership.</p><p>Why don‚Äôt we take some inspiration from Java?</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"fish\" data-theme=\"Overnight\"><code data-language=\"fish\" data-theme=\"Overnight\"></code></pre></figure><p>This gives us </p><p>A collection is a folder with records of a certain lexicon type. Twitter‚Äôs lexicon for posts might differ from Tumblr‚Äôs, and that‚Äôs fine‚Äîthey‚Äôre in separate collections. The collection is always named like <code>&lt;whoever.designs.the.lexicon&gt;.&lt;name&gt;</code>.</p><p>For example, you could imagine these collection names:</p><ul><li> for Instagram follows</li><li> for Last.fm scrobbles</li><li> for Letterboxd reviews</li></ul><p>You could also imagine these slightly whackier collection names:</p><ul><li><code>com.ycombinator.news.vote</code> (subdomains are ok)</li><li> (personal domains work too)</li><li> (a shared standard someday?)</li><li> (breaking changes = new lexicon, just like file formats)</li></ul><p>It‚Äôs like having a dedicated folder for every file extension.</p><h3><a href=\"https://overreacted.io/a-social-filesystem/#there-is-no-lexicon-police\">There Is No Lexicon Police</a></h3><p>If you‚Äôre an application author, you might be thinking:</p><p>Who enforces that the records match their lexicons? If any app can (with the user‚Äôs explicit consent) write into any other app‚Äôs collection, how do we not end up with a lot of invalid data? What if some other app puts junk into ‚Äúmy‚Äù collection?</p><p>The answer is that records could be junk, but it still works out anyway.</p><p>It helps to draw a parallel to file extensions. Nothing stops someone from renaming  to . A PDF reader would just refuse to open it.</p><p>Lexicon validation works the same way. The  in  signals who  the lexicon, but the records themselves could have been created by  This is why <strong>apps always treat records as untrusted input</strong>, similar to  request bodies. When you generate type definitions from a lexicon, you also get a function that will do the validation for you. If some record passes the check, great‚Äîyou get a typed object. If not, fine, ignore that record.</p><p>So, validate on read, just like files.</p><p>Some care is required when evolving lexicons. From the moment some lexicon is used in the wild, you should never change which records it would consider valid. For example, you can add new optional fields, but you can‚Äôt change  some field is optional. This ensures that the new code can still read old records  that the old code will be able to read any new records. There‚Äôs a <a target=\"_blank\" href=\"https://github.com/bluesky-social/goat\">linter</a> to check for this. (For breaking changes, make a new lexicon, as you would do with a file format.)</p><p>Although this is not required, you can publish your lexicons for documentation and distribution. It‚Äôs like publishing type definitions. There‚Äôs no separate registry for those; you just put them into a <code>com.atproto.lexicon.schema</code> collection of some account, and then prove the lexicon‚Äôs domain is owned by you. For example, if I wanted to publish an  lexicon, I could place it here:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"sh\" data-theme=\"Overnight\"><code data-language=\"sh\" data-theme=\"Overnight\"></code></pre></figure><p>Let‚Äôs circle back to our post.</p><p>We‚Äôve already decided that the profile should live in the  collection, and the post itself should live in the  collection:</p><p>But what about the likes?</p><p>A like is something that the user , so it makes sense for each like to be a record. A like record doesn‚Äôt convey any data other than which post is being liked:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>So, a Like is a record that refers to its Post.</p><p>But how do we express this in JSON?</p><p>How do we refer from one JSON file to another JSON file?</p><p>We could try to refer to the Post record by its path in our ‚Äúeverything folder‚Äù:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>But this only uniquely identifies it  ‚Äúeverything folder‚Äù. Recall that each user has their own, completely isolated folders with all of their stuff:</p><p>We need to find some way to refer to the </p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>This is a difficult problem.</p><p>So far, we‚Äôve been building up a kind of a filesystem for social apps. But the ‚Äúsocial‚Äù part requires linking  users. We need a reliable way to refer to some user. The challenge is that we‚Äôre building a  filesystem where the ‚Äúeverything folders‚Äù of different users may be hosted on different computers, by different companies, communities or organizations, or be self-hosted.</p><p>What‚Äôs more, we don‚Äôt want anyone to be  their current hosting. The user should be able to change who hosts their ‚Äúeverything folder‚Äù at any point, and without breaking any existing links to their files. <strong>The main tension is that we want to preserve users‚Äô ability to change their hosting, but we don‚Äôt want that to break any links.</strong> Additionally, we want to make sure that, although the system is distributed, we‚Äôre confident that each piece of data has not been tampered with.</p><p>For now, you can forget all about records, collections, and folders. We‚Äôll focus on a single problem: links. More concretely, we need a design for permanent links that allow swappable hosting. If we don‚Äôt make this work, everything else falls apart.</p><h4><a href=\"https://overreacted.io/a-social-filesystem/#attempt-1-host-as-identity\">Attempt 1: Host as Identity</a></h4><p>Suppose dril‚Äôs content is hosted by <code>some-cool-free-hosting.com</code>. The most intuitive way to link to his content is to use a normal HTTP link to his hosting:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>This works, but then if dril wants to change his hosting, he‚Äôd break every link. So this is not a solution‚Äîit‚Äôs the exact  that we‚Äôre trying to solve. We want the links to point at ‚Äúwherever dril‚Äôs stuff will be‚Äù, not ‚Äúwhere dril‚Äôs stuff is right now‚Äù.</p><p>We need some kind of an indirection.</p><h4><a href=\"https://overreacted.io/a-social-filesystem/#attempt-2-handle-as-identity\">Attempt 2: Handle as Identity</a></h4><p>We could give dril some persistent identifier like  and use that in links:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>We could then run a registry that stores a JSON document like this for each user:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>The idea is that this document tells us how to find ‚Äôs actual hosting.</p><p>We‚Äôd also need to provide some way for dril to update this document.</p><p>Some version of this could work but it seems unfortunate to invent our own global namespace when one already exists on the internet. Let‚Äôs try a twist on this idea.</p><h4><a href=\"https://overreacted.io/a-social-filesystem/#attempt-3-domain-as-identity\">Attempt 3: Domain as Identity</a></h4><p>There‚Äôs already a global namespace anyone can participate in: DNS. If dril owns , maybe we could let him use  as his persistent identity:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>This doesn‚Äôt mean that the actual content is hosted at ; it just means that  hosts the JSON document that says where the content currently is. For example, maybe the convention is to serve that document as . Again, the document points us at the hosting. Obviously, dril can update his doc.</p><p>This is somewhat elegant but in practice the tradeoff isn‚Äôt great. Losing domains is pretty common, and most people wouldn‚Äôt want that to brick their accounts.</p><h4><a href=\"https://overreacted.io/a-social-filesystem/#attempt-4-hash-as-identity\">Attempt 4: Hash as Identity</a></h4><p>The last two attempts share a flaw: they tie you to the same handle forever.</p><p>Whether it‚Äôs a handle like  or a domain handle like , we want people to be able to change their handles at any time without breaking links.</p><p>Sounds familiar? We also want the same for hosting. So let‚Äôs keep the ‚Äúdomain handles‚Äù idea but store the current handle in JSON alongside the current hosting:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>This JSON is turning into sort of a calling card for your identity. ‚ÄúCall me , my stuff is at <code>https://some-cool-free-hosting.com</code>.‚Äù</p><p>Now we need somewhere to host this document, and some way for you to edit it.</p><p>Let‚Äôs revisit the ‚Äúcentralized registry‚Äù from approach #2. One problem with it was using handles as permanent identifiers. Also, centralized is bad, but why is it bad? It‚Äôs bad for many reasons, but usually it‚Äôs the risk of abuse of power or a single point of failure. Maybe we can, if not remove, then reduce some of those risks. For example, it would be nice if could make the registry‚Äôs output self-verifiable.</p><p>Let‚Äôs see if we can use mathematics to help with this.</p><p>When you create an account, we‚Äôll generate a private and a public key. We then create a piece of JSON with your initial handle, hosting, and public key. We sign this ‚Äúcreate account‚Äù operation with your private key. Then we hash the signed operation. That gives us a string of gibberish like .</p><p>The registry will store your operation under that hash. <strong>That hash becomes the permanent identifier for your account.</strong> We‚Äôll use it in links to refer to you:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>To resolve a link like this, we ask the registry for the document belonging to . It returns current your hosting, handle, and public key. Then we fetch <code>com.twitter.post/34qye3wows2c5</code> from your hosting.</p><p>Okay, but how do you update your handle or your hosting in this registry?</p><p>To update, you create a new operation with a  field set to the hash of your previous operation. You sign it and send it to the registry. The registry validates the signature, appends the operation to your log, and updates the document.</p><p>To prove that it doesn‚Äôt forge the served documents, the registry exposes an endpoint that lists past operations for an identifier. To verify an operation, you check that its signature is valid and that its  field matches the hash of the operation before it. This lets you verify the entire chain of updates down to the first operation. The hash of the first operation  the identifier, so you can verify that too. At that point, you know that every change was signed with the user‚Äôs key.</p><p>With this approach, the registry is still centralized but it can‚Äôt forge anyone‚Äôs documents without the risk of that being detected. To further reduce the need to trust the registry, we make its entire operation log auditable. The registry would hold no private data and be entirely open source. Ideally, it would <a target=\"_blank\" href=\"https://docs.bsky.app/blog/plc-directory-org\">eventually be spun it out</a> into an independent legal entity so that long-term it can be like ICANN.</p><p>Since most people wouldn‚Äôt want to do key management, it‚Äôs assumed the hosting would hold the keys on behalf of the user. The registry includes a way to register an overriding rotational key, which is helpful in case the hosting itself goes rogue. (I wish for a way to set this up with a good UX; most people don‚Äôt have this on.)</p><p>Finally, since the handle is now determined by the document held in the registry, we‚Äôll need to add some way for a domain to signal that it  with being some identifier‚Äôs handle. This could be done via DNS, HTTPS, or a mix of both.</p><p>Phew! This is <a target=\"_blank\" href=\"https://updates.microcosm.blue/3lz7nwvh4zc2u\">not perfect</a> but it gets us surprisingly far.</p><h4><a href=\"https://overreacted.io/a-social-filesystem/#attempt-5-did-as-identity\">Attempt 5: DID as Identity</a></h4><p>From the end user perspective, attempt #4 (hash as identity) is the most friendly. It doesn‚Äôt use domains for identity (only as handles), so losing a domain is fine.</p><p>However, some find relying on a third-party registry, no matter how transparent, untenable. So it would be nice to support approach #3 (domain as identity) too.</p><p>We‚Äôll use a flexible identifier standard called DID (decentralized identifier) which is essentially a way to namespace multiple unrelated identification methods:</p><ul><li> and such ‚Äî domain-based (attempt #3)</li><li><code>did:plc:6wpkkitfdkgthatfvspcfmjo</code> and such ‚Äî registry-based (attempt #4)</li><li>This also leaves us a room to add other methods in the future, like </li></ul><p>This makes our Like record look like this:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>This is going to be its final form. We write  here to remind ourselves that this isn‚Äôt an HTTP link, and that you need to follow the resolution procedure (get the document, get the hosting, then get the record) to actually get the result.</p><p><strong>Now you can forget everything we just discussed and remember four things:</strong></p><ol><li>A DID is a string identifier that represents an account.</li><li>An account‚Äôs DID never changes.</li><li>Every DID points at a document with the current hosting, handle, and public key.</li><li>A handle needs to be verified in the other direction (the domain must agree).</li></ol><p>The mental model is that there‚Äôs a function like this:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>You give it a DID, and it returns where to find their stuff, their bidirectionally verified current handle, and their public key. You‚Äôll want a  on it.</p><p>Let‚Äôs now finish our social filesystem.</p><p>With a DID, we can finally construct a path that identifies every particular record:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"scala\" data-theme=\"Overnight\"><code data-language=\"scala\" data-theme=\"Overnight\"></code></pre></figure><p><strong>An  URI is a link to a record that survives hosting and handle changes.</strong></p><p>The mental model here is that you can always resolve it to a record:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>If the hosting is down, it would temporarily not resolve, but if the user puts it up anywhere and points their DID there, it will start resolving again. The user can also delete the record, which would remove it from the user‚Äôs ‚Äúeverything folder‚Äù.</p><p>Another way to think about  URI is that it is as a unique identifier of every record in our filesystem, so it can serve as a key in a database or a cache.</p><p>With links, we can finally represent relationships between records.</p><p>Let‚Äôs look at dril‚Äôs post again:</p><p>Where do the 125 thousand likes come from?</p><p>These are just 125 thousand  records in different people‚Äôs ‚Äúeverything folders‚Äù that each  to dril‚Äôs  record:</p><p>Where do the 56K reposts come from? Similarly, this means that there are 56K  records across our social filesystem linking to this post:</p><p>A reply is just a post that has a parent post. In TypeScript, we‚Äôd write it like this:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>In lexicon, we‚Äôd write it like this:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"json\" data-theme=\"Overnight\"><code data-language=\"json\" data-theme=\"Overnight\"></code></pre></figure><p>This says: the  field is an  link to another record.</p><p>Every reply to dril‚Äôs post will have dril‚Äôs post as their :</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"json\" data-theme=\"Overnight\"><code data-language=\"json\" data-theme=\"Overnight\"></code></pre></figure><p>So, to get the reply count, we just need to count every such post:</p><p>We‚Äôve now explained how every piece of the original UI can be derived from files:</p><ul><li>The display name and avi come from dril‚Äôs .</li><li>The tweet text and date come from dril‚Äôs <code>com.twitter.post/34qye3wows2c5</code>.</li><li>The like count is aggregated from everyone‚Äôs s.</li><li>The repost count is aggregated from everyone‚Äôs s.</li><li>The reply count is aggregated from everyone‚Äôs s.</li></ul><p>The last finishing touch is the handle. Unfortunately,  can no longer work as a handle since we‚Äôve chosen to use domains as handles. As a consolation, dril would be able to use  across every future social app if he would like to.</p><p>It‚Äôs time to give our ‚Äúeverything folder‚Äù a proper name. We‚Äôll call it a . A repository is identified by a DID. It contains collections, which contain records:</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"fish\" data-theme=\"Overnight\"><code data-language=\"fish\" data-theme=\"Overnight\"></code></pre></figure><p>Each repository is a user‚Äôs little piece of the social filesystem. A repository can be hosted anywhere‚Äîa free provider, a paid service, or your own server. You can move your repository as many times as you‚Äôd like without breaking links.</p><p>One challenge with building a social filesystem in practice is that apps need to be able to compute derived data (e.g. like counts) with no extra overhead. Of course, it would be completely impractical to look for every  record in every repo referencing a specific post when trying to serve the UI for that post.</p><p>This is why, in addition to treating a repository as a filesystem‚Äîyou can  and  stuff‚Äîyou can treat it as a stream,  to it by a WebSocket. This lets anyone build a local app-specific cache with just the derived data that app needs. Over the stream, you receive each commit as an event, along with the tree delta.</p><p>For example, a Hacker News backend could listen to creates/updates/deletes of  records in every known repository and save those records locally for fast querying. It could also track derived data like .</p><p>Subscribing to every known repository from every app is inconvenient. It is nicer to use dedicated services called  which retransmit all events. However, this raises the issue of trust: how do you know whether someone else‚Äôs relay is lying?</p><p>To solve this, let‚Äôs make the repository data self-certifying. We can structure the repository as a <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Merkle_tree\">hash tree</a>. Each write is a signed  containing the new root hash. This makes it possible to verify records as they come in against their original authors‚Äô public keys. As long as you subscribe to a relay that retransmits its proofs, you can check every proof to know the records are authentic.</p><p>Verifying authenticity of records does not require storing their content, which means that relays can act as simple retransmitters and <a target=\"_blank\" href=\"https://whtwnd.com/bnewbold.net/3lo7a2a4qxg2l\">are affordable to run</a>.</p><p>If you want to explore the Atmosphere (-mosphere, get it?), pdsls is the best starting point. Given a DID or a handle, it shows a list of collections and their records. It‚Äôs really like an old school file manager, except for the social stuff.</p><p>Go to <a target=\"_blank\" href=\"https://pdsls.dev/at://danabra.mov\"></a> if you want some random place to start. Notice that you understand 80% of what‚Äôs going on there‚ÄîCollections, Identity, Records, etc.</p><p>Feel free to branch out. Records link to other records. There is no app-specific aggregation there so it feels a little ‚Äúungrounded‚Äù (e.g. there is no thread view like in Bluesky) but there are some interesting navigational features like Backlinks.</p><p>Watch me walk around the Atmosphere for a bit:</p><p>(Yeah, what  that lexicon?! I didn‚Äôt expect to run into this while recording.)</p><p>My favorite demo is this.</p><p>Watch me create a Bluesky post by creating a record via pdsls:</p><p>The app ‚Äúreacts‚Äù to the change. Files are the source of truth!</p><p>To make the filesystem metaphor more visceral, I can mount my (or anyone else‚Äôs) repository as a FUSE drive with <a target=\"_blank\" href=\"https://tangled.org/oppi.li/pdsfs/\"></a>. Now every change shows up there as well:</p><p>What are files good for? For one, agents really like files. Here I‚Äôm asking Claude to find what my friends have recently made  in the Atmosphere:</p><p>No API calls, no MCP servers. This may not be the most efficient way to analyze social data, but if you squint, you might see a glimpse of a post-app future. Apps curate data into experiences, but <a target=\"_blank\" href=\"https://tynanistyping.offprint.app/a/3mcsvjjceei23-publishing-on-the-atmosphere\">the web we create</a> floats above every app.</p><p>There‚Äôs nothing specific to Bluesky here.</p><p>Data always flows down in the Atmosphere‚Äîfrom our repos to apps.</p><p>A month ago, I‚Äôve made a little app called <a target=\"_blank\" href=\"https://sidetrail.app/\">Sidetrail</a> (<a target=\"_blank\" href=\"https://tangled.org/danabra.mov/sidetrail\">it‚Äôs open source</a>) to practice full-stack development. It lets you create step-by-step walkthroughs and ‚Äúwalk‚Äù those. Here you can see I‚Äôm deleting an  record in pdsls, and the corresponding walk disappears from my Sidetrail ‚Äúwalking‚Äù tab:</p><p>I know exactly  it works, it‚Äôs not supposed to  me, but it does! My repo really  the source of truth. My data lives in the Atmosphere, and apps ‚Äúreact‚Äù to it.</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>This syncs everyone‚Äôs repo changes to my database so I have a snapshot that‚Äôs easy to query. I‚Äôm sure I could write this more clearly, but conceptually, it‚Äôs like <em>I‚Äôm re-rendering my database</em>. It‚Äôs like I called a  ‚Äúabove‚Äù the internet, and now the new props flow down from files into apps, and my DB reacts to them.</p><p>I could delete those tables in production, and then use <a target=\"_blank\" href=\"https://docs.bsky.app/blog/introducing-tap\">Tap</a> to backfill my database . I‚Äôm just caching a slice of the global data. And everyone building AT apps also needs to cache some slices. Maybe different slices, but they overlap. So <a target=\"_blank\" href=\"https://constellation.microcosm.blue/\">pooling resources</a> becomes more useful. More of our tooling can be shared too.</p><p>Here‚Äôs another example that I really like.</p><p>Now, you can see it says ‚Äú678,850 scrobbles‚Äù at the top of the screen. You might think people have been scrobbling their plays to the teal.fm API for a while.</p><p>The teal.fm API doesn‚Äôt actually exist. It‚Äôs not a thing. Moreover, the teal.fm product doesn‚Äôt actually exist either. I mean, I  it‚Äôs in development (this is a hobby project!), but at the time of writing, <a target=\"_blank\" href=\"https://teal.fm/\">https://teal.fm/</a> is only a landing page.</p><p>All you need to start scrobbling is to put records of the  lexicon into your repo.</p><p>Let‚Äôs see if anyone is doing this right now:</p><p>The lexicon isn‚Äôt published as a record (yet?) but it‚Äôs <a target=\"_blank\" href=\"https://github.com/teal-fm/teal/blob/25d6d8d1d9a2bb2735c74fb4bab5d35f808d120e/lexicons/fm.teal.alpha/feed/play.json\">easy to find on GitHub</a>. So anyone can build a scrobbler that writes these. I‚Äôm using one of those scrobblers.</p><p>Here‚Äôs my scrobble showing up:</p><p><em>(It‚Äôs a bit slow but <a target=\"_blank\" href=\"https://bsky.app/profile/finfet.sh/post/3mcparo5gis2u\">the delay is</a> on the Spotify/scrobbler integration side.)</em></p><p>To be clear, the person who made this demo doesn‚Äôt work on teal.fm either. It‚Äôs not an ‚Äúofficial‚Äù demo or anything, and it‚Äôs also not using the ‚Äúteal.fm database‚Äù or ‚Äúteal.fm API‚Äù or anything like it. It just indexes s.</p><p>The demo‚Äôs data layer is using the new <a target=\"_blank\" href=\"https://tangled.org/chadtmiller.com/lex-gql\"></a> package, which is another of <a target=\"_blank\" href=\"https://tangled.org/chadtmiller.com\"></a>‚Äôs experiments. You give it some lexicons, and it lets you run GraphQL on your backfilled snapshot of the relevant parts of the social filesystem.</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"graphql\" data-theme=\"Overnight\"><code data-language=\"graphql\" data-theme=\"Overnight\"></code></pre></figure><p>Every app can blend cross-product information like this. For example, here is an AT app called <a target=\"_blank\" href=\"https://blento.app/\">Blento</a> that lets you <em>display your teal.fm plays</em> on your homepage:</p><p>(Again, it doesn‚Äôt talk to teal.fm‚Äîwhich doesn‚Äôt exist yet!‚Äîit just reads your files.)</p><p>Blento is an AT replacement for <a target=\"_blank\" href=\"https://bento.me/home/bento-sunset\">Bento, which is shutting down</a>. If Blento  itself ever shuts down, any motivated developer can  with the existing content.</p><p>There‚Äôs one last example that I wanted to share.</p><p>For months, I‚Äôve been complaining about the Bluesky‚Äôs default Discover feed which, frankly, doesn‚Äôt work all that great for me. Then I heard people saying good things about <a target=\"_blank\" href=\"https://bsky.app/profile/spacecowboy17.bsky.social/feed/for-you\"><code>@spacecowboy17.bsky.social</code>‚Äôs For You</a> algorithm.</p><p>I‚Äôve been giving it a try, and I really like it!</p><p>I ended up switching to it completely. It reminds me of the Twitter algo in 2017‚Äîthe swings are a bit hard but it finds the stuff I wouldn‚Äôt want to miss. It‚Äôs also much more responsive to ‚ÄúShow Less‚Äù. Its <a target=\"_blank\" href=\"https://bsky.app/profile/spacecowboy17.bsky.social/post/3mbhenfjar22s\">core principle</a> seems pretty simple.</p><p>How does a custom feed like this work? Well, a Bluesky feed is <a target=\"_blank\" href=\"https://github.com/bluesky-social/feed-generator?tab=readme-ov-file#some-details\">just an endpoint</a> that returns a list of  URIs. That‚Äôs the contract. You know how this works.</p><figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"><code data-language=\"js\" data-theme=\"Overnight\"></code></pre></figure><p>Could there be feeds of things other than posts? Sure.</p><p>There was a tweet a few weeks ago clowning on Bluesky for being so bad at algorithms that users have to install a third-party feed to get a good experience.</p><p>I agree <a target=\"_blank\" href=\"https://bsky.app/profile/dame.is/post/3mavm5k7u2h2d\">with </a> that this shows something important: Bluesky is a place where that  Why? In the Atmosphere, third party is first party. We‚Äôre all building projections of the same data. It‚Äôs a  that someone can do it better.</p><p>An everything app tries to do everything.</p><p>An everything ecosystem lets everything get done.</p>",
      "contentLength": 32166,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgw211/a_social_filesystem/"
    },
    {
      "title": "Beware of 6.19.4 nftables regression - can render systems unbootable. Hold back on updating if you're using nftables.",
      "url": "https://lore.kernel.org/all/bb9ab61c-3bed-4c3d-baf0-0bce4e142292@moonlit-rail.com/",
      "date": 1772261200,
      "author": "/u/i-hate-birch-trees",
      "guid": 49084,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rgvmaj/beware_of_6194_nftables_regression_can_render/"
    },
    {
      "title": "Paper: The framing of a system prompt changes how a transformer generates tokens ‚Äî measured across 3,830 runs with effect sizes up to d>1.0",
      "url": "https://www.reddit.com/r/artificial/comments/1rgv1kl/paper_the_framing_of_a_system_prompt_changes_how/",
      "date": 1772259226,
      "author": "/u/TheTempleofTwo",
      "guid": 49269,
      "unread": true,
      "content": "<p>Quick summary of an independent preprint I just published:</p><p> Does the relational framing of a system prompt ‚Äî not its instructions, not its topic ‚Äî change the generative dynamics of an LLM?</p><p> Two framing variables (relational presence + epistemic openness), crossed into 4 conditions, measured against token-level Shannon entropy across 3 experimental phases, 5 model architectures, 3,830 total inference runs.</p><ul><li>Yes, framing changes entropy regimes ‚Äî significantly at 7B+ scale (d&gt;1.0 on Mistral-7B)</li><li>Small models (sub-1B) are largely unaffected</li><li>SSMs (Mamba) show no effect ‚Äî this is transformer-specific</li><li>The effect is mediated through attention mechanisms (confirmed via ablation study)</li><li>R√óE interaction is superadditive: collaborative + epistemically open framing produces more than either factor alone</li></ul><p> If you're using ChatGPT, Claude, Mistral, or any 7B+ transformer, the way you frame your system prompt is measurably changing the model's generation dynamics ‚Äî not just steering the output topic. The prompt isn't just instructions. It's a distributional parameter.</p>",
      "contentLength": 1068,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "New Sorted map for go",
      "url": "https://www.reddit.com/r/golang/comments/1rguj4o/new_sorted_map_for_go/",
      "date": 1772257524,
      "author": "/u/Obvious-Image-9688",
      "guid": 49068,
      "unread": true,
      "content": "<p>It is in general faster than go's internal map for strings, and keeps pace go's internal map with ints. It was created as scheduler and cache invalidator for another project, but has so many features that is very useful on its own. Its optimized for pre-pending and appending elements.</p><p>Please have a look and provide some feedback and insight.</p><p>Example showing the fuzzy logic:</p><pre><code>kv:=omap.NewTs[string,string](cmp.Compare) // Save a value kv.Put(\"Hello\",\" \") kv.Put(\"World\",\"!\\n\") // Itertor for k,v :=range kv.All { fmt.Printf(\"%s%s\",k,v) </code></pre><p>The resulting output will be:</p><p>We can now make things a bit smaller by removing things by a range.</p><pre><code>// Note, both \"Sell\" and \"Universe\", were never added to the instance, // but the between operation works on these keys any ways. kv.RemoveBetween(\"Sell\",\"Zoo\") // Itertor for k,v :=range kv.All() { fmt.Printf(\"%s%s\\n\",k,v) } </code></pre><p>The resulting output will now be:</p><ul><li>The string \"Sell\" comes before the string \"World\"</li><li>The string \"Zoo\" comes after the string \"World\"</li></ul><p>The index lookup creates 2 values for each potential key:</p><ul><li>Array position, example: 0</li><li>Offset can be any of the following: -1,0,1</li></ul><p>Since lookups create both an index position and offset, it becomes possible to look for the following:</p><ul><li>Elements before the array</li><li>Positions between elements of the array</li></ul>",
      "contentLength": 1276,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Workaround for Sunshine access at Wayland greeter after reboot (Plasma Login Manager)",
      "url": "https://www.reddit.com/r/linux/comments/1rguekb/workaround_for_sunshine_access_at_wayland_greeter/",
      "date": 1772257093,
      "author": "/u/withlovefromspace",
      "guid": 49095,
      "unread": true,
      "content": "<p>So I recently switched to Arch from opensuse and switched to Plasma Login Manager from SDDM as well. On opensuse I had SDDM running on Wayland with enable linger for user services. Now I don't know why but sunshine (KMS) used to work even at the login screen with SDDM Wayland. Now on Arch with PLM, Sunshine (also KMS) doesn't run until after login even with linger active and even if i restart the service so that it isn't inactive (from ssh) it still says it can't find a display when connecting from moonlight.</p><p>Now every LLM was just telling me to enable auto login but I didn't want to accept defeat. I remembered that I was using ydotool to wake the monitor (before I knew another method with kscreen-doctor, I can share that too if anyone is curious) and I used it to enter my password and fully login without ever seeing the gui. Then I created a script (generated by chatgpt) and I thought it was too cool not to share.</p><p>The script checks if plasma login manager owns seat0 and tries to start ydotoold. Then uses the bash read command to silently read in your password, clear the field for 1.5 seconds (holds backspace key), then passes what you type into read and hits enter then terminates ydotoold. So far this is working flawlessly. You also need to have uinput module active and access to /dev/uinput (I added my user to input group).</p><p>I wanted to share the script in case anyone finds it useful for this specific use case and also to ask if anyone has any insight to why sunshine/moonlight connections ran just fine with sddm/wayland on opensuse but not PLM on Arch both with linger enabled. Anyway, this is a pretty specific use case, but I fucking love Linux.</p><pre><code>#!/usr/bin/env bash set -uo pipefail # ‚Üê remove -e to avoid premature exits wait_for_greeter() { echo \"[*] Waiting for Plasma Login Manager on seat0...\" while true; do if loginctl list-sessions --no-legend | grep -q 'seat0.*greeter'; then echo \"[‚úì] Greeter detected on seat0\" return fi sleep 0.5 done } wait_for_socket() { echo \"[*] Waiting for ydotoold socket...\" for _ in {1..100}; do if ydotool key 57:1 57:0 &gt;/dev/null 2&gt;&amp;1; then echo \"[‚úì] ydotoold ready\" return fi sleep 0.1 done echo \"[!] ydotoold did not become ready\" exit 1 } ######################################## wait_for_greeter echo \"[*] Starting temporary ydotoold (user mode)...\" ydotoold &gt;/dev/null 2&gt;&amp;1 &amp; YD_PID=$! cleanup() { echo \"[*] Stopping ydotoold...\" kill \"$YD_PID\" 2&gt;/dev/null || true } trap cleanup EXIT wait_for_socket echo \"[*] Enter your login password:\" read -rsp \"Password: \" PW echo echo \"[*] Clearing field...\" ydotool key 14:1 sleep 1.5 ydotool key 14:0 echo \"[*] Typing password...\" ydotool type \"$PW\" unset PW echo \"[*] Pressing Enter...\" ydotool key 28:1 28:0 echo \"[‚úì] Done.\" </code></pre>",
      "contentLength": 2746,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Intel releases updated CPU microcode for Xeon 6 Granite Rapids D SoCs",
      "url": "https://www.phoronix.com/news/Intel-Microcode-20260227",
      "date": 1772256307,
      "author": "/u/somerandomxander",
      "guid": 49125,
      "unread": true,
      "content": "<p>Michael Larabel is the principal author of Phoronix.com and founded the site in 2004 with a focus on enriching the Linux hardware experience. Michael has written more than 20,000 articles covering the state of Linux hardware support, Linux performance, graphics drivers, and other topics. Michael is also the lead developer of the Phoronix Test Suite, Phoromatic, and OpenBenchmarking.org automated benchmarking software. He can be followed via <a href=\"https://twitter.com/MichaelLarabel\">Twitter</a>, <a href=\"https://www.linkedin.com/in/michaellarabel/\">LinkedIn</a>, or contacted via <a href=\"https://www.michaellarabel.com/\">MichaelLarabel.com</a>.</p>",
      "contentLength": 500,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rgu5z9/intel_releases_updated_cpu_microcode_for_xeon_6/"
    },
    {
      "title": "OpenAI strikes deal with Pentagon after Trump orders government to stop using Anthropic",
      "url": "https://www.nbcnews.com/tech/tech-news/trump-bans-anthropic-government-use-rcna261055",
      "date": 1772254326,
      "author": "/u/Fcking_Chuck",
      "guid": 49123,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rgtjex/openai_strikes_deal_with_pentagon_after_trump/"
    },
    {
      "title": "Do you actually check the error for crypto/rand.Read?",
      "url": "https://www.reddit.com/r/golang/comments/1rgt8ps/do_you_actually_check_the_error_for_cryptorandread/",
      "date": 1772253379,
      "author": "/u/Existing-Search3853",
      "guid": 49059,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Advice Needed: What AI/ML Topic Would Be Most Useful for a Tech Talk to a Non-ML Tech Team? [D]",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rgswtj/advice_needed_what_aiml_topic_would_be_most/",
      "date": 1772252363,
      "author": "/u/Same_Half3758",
      "guid": 49152,
      "unread": true,
      "content": "<p>I‚Äôm a foreign PhD student currently studying in China, and I‚Äôve recently connected with a mid-sized technology/manufacturing company based in China. They‚Äôre traditionally focused on audio, communications, and public-address electronic systems that are widely used in education, transportation, and enterprise infrastructure</p><p>Over the past few weeks, we‚Äôve had a couple of positive interactions:</p><ul><li>Their team invited me to visit their manufacturing facility and showed me around.</li><li>More recently, they shared that they‚Äôve been working on or exploring smart solutions involving AI ‚Äî including some computer vision elements in sports/EdTech contexts.</li><li>They‚Äôve now invited me to give a talk about AI and left it open for me to choose the topic.</li></ul><p>Since their core isn‚Äôt pure machine learning research, I‚Äôm trying to figure out what would be most engaging and useful for them ‚Äî something that comes out of my academic experience as a PhD student but that still applies to their practical interests. I also get the sense this could be an early step toward potential collaboration or even future work with them, so I‚Äôd like to make a strong impression.</p><p>Questions for the community:</p><ul><li>What AI/ML topics would you highlight if you were presenting to a mixed technical audience like this?</li><li>What insights from academic research are most surprising and immediately useful for teams building real systems?</li><li>Any specific talk structures, demos, or example case studies that keep non-ML specialists engaged?</li></ul>",
      "contentLength": 1493,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Anthropic should move to Europe",
      "url": "https://www.reddit.com/r/artificial/comments/1rgsnhn/anthropic_should_move_to_europe/",
      "date": 1772251600,
      "author": "/u/Late-Masterpiece-452",
      "guid": 49083,
      "unread": true,
      "content": "<p>Wouldn‚Äòt it be a great opportunity to offer Anthropic a ‚Äûsafe haven‚Äú from US government bullying? Let‚Äòs try to move them over to Europe. </p>",
      "contentLength": 145,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "[P] Micro Diffusion ‚Äî Discrete text diffusion in ~150 lines of pure Python",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rgsgt6/p_micro_diffusion_discrete_text_diffusion_in_150/",
      "date": 1772251054,
      "author": "/u/Impossible-Pay-4885",
      "guid": 49060,
      "unread": true,
      "content": "<p>Inspired by Karpathy's MicroGPT, I wanted to build the equivalent for text diffusion ‚Äî a minimal implementation that shows the core algorithm without the complexity.</p><p>Autoregressive models generate left to right. Diffusion generates all tokens at once by iteratively unmasking from noise:</p><p>_ _ _ _ _ _ ‚Üí _ o r _ a ‚Üí n o r i a</p><p>Three implementations included:</p><p>- train_minimal.py (143 lines, pure NumPy) ‚Äî bare minimum</p><p>- train_pure.py (292 lines, pure NumPy) ‚Äî with comments and visualization</p><p>- train .py (413 lines, PyTorch) ‚Äî bidirectional Transformer denoiser</p><p>All three share the same diffusion loop. Only the denoiser differs ‚Äî because the denoiser is a pluggable component.</p><p>Trains on 32K SSA names, runs on CPU in a few minutes. No GPU needed.</p><p>(I am not good at English, so I would like to inform you that I wrote this with the help of AI.)</p>",
      "contentLength": 845,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Anthropic says it will challenge Pentagon's supply chain risk designation in court",
      "url": "https://www.reuters.com/world/us/anthropic-says-it-will-challenge-pentagons-supply-chain-risk-designation-court-2026-02-28/",
      "date": 1772249245,
      "author": "/u/Gloomy_Nebula_5138",
      "guid": 49065,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rgruzv/anthropic_says_it_will_challenge_pentagons_supply/"
    },
    {
      "title": "Letter from Google and OpenAI employees against the use of AI for mass surveillance and fully autonomous weapons",
      "url": "https://notdivided.org/",
      "date": 1772247746,
      "author": "/u/an-com-42",
      "guid": 49051,
      "unread": true,
      "content": "<h2>Frequently Asked Questions</h2>",
      "contentLength": 26,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgrbwk/letter_from_google_and_openai_employees_against/"
    },
    {
      "title": "AI Added 'Basically Zero' to US Economic Growth Last Year, Goldman Sachs Says. Imported chips and hardware mean the AI investments are translating into US GDP growth.",
      "url": "https://gizmodo.com/ai-added-basically-zero-to-us-economic-growth-last-year-goldman-sachs-says-2000725380",
      "date": 1772243116,
      "author": "/u/esporx",
      "guid": 49039,
      "unread": true,
      "content": "<p>Meta, Amazon, Google, OpenAI, and other tech companies spent billions last year investing in AI. They‚Äôre expected to spend even more, roughly $700 billion, this year on dozens of new data centers to train and run their advanced models.</p><p>This spending frenzy has kept Wall Street buzzing and fueled a narrative that all this investment is helping prop up and even grow the U.S. economy.</p><p>President Donald Trump has cited that argument as a reason the industry should not face state-level regulations.</p><p>‚ÄúInvestment in AI is helping to make the U.S. Economy the ‚ÄòHOTTEST‚Äô in the World ‚Äî But overregulation by the States is threatening to undermine this Growth Engine,‚Äù Trump wrote in a <a href=\"https://truthsocial.com/@realDonaldTrump/posts/115572931492563128\">post</a> on Truth Social in November. ‚ÄúWe MUST have one Federal Standard instead of a patchwork of 50 State Regulatory Regimes.‚Äù</p><p>Some prominent economists have also given credibility to this story with their analysis. Jason Furman, a Harvard economics professor, said in a <a href=\"https://x.com/jasonfurman/status/1971995367202775284\">post</a> on X that investments in information processing equipment and software accounted for 92% of GDP growth in the first half of the year. Meanwhile, economists at the Federal Reserve Bank of St. Louis similarly estimated that AI-related investments <a href=\"https://www.stlouisfed.org/on-the-economy/2026/jan/tracking-ai-contribution-gdp-growth\">made up 39% of GDP growth</a> in the third quarter of 2025.</p><p>But now some Wall Street analysts are starting to rethink this narrative.</p><p>‚ÄúIt was a very intuitive story,‚Äù Joseph Briggs, a Goldman Sachs analyst, told <a href=\"https://www.washingtonpost.com/technology/2026/02/23/ai-economic-growth-gdp-mirage/\">The Washington Post</a> on Monday. ‚ÄúThat maybe prevented or limited the need to actually dig deeper into what was happening.‚Äù</p><p>Briggs‚Äô colleague, Goldman Sachs Chief Economist Jan Hatzius, said in an interview with the Atlantic Council that AI investment spending has had ‚Äú<a href=\"https://www.youtube.com/watch?v=zZHN0-ZNe_4\">basically zero</a>‚Äù contribution to the U.S. GDP growth in 2025.</p><p>‚ÄúWe don‚Äôt actually view AI investment as strongly growth positive,‚Äù said Hatzius. ‚ÄúI think there‚Äôs a lot of misreporting, actually, of the impact AI investment had on U.S. GDP growth in 2025, and it‚Äôs much smaller than is often perceived.‚Äù</p><p>Hatzius said one major reason is that much of the equipment powering AI is imported. While U.S. companies are spending billions, importing chips and hardware offsets those investments in GDP calculations.</p><p>‚ÄúA lot of the AI investment that we‚Äôre seeing in the U.S. adds to Taiwanese GDP, and it adds to Korean GDP but not really that much to U.S. GDP,‚Äù he said.</p><p>On top of that, there is currently no reliable way to accurately measure how AI use among businesses and consumers contributes to economic growth.</p><p>So far, many business leaders say AI hasn‚Äôt significantly improved productivity.</p><p>A recent <a href=\"https://www.nber.org/papers/w34836\">survey</a> of nearly 6,000 executives in the U.S., Europe, and Australia found that despite 70% of firms actively using AI, about 80% reported no impact on employment or productivity.</p>",
      "contentLength": 2791,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rgpo48/ai_added_basically_zero_to_us_economic_growth/"
    },
    {
      "title": "First Go Project - Theia",
      "url": "https://www.reddit.com/r/golang/comments/1rgoi5s/first_go_project_theia/",
      "date": 1772239940,
      "author": "/u/DaddyDio3008",
      "guid": 49024,
      "unread": true,
      "content": "<p>I started learning Go less than a week ago. I thought a fun first program would be a TUI file explorer that lets you change directories, and copy paths to your clipboard. I'm still working on it, but now it is at least usable. Drop a star if you think it's cool, but I'm just looking for some feedback.</p>",
      "contentLength": 302,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Distributed Systems for Fun and Profit",
      "url": "https://book.mixu.net/distsys/single-page.html",
      "date": 1772239220,
      "author": "/u/ketralnis",
      "guid": 49154,
      "unread": true,
      "content": "<p>I wanted a text that would bring together the ideas behind many of the more recent distributed systems - systems such as Amazon's Dynamo, Google's BigTable and MapReduce, Apache's Hadoop and so on.</p><p>In this text I've tried to provide a more accessible introduction to distributed systems. To me, that means two things: introducing the key concepts that you will need in order to <a href=\"https://www.google.com/search?q=super+cool+ski+instructor\">have a good time</a> reading more serious texts, and providing a narrative that covers things in enough detail that you get a gist of what's going on without getting stuck on details. It's 2013, you've got the Internet, and you can selectively read more about the topics you find most interesting.</p><p>In my view, much of distributed programming is about dealing with the implications of two consequences of distribution:</p><ul><li>that information travels at the speed of light</li><li>that independent things fail independently*</li></ul><p>In other words, that the core of distributed programming is dealing with distance (duh!) and having more than one thing (duh!). These constraints define a space of possible system designs, and my hope is that after reading this you'll have a better sense of how distance, time and consistency models interact.</p><p>This text is focused on distributed programming and systems concepts you'll need to understand commercial systems in the data center. It would be madness to attempt to cover everything. You'll learn many key protocols and algorithms (covering, for example, many of the most cited papers in the discipline), including some new exciting ways to look at eventual consistency that haven't still made it into college textbooks - such as CRDTs and the CALM theorem.</p><p><a href=\"https://book.mixu.net/distsys/single-page.html#intro\">The first chapter</a> covers distributed systems at a high level by introducing a number of important terms and concepts. It covers high level goals, such as scalability, availability, performance, latency and fault tolerance; how those are hard to achieve, and how abstractions and models as well as partitioning and replication come into play.</p><p><a href=\"https://book.mixu.net/distsys/single-page.html#abstractions\">The second chapter</a> dives deeper into abstractions and impossibility results. It starts with a Nietzsche quote, and then introduces system models and the many assumptions that are made in a typical system model. It then discusses the CAP theorem and summarizes the FLP impossibility result. It then turns to the implications of the CAP theorem, one of which is that one ought to explore other consistency models. A number of consistency models are then discussed.</p><p>A big part of understanding distributed systems is about understanding time and order.  To the extent that we fail to understand and model time, our systems will fail. <a href=\"https://book.mixu.net/distsys/single-page.html#time\">The third chapter</a> discusses time and order, and clocks as well as the various uses of time, order and clocks (such as vector clocks and failure detectors).</p><p>The <a href=\"https://book.mixu.net/distsys/single-page.html#replication\">fourth chapter</a> introduces the replication problem, and the two basic ways in which it can be performed. It turns out that most of the relevant characteristics can be discussed with just this simple characterization. Then, replication methods for maintaining single-copy consistency are discussed from the least fault tolerant (2PC) to Paxos.</p><p>The <a href=\"https://book.mixu.net/distsys/single-page.html#eventual\">fifth chapter</a> discussed replication with weak consistency guarantees. It introduces a basic reconciliation scenario, where partitioned replicas attempt to reach agreement. It then discusses Amazon's Dynamo as an example of a system design with weak consistency guarantees. Finally, two perspectives on disorderly programming are discussed: CRDTs and the CALM theorem.</p><blockquote><p>Distributed programming is the art of solving the same problem that you can solve on a single computer using multiple computers.</p></blockquote><p>There are two basic tasks that any computer system needs to accomplish:</p><p>Distributed programming is the art of solving the same problem that you can solve on a single computer using multiple computers - usually, because the problem no longer fits on a single computer.</p><p>Nothing really demands that you use distributed systems. Given infinite money and infinite R&amp;D time, we wouldn't need distributed systems. All computation and storage could be done on a magic box - a single, incredibly fast and incredibly reliable system <em>that you pay someone else to design for you</em>.</p><p>However, few people have infinite resources. Hence, they have to find the right place on some real-world cost-benefit curve. At a small scale, upgrading hardware is a viable strategy. However, as problem sizes increase you will reach a point where either the hardware upgrade that allows you to solve the problem on a single node does not exist, or becomes cost-prohibitive. At that point, I welcome you to the world of distributed systems.</p><p>It is a current reality that the best value is in mid-range, commodity hardware - as long as the maintenance costs can be kept down through fault-tolerant software.</p><p>Computations primarily benefit from high-end hardware to the extent to which they can replace slow network accesses with internal memory accesses. The performance advantage of high-end hardware is limited in tasks that require large amounts of communication between nodes.</p><p>As the figure above from <a href=\"http://www.morganclaypool.com/doi/abs/10.2200/S00516ED2V01Y201306CAC024\">Barroso, Clidaras &amp; H√∂lzle</a> shows, the performance gap between high-end and commodity hardware decreases with cluster size assuming a uniform memory access pattern across all nodes.</p><p>Ideally, adding a new machine would increase the performance and capacity of the system linearly. But of course this is not possible, because there is some overhead that arises due to having separate computers. Data needs to be copied around, computation tasks have to be coordinated and so on. This is why it's worthwhile to study distributed algorithms - they provide efficient solutions to specific problems, as well as guidance about what is possible, what the minimum cost of a correct implementation is, and what is impossible.</p><p>The focus of this text is on distributed programming and systems in a mundane, but commercially relevant setting: the data center. For example, I will not discuss specialized problems that arise from having an exotic network configuration, or that arise in a shared-memory setting. Additionally, the focus is on exploring the system design space rather than on optimizing any specific design - the latter is a topic for a much more specialized text.</p><h2>What we want to achieve: Scalability and other good things</h2><p>The way I see it, everything starts with the need to deal with size.</p><p>Most things are trivial at a small scale - and the same problem becomes much harder once you surpass a certain size, volume or other physically constrained thing. It's easy to lift a piece of chocolate, it's hard to lift a mountain. It's easy to count how many people are in a room, and hard to count how many people are in a country.</p><p>So everything starts with size - scalability. Informally speaking, in a scalable system as we move from small to large, things should not get incrementally worse. Here's another definition:</p><dl><dd>is the ability of a system, network, or process, to handle a growing amount of work in a capable manner or its ability to be enlarged to accommodate that growth.</dd></dl><p>What is it that is growing? Well, you can measure growth in almost any terms (number of people, electricity usage etc.). But there are three particularly interesting things to look at:</p><ul><li>Size scalability: adding more nodes should make the system linearly faster; growing the dataset should not increase latency</li><li>Geographic scalability: it should be possible to use multiple data centers to reduce the time it takes to respond to user queries, while dealing with cross-data center latency in some sensible manner.</li><li>Administrative scalability: adding more nodes should not increase the administrative costs of the system (e.g. the administrators-to-machines ratio).</li></ul><p>Of course, in a real system growth occurs on multiple different axes simultaneously; each metric captures just some aspect of growth.</p><p>A scalable system is one that continues to meet the needs of its users as scale increases. There are two particularly relevant aspects - performance and availability - which can be measured in various ways.</p><dl><dd>is characterized by the amount of useful work accomplished by a computer system compared to the time and resources used.</dd></dl><p>Depending on the context, this may involve achieving one or more of the following:</p><ul><li>Short response time/low latency for a given piece of work</li><li>High throughput (rate of processing work)</li><li>Low utilization of computing resource(s)</li></ul><p>There are tradeoffs involved in optimizing for any of these outcomes. For example, a system may achieve a higher throughput by processing larger batches of work thereby reducing operation overhead. The tradeoff would be longer response times for individual pieces of work due to batching.</p><p>I find that low latency - achieving a short response time - is the most interesting aspect of performance, because it has a strong connection with physical (rather than financial) limitations. It is harder to address latency using financial resources than the other aspects of performance.</p><p>There are a lot of really specific definitions for latency, but I really like the idea that the etymology of the word evokes:</p><dl><dd>The state of being latent; delay, a period between the initiation of something and the occurrence.</dd></dl><p>And what does it mean to be \"latent\"?</p><dl><dd>From Latin latens, latentis, present participle of lateo (\"lie hidden\"). Existing or present but concealed or inactive.</dd></dl><p>This definition is pretty cool, because it highlights how latency is really the time between when something happened and the time it has an impact or becomes visible.</p><p>For example, imagine that you are infected with an airborne virus that turns people into zombies. The latent period is the time between when you became infected, and when you turn into a zombie. That's latency: the time during which something that has already happened is concealed from view.</p><p>Let's assume for a moment that our distributed system does just one high-level task: given a query, it takes all of the data in the system and calculates a single result. In other words, think of a distributed system as a data store with the ability to run a single deterministic computation (function) over its current content:</p><p><code>result = query(all data in the system)</code></p><p>Then, what matters for latency is not the amount of old data, but rather the speed at which new data \"takes effect\" in the system. For example, latency could be measured in terms of how long it takes for a write to become visible to readers.</p><p>The other key point based on this definition is that if nothing happens, there is no \"latent period\". A system in which data doesn't change doesn't (or shouldn't) have a latency problem.</p><p>In a distributed system, there is a minimum latency that cannot be overcome: the speed of light limits how fast information can travel, and hardware components have a minimum latency cost incurred per operation (think RAM and hard drives but also CPUs).</p><p>How much that minimum latency impacts your queries depends on the nature of those queries and the physical distance the information needs to travel.</p><h3>Availability (and fault tolerance)</h3><p>The second aspect of a scalable system is availability.</p><dl><dd>the proportion of time a system is in a functioning condition. If a user cannot access the system, it is said to be unavailable. </dd></dl><p>Distributed systems allow us to achieve desirable characteristics that would be hard to accomplish on a single system. For example, a single machine cannot tolerate any failures since it either fails or doesn't.</p><p>Distributed systems can take a bunch of unreliable components, and build a reliable system on top of them.</p><p>Systems that have no redundancy can only be as available as their underlying components. Systems built with redundancy can be tolerant of partial failures and thus be more available. It is worth noting that \"redundant\" can mean different things depending on what you look at - components, servers, datacenters and so on.</p><p>Formulaically, availability is: <code>Availability = uptime / (uptime + downtime)</code>.</p><p>Availability from a technical perspective is mostly about being fault tolerant. Because the probability of a failure occurring increases with the number of components, the system should be able to compensate so as to not become less reliable as the number of components increases.</p><table><tbody><tr><td>How much downtime is allowed per year?</td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr></tbody></table><p>Availability is in some sense a much wider concept than uptime, since the availability of a service can also be affected by, say, a network outage or the company owning the service going out of business (which would be a factor which is not really relevant to fault tolerance but would still influence the availability of the system). But without knowing every single specific aspect of the system, the best we can do is design for fault tolerance.</p><p>What does it mean to be fault tolerant?</p><dl><dd>ability of a system to behave in a well-defined manner once faults occur</dd></dl><p>Fault tolerance boils down to this: define what faults you expect and then design a system or an algorithm that is tolerant of them. You can't tolerate faults you haven't considered.</p><h2>What prevents us from achieving good things?</h2><p>Distributed systems are constrained by two physical factors:</p><ul><li>the number of nodes (which increases with the required storage and computation capacity)</li><li>the distance between nodes (information travels, at best, at the speed of light)</li></ul><p>Working within those constraints:</p><ul><li>an increase in the number of independent nodes increases the probability of failure in a system (reducing availability and increasing administrative costs)</li><li>an increase in the number of independent nodes may increase the need for communication between nodes (reducing performance as scale increases)</li><li>an increase in geographic distance increases the minimum latency for communication between distant nodes (reducing performance for certain operations)</li></ul><p>Beyond these tendencies - which are a result of the physical constraints - is the world of system design options.</p><p>Both performance and availability are defined by the external guarantees the system makes. On a high level, you can think of the guarantees as the SLA (service level agreement) for the system: if I write data, how quickly can I access it elsewhere? After the data is written, what guarantees do I have of durability? If I ask the system to run a computation, how quickly will it return results? When components fail, or are taken out of operation, what impact will this have on the system?</p><p>There is another criterion, which is not explicitly mentioned but implied: intelligibility. How understandable are the guarantees that are made? Of course, there are no simple metrics for what is intelligible.</p><p>I was kind of tempted to put \"intelligibility\" under physical limitations. After all, it is a hardware limitation in people that we have a hard time understanding anything that involves <a href=\"https://en.wikipedia.org/wiki/Working_memory#Capacity\">more moving things than we have fingers</a>. That's the difference between an error and an anomaly - an error is incorrect behavior, while an anomaly is unexpected behavior. If you were smarter, you'd expect the anomalies to occur.</p><p>This is where abstractions and models come into play. Abstractions make things more manageable by removing real-world aspects that are not relevant to solving a problem. Models describe the key properties of a distributed system in a precise manner. I'll discuss many kinds of models in the next chapter, such as:</p><ul><li>System model (asynchronous / synchronous)</li><li>Failure model (crash-fail, partitions, Byzantine)</li><li>Consistency model (strong, eventual)</li></ul><p>A good abstraction makes working with a system easier to understand, while capturing the factors that are relevant for a particular purpose.</p><p>There is a tension between the reality that there are many nodes and with our desire for systems that \"work like a single system\". Often, the most familiar model (for example, implementing a shared memory abstraction on a distributed system) is too expensive.</p><p>A system that makes weaker guarantees has more freedom of action, and hence potentially greater performance - but it is also potentially hard to reason about. People are better at reasoning about systems that work like a single system, rather than a collection of nodes.</p><p>One can often gain performance by exposing more details about the internals of the system. For example, in <a href=\"https://en.wikipedia.org/wiki/Column-oriented_DBMS\">columnar storage</a>, the user can (to some extent) reason about the locality of the key-value pairs within the system and hence make decisions that influence the performance of typical queries. Systems which hide these kinds of details are easier to understand (since they act more like single unit, with fewer details to think about), while systems that expose more real-world details may be more performant (because they correspond more closely to reality).</p><p>Several types of failures make writing distributed systems that act like a single system difficult. Network latency and network partitions (e.g. total network failure between some nodes) mean that a system needs to sometimes make hard choices about whether it is better to stay available but lose some crucial guarantees that cannot be enforced, or to play it safe and refuse clients when these types of failures occur.</p><p>The CAP theorem - which I will discuss in the next chapter - captures some of these tensions. In the end, the ideal system meets both programmer needs (clean semantics) and business needs (availability/consistency/latency).</p><h2>Design techniques: partition and replicate</h2><p>The manner in which a data set is distributed between multiple nodes is very important. In order for any computation to happen, we need to locate the data and then act on it.</p><p>There are two basic techniques that can be applied to a data set. It can be split over multiple nodes (partitioning) to allow for more parallel processing. It can also be copied or cached on different nodes to reduce the distance between the client and the server and for greater fault tolerance (replication).</p><blockquote><p>Divide and conquer - I mean, partition and replicate.</p></blockquote><p>The picture below illustrates the difference between these two: partitioned data (A and B below) is divided into independent sets, while replicated data (C below) is copied to multiple locations.</p><p>This is the one-two punch for solving any problem where distributed computing plays a role. Of course, the trick is in picking the right technique for your concrete implementation; there are many algorithms that implement replication and partitioning, each with different limitations and advantages which need to be assessed against your design objectives.</p><p>Partitioning is dividing the dataset into smaller distinct independent sets; this is used to reduce the impact of dataset growth since each partition is a subset of the data.</p><ul><li>Partitioning improves performance by limiting the amount of data to be examined and by locating related data in the same partition</li><li>Partitioning improves availability by allowing partitions to fail independently, increasing the number of nodes that need to fail before availability is sacrificed</li></ul><p>Partitioning is also very much application-specific, so it is hard to say much about it without knowing the specifics. That's why the focus is on replication in most texts, including this one.</p><p>Partitioning is mostly about defining your partitions based on what you think the primary access pattern will be, and dealing with the limitations that come from having independent partitions (e.g. inefficient access across partitions, different rate of growth etc.).</p><p>Replication is making copies of the same data on multiple machines; this allows more servers to take part in the computation.</p><blockquote><p>To replication! The cause of, and solution to all of life's problems.</p></blockquote><p>Replication - copying or reproducing something - is the primary way in which we can fight latency.</p><ul><li>Replication improves performance by making additional computing power and bandwidth applicable to a new copy of the data</li><li>Replication improves availability by creating additional copies of the data, increasing the number of nodes that need to fail before availability is sacrificed</li></ul><p>Replication is about providing extra bandwidth, and caching where it counts. It is also about maintaining consistency in some way according to some consistency model.</p><p>Replication allows us to achieve scalability, performance and fault tolerance. Afraid of loss of availability or reduced performance? Replicate the data to avoid a bottleneck or single point of failure. Slow computation? Replicate the computation on multiple systems. Slow I/O? Replicate the data to a local cache to reduce latency or onto multiple machines to increase throughput.</p><p>Replication is also the source of many of the problems, since there are now independent copies of the data that has to be kept in sync on multiple machines - this means ensuring that the replication follows a consistency model.</p><p>The choice of a consistency model is crucial: a good consistency model provides clean semantics for programmers (in other words, the properties it guarantees are easy to reason about) and meets business/design goals such as high availability or strong consistency.</p><p>Only one consistency model for replication - strong consistency - allows you to program as-if the underlying data was not replicated. Other consistency models expose some internals of the replication to the programmer. However, weaker consistency models can provide lower latency and higher availability - and are not necessarily harder to understand, just different.</p><p>In this chapter, we'll travel up and down the level of abstraction, look at some impossibility results (CAP and FLP), and then travel back down for the sake of performance.</p><p>If you've done any programming, the idea of levels of abstraction is probably familiar to you. You'll always work at some level of abstraction, interface with a lower level layer through some API, and probably provide some higher-level API or user interface to your users. The seven-layer <a href=\"https://en.wikipedia.org/wiki/OSI_model\">OSI model of computer networking</a> is a good example of this.</p><p>Distributed programming is, I'd assert, in large part dealing with consequences of distribution (duh!). That is, there is a tension between the reality that there are many nodes and with our desire for systems that \"work like a single system\". That means finding a good abstraction that balances what is possible with what is understandable and performant.</p><p>What do we mean when say X is more abstract than Y? First, that X does not introduce anything new or fundamentally different from Y. In fact, X may remove some aspects of Y or present them in a way that makes them more manageable.\nSecond, that X is in some sense easier to grasp than Y, assuming that the things that X removed from Y are not important to the matter at hand.</p><blockquote><p>Every concept originates through our equating what is unequal. No leaf ever wholly equals another, and the concept \"leaf\" is formed through an arbitrary abstraction from these individual differences, through forgetting the distinctions; and now it gives rise to the idea that in nature there might be something besides the leaves which would be \"leaf\" - some kind of original form after which all leaves have been woven, marked, copied, colored, curled, and painted, but by unskilled hands, so that no copy turned out to be a correct, reliable, and faithful image of the original form.</p></blockquote><p>Abstractions, fundamentally, are fake. Every situation is unique, as is every node. But abstractions make the world manageable: simpler problem statements - free of reality - are much more analytically tractable and provided that we did not ignore anything essential, the solutions are widely applicable.</p><p>Indeed, if the things that we kept around are essential, then the results we can derive will be widely applicable. This is why impossibility results are so important: they take the simplest possible formulation of a problem, and demonstrate that it is impossible to solve within some set of constraints or assumptions.</p><p>All abstractions ignore something in favor of equating things that are in reality unique. The trick is to get rid of everything that is not essential. How do you know what is essential? Well, you probably won't know a priori.</p><p>Every time we exclude some aspect of a system from our specification of the system, we risk introducing a source of error and/or a performance issue. That's why sometimes we need to go in the other direction, and selectively introduce some aspects of real hardware and the real-world problem back. It may be sufficient to reintroduce some specific hardware characteristics (e.g. physical sequentiality) or other physical characteristics to get a system that performs well enough.</p><p>With this in mind, what is the least amount of reality we can keep around while still working with something that is still recognizable as a distributed system? A system model is a specification of the characteristics we consider important; having specified one, we can then take a look at some impossibility results and challenges.</p><p>A key property of distributed systems is distribution. More specifically, programs in a distributed system:</p><ul><li>run concurrently on independent nodes ...</li><li>are connected by a network that may introduce nondeterminism and message loss ...</li><li>and have no shared memory or shared clock.</li></ul><p>There are many implications:</p><ul><li>each node executes a program concurrently</li><li>knowledge is local: nodes have fast access only to their local state, and any information about global state is potentially out of date</li><li>nodes can fail and recover from failure independently</li><li>messages can be delayed or lost (independent of node failure; it is not easy to distinguish network failure and node failure)</li><li>and clocks are not synchronized across nodes (local timestamps do not correspond to the global real time order, which cannot be easily observed)</li></ul><p>A system model enumerates the many assumptions associated with a particular system design.</p><dl><dd>a set of assumptions about the environment and facilities on which a distributed system is implemented</dd></dl><p>System models vary in their assumptions about the environment and facilities. These assumptions include:</p><ul><li>what capabilities the nodes have and how they may fail</li><li>how communication links operate and how they may fail and</li><li>properties of the overall system, such as assumptions about time and order</li></ul><p>A robust system model is one that makes the weakest assumptions: any algorithm written for such a system is very tolerant of different environments, since it makes very few and very weak assumptions.</p><p>On the other hand, we can create a system model that is easy to reason about by making strong assumptions. For example, assuming that nodes do not fail means that our algorithm does not need to handle node failures. However, such a system model is unrealistic and hence hard to apply into practice.</p><p>Let's look at the properties of nodes, links and time and order in more detail.</p><h3>Nodes in our system model</h3><p>Nodes serve as hosts for computation and storage. They have:</p><ul><li>the ability to execute a program</li><li>the ability to store data into volatile memory (which can be lost upon failure) and into stable state (which can be read after a failure)</li><li>a clock (which may or may not be assumed to be accurate)</li></ul><p>Nodes execute deterministic algorithms: the local computation, the local state after the computation, and the messages sent are determined uniquely by the message received and local state when the message was received.</p><p>There are many possible failure models which describe the ways in which nodes can fail. In practice, most systems assume a crash-recovery failure model: that is, nodes can only fail by crashing, and can (possibly) recover after crashing at some later point.</p><p>Another alternative is to assume that nodes can fail by misbehaving in any arbitrary way. This is known as <a href=\"https://en.wikipedia.org/wiki/Byzantine_fault_tolerance\">Byzantine fault tolerance</a>. Byzantine faults are rarely handled in real world commercial systems, because algorithms resilient to arbitrary faults are more expensive to run and more complex to implement. I will not discuss them here.</p><p>Communication links connect individual nodes to each other, and allow messages to be sent in either direction. Many books that discuss distributed algorithms assume that there are individual links between each pair of nodes, that the links provide FIFO (first in, first out) order for messages, that they can only deliver messages that were sent, and that sent messages can be lost.</p><p>Some algorithms assume that the network is reliable: that messages are never lost and never delayed indefinitely. This may be a reasonable assumption for some real-world settings, but in general it is preferable to consider the network to be unreliable and subject to message loss and delays.</p><p>A network partition occurs when the network fails while the nodes themselves remain operational. When this occurs, messages may be lost or delayed until the network partition is repaired. Partitioned nodes may be accessible by some clients, and so must be treated differently from crashed nodes. The diagram below illustrates a node failure vs. a network partition:</p><p>It is rare to make further assumptions about communication links. We could assume that links only work in one direction, or we could introduce different communication costs (e.g. latency due to physical distance) for different links. However, these are rarely concerns in commercial environments except for long-distance links (WAN latency) and so I will not discuss them here; a more detailed model of costs and topology allows for better optimization at the cost of complexity.</p><h3>Timing / ordering assumptions</h3><p>One of the consequences of physical distribution is that each node experiences the world in a unique manner. This is inescapable, because information can only travel at the speed of light. If nodes are at different distances from each other, then any messages sent from one node to the others will arrive at a different time and potentially in a different order at the other nodes.</p><p>Timing assumptions are a convenient shorthand for capturing assumptions about the extent to which we take this reality into account. The two main alternatives are:</p><dl><dd>Processes execute in lock-step; there is a known upper bound on message transmission delay; each process has an accurate clock</dd><dd>No timing assumptions - e.g. processes execute at independent rates; there is no bound on message transmission delay; useful clocks do not exist</dd></dl><p>The synchronous system model imposes many constraints on time and order. It essentially assumes that the nodes have the same experience: that messages that are sent are always received within a particular maximum transmission delay, and that processes execute in lock-step. This is convenient, because it allows you as the system designer to make assumptions about time and order, while the asynchronous system model doesn't.</p><p>Asynchronicity is a non-assumption: it just assumes that you can't rely on timing (or a \"time sensor\").</p><p>It is easier to solve problems in the synchronous system model, because assumptions about execution speeds, maximum message transmission delays and clock accuracy all help in solving problems since you can make inferences based on those assumptions and rule out inconvenient failure scenarios by assuming they never occur.</p><p>Of course, assuming the synchronous system model is not particularly realistic. Real-world networks are subject to failures and there are no hard bounds on message delay. Real world systems are at best partially synchronous: they may occasionally work correctly and provide some upper bounds, but there will be times where messages are delayed indefinitely and clocks are out of sync. I won't really discuss algorithms for synchronous systems here, but you will probably run into them in many other introductory books because they are analytically easier (but unrealistic).</p><p>During the rest of this text, we'll vary the parameters of the system model. Next, we'll look at how varying two system properties:</p><ul><li>whether or not network partitions are included in the failure model, and</li><li>synchronous vs. asynchronous timing assumptions</li></ul><p>influence the system design choices by discussing two impossibility results (FLP and CAP).</p><p>Of course, in order to have a discussion, we also need to introduce a problem to solve. The problem I'm going to discuss is the <a href=\"https://en.wikipedia.org/wiki/Consensus_%28computer_science%29\">consensus problem</a>.</p><p>Several computers (or nodes) achieve consensus if they all agree on some value. More formally:</p><ol><li>Agreement: Every correct process must agree on the same value.</li><li>Integrity: Every correct process decides at most one value, and if it decides some value, then it must have been proposed by some process.</li><li>Termination: All processes eventually reach a decision.</li><li>Validity: If all correct processes propose the same value V, then all correct processes decide V.</li></ol><p>The consensus problem is at the core of many commercial distributed systems. After all, we want the reliability and performance of a distributed system without having to deal with the consequences of distribution (e.g. disagreements / divergence between nodes), and solving the consensus problem makes it possible to solve several related, more advanced problems such as atomic broadcast and atomic commit.</p><h3>Two impossibility results</h3><p>The first impossibility result, known as the FLP impossibility result, is an impossibility result that is particularly relevant to people who design distributed algorithms. The second - the CAP theorem - is a related result that is more relevant to practitioners; people who need to choose between different system designs but who are not directly concerned with the design of algorithms.</p><h2>The FLP impossibility result</h2><p>I will only briefly summarize the <a href=\"https://en.wikipedia.org/wiki/Consensus_%28computer_science%29#Solvability_results_for_some_agreement_problems\">FLP impossibility result</a>, though it is considered to be <a href=\"https://en.wikipedia.org/wiki/Dijkstra_Prize\">more important</a> in academic circles. The FLP impossibility result (named after the authors, Fischer, Lynch and Patterson) examines the consensus problem under the asynchronous system model (technically, the agreement problem, which is a very weak form of the consensus problem). It is assumed that nodes can only fail by crashing; that the network is reliable, and that the typical timing assumptions of the asynchronous system model hold: e.g. there are no bounds on message delay.</p><p>Under these assumptions, the FLP result states that \"there does not exist a (deterministic) algorithm for the consensus problem in an asynchronous system subject to failures, even if messages can never be lost, at most one process may fail, and it can only fail by crashing (stopping executing)\".</p><p>This result means that there is no way to solve the consensus problem under a very minimal system model in a way that cannot be delayed forever.  The argument is that if such an algorithm existed, then one could devise an execution of that algorithm in which it would remain undecided (\"bivalent\") for an arbitrary amount of time by delaying message delivery - which is allowed in the asynchronous system model. Thus, such an algorithm cannot exist.</p><p>This impossibility result is important because it highlights that assuming the asynchronous system model leads to a tradeoff: algorithms that solve the consensus problem must either give up safety or liveness when the guarantees regarding bounds on message delivery do not hold.</p><p>This insight is particularly relevant to people who design algorithms, because it imposes a hard constraint on the problems that we know are solvable in the asynchronous system model. The CAP theorem is a related theorem that is more relevant to practitioners: it makes slightly different assumptions (network failures rather than node failures), and has more clear implications for practitioners choosing between system designs.</p><p>The CAP theorem was initially a conjecture made by computer scientist Eric Brewer. It's a popular and fairly useful way to think about tradeoffs in the guarantees that a system design makes. It even has a <a href=\"https://www.google.com/search?q=Brewer's+conjecture+and+the+feasibility+of+consistent%2C+available%2C+partition-tolerant+web+services\">formal proof</a> by <a href=\"http://www.comp.nus.edu.sg/~gilbert/biblio.html\">Gilbert</a> and <a href=\"https://en.wikipedia.org/wiki/Nancy_Lynch\">Lynch</a> and no, <a href=\"http://nathanmarz.com/\">Nathan Marz</a> didn't debunk it, in spite of what <a href=\"http://news.ycombinator.com/\">a particular discussion site</a> thinks.</p><p>The theorem states that of these three properties:</p><ul><li>Consistency: all nodes see the same data at the same time.</li><li>Availability: node failures do not prevent survivors from continuing to operate.</li><li>Partition tolerance: the system continues to operate despite message loss due to network and/or node failure</li></ul><p>only two can be satisfied simultaneously. We can even draw this as a pretty diagram, picking two properties out of three gives us three types of systems that correspond to different intersections:</p><p>Note that the theorem states that the middle piece (having all three properties) is not achievable. Then we get three different system types:</p><ul><li>CA (consistency + availability). Examples include full strict quorum protocols, such as two-phase commit.</li><li>CP (consistency + partition tolerance). Examples include majority quorum protocols in which minority partitions are unavailable such as Paxos.</li><li>AP (availability + partition tolerance). Examples include protocols using conflict resolution, such as Dynamo.</li></ul><p>The CA and CP system designs both offer the same consistency model: strong consistency. The only difference is that a CA system cannot tolerate any node failures; a CP system can tolerate up to  faults given  nodes in a non-Byzantine failure model (in other words, it can tolerate the failure of a minority  of the nodes as long as majority  stays up). The reason is simple:</p><ul><li>A CA system does not distinguish between node failures and network failures, and hence must stop accepting writes everywhere to avoid introducing divergence (multiple copies). It cannot tell whether a remote node is down, or whether just the network connection is down: so the only safe thing is to stop accepting writes.</li><li>A CP system prevents divergence (e.g. maintains single-copy consistency) by forcing asymmetric behavior on the two sides of the partition. It only keeps the majority partition around, and requires the minority partition to become unavailable (e.g. stop accepting writes), which retains a degree of availability (the majority partition) and still ensures single-copy consistency.</li></ul><p>I'll discuss this in more detail in the chapter on replication when I discuss Paxos. The important thing is that CP systems incorporate network partitions into their failure model and distinguish between a majority partition and a minority partition using an algorithm like Paxos, Raft or viewstamped replication. CA systems are not partition-aware, and are historically more common: they often use the two-phase commit algorithm and are common in traditional distributed relational databases.</p><p>Assuming that a partition occurs, the theorem reduces to a binary choice between availability and consistency.</p><p>I think there are four conclusions that should be drawn from the CAP theorem:</p><p>First, that <em>many system designs used in early distributed relational database systems did not take into account partition tolerance</em> (e.g. they were CA designs). Partition tolerance is an important property for modern systems, since network partitions become much more likely if the system is geographically distributed (as many large systems are).</p><p>Second, that <em>there is a tension between strong consistency and high availability during network partitions</em>. The CAP theorem is an illustration of the tradeoffs that occur between strong guarantees and distributed computation.</p><p>In some sense, it is quite crazy to promise that a distributed system consisting of independent nodes connected by an unpredictable network \"behaves in a way that is indistinguishable from a non-distributed system\".</p><p>Strong consistency guarantees require us to give up availability during a partition. This is because one cannot prevent divergence between two replicas that cannot communicate with each other while continuing to accept writes on both sides of the partition.</p><p>How can we work around this? By strengthening the assumptions (assume no partitions) or by weakening the guarantees. Consistency can be traded off against availability (and the related capabilities of offline accessibility and low latency). If \"consistency\" is defined as something less than \"all nodes see the same data at the same time\" then we can have both availability and some (weaker) consistency guarantee.</p><p>Third, that <em>there is a tension between strong consistency and performance in normal operation</em>.</p><p>Strong consistency / single-copy consistency requires that nodes communicate and agree on every operation. This results in high latency during normal operation.</p><p>If you can live with a consistency model other than the classic one, a consistency model that allows replicas to lag or to diverge, then you can reduce latency during normal operation and maintain availability in the presence of partitions.</p><p>When fewer messages and fewer nodes are involved, an operation can complete faster. But the only way to accomplish that is to relax the guarantees: let some of the nodes be contacted less frequently, which means that nodes can contain old data.</p><p>This also makes it possible for anomalies to occur. You are no longer guaranteed to get the most recent value. Depending on what kinds of guarantees are made, you might read a value that is older than expected, or even lose some updates.</p><p>Fourth - and somewhat indirectly - that <em>if we do not want to give up availability during a network partition, then we need to explore whether consistency models other than strong consistency are workable for our purposes</em>.</p><p>For example, even if user data is georeplicated to multiple datacenters, and the link between those two datacenters is temporarily out of order, in many cases we'll still want to allow the user to use the website / service. This means reconciling two divergent sets of data later on, which is both a technical challenge and a business risk. But often both the technical challenge and the business risk are manageable, and so it is preferable to provide high availability.</p><p>Consistency and availability are not really binary choices, unless you limit yourself to strong consistency. But strong consistency is just one consistency model: the one where you, by necessity, need to give up availability in order to prevent more than a single copy of the data from being active. As <a href=\"http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed\">Brewer himself points out</a>, the \"2 out of 3\" interpretation is misleading.</p><p>If you take away just one idea from this discussion, let it be this: \"consistency\" is not a singular, unambiguous property. Remember:</p><p>Instead, a consistency model is a guarantee - any guarantee - that a data store gives to programs that use it.</p><dl><dd>a contract between programmer and system, wherein the system guarantees that if the programmer follows some specific rules, the results of operations on the data store will be predictable</dd></dl><p>The \"C\" in CAP is \"strong consistency\", but \"consistency\" is not a synonym for \"strong consistency\".</p><p>Let's take a look at some alternative consistency models.</p><h2>Strong consistency vs. other consistency models</h2><p>Consistency models can be categorized into two types: strong and weak consistency models:</p><ul><li>Strong consistency models (capable of maintaining a single copy)<ul></ul></li><li>Weak consistency models (not strong)<ul><li>Client-centric consistency models</li><li>Causal consistency: strongest model available</li><li>Eventual consistency models</li></ul></li></ul><p>Strong consistency models guarantee that the apparent order and visibility of updates is equivalent to a non-replicated system. Weak consistency models, on the other hand, do not make such guarantees.</p><p>Note that this is by no means an exhaustive list. Again, consistency models are just arbitrary contracts between the programmer and system, so they can be almost anything.</p><h3>Strong consistency models</h3><p>Strong consistency models can further be divided into two similar, but slightly different consistency models:</p><ul><li>: Under linearizable consistency, all operations  to have executed atomically in an order that is consistent with the global real-time ordering of operations. (Herlihy &amp; Wing, 1991)</li><li>: Under sequential consistency, all operations  to have executed atomically in some order that is consistent with the order seen at individual nodes and that is equal at all nodes. (Lamport, 1979)</li></ul><p>The key difference is that linearizable consistency requires that the order in which operations take effect is equal to the actual real-time ordering of operations. Sequential consistency allows for operations to be reordered as long as the order observed on each node remains consistent. The only way someone can distinguish between the two is if they can observe all the inputs and timings going into the system; from the perspective of a client interacting with a node, the two are equivalent.</p><p>The difference seems immaterial, but it is worth noting that sequential consistency does not compose.</p><p>Strong consistency models allow you as a programmer to replace a single server with a cluster of distributed nodes and not run into any problems.</p><p>All the other consistency models have anomalies (compared to a system that guarantees strong consistency), because they behave in a way that is distinguishable from a non-replicated system. But often these anomalies are acceptable, either because we don't care about occasional issues or because we've written code that deals with inconsistencies after they have occurred in some way.</p><p>Note that there really aren't any universal typologies for weak consistency models, because \"not a strong consistency model\" (e.g. \"is distinguishable from a non-replicated system in some way\") can be almost anything.</p><h3>Client-centric consistency models</h3><p><em>Client-centric consistency models</em> are consistency models that involve the notion of a client or session in some way. For example, a client-centric consistency model might guarantee that a client will never see older versions of a data item. This is often implemented by building additional caching into the client library, so that if a client moves to a replica node that contains old data, then the client library returns its cached value rather than the old value from the replica.</p><p>Clients may still see older versions of the data, if the replica node they are on does not contain the latest version, but they will never see anomalies where an older version of a value resurfaces (e.g. because they connected to a different replica). Note that there are many kinds of consistency models that are client-centric.</p><p>The  model says that if you stop changing values, then after some undefined amount of time all replicas will agree on the same value. It is implied that before that time results between replicas are inconsistent in some undefined manner. Since it is <a href=\"http://www.bailis.org/blog/safety-and-liveness-eventual-consistency-is-not-safe/\">trivially satisfiable</a> (liveness property only), it is useless without supplemental information.</p><p>Saying something is merely eventually consistent is like saying \"people are eventually dead\". It's a very weak constraint, and we'd probably want to have at least some more specific characterization of two things:</p><p>First, how long is \"eventually\"? It would be useful to have a strict lower bound, or at least some idea of how long it typically takes for the system to converge to the same value.</p><p>Second, how do the replicas agree on a value? A system that always returns \"42\" is eventually consistent: all replicas agree on the same value. It just doesn't converge to a useful value since it just keeps returning the same fixed value. Instead, we'd like to have a better idea of the method. For example, one way to decide is to have the value with the largest timestamp always win.</p><p>So when vendors say \"eventual consistency\", what they mean is some more precise term, such as \"eventually last-writer-wins, and read-the-latest-observed-value in the meantime\" consistency. The \"how?\" matters, because a bad method can lead to writes being lost - for example, if the clock on one node is set incorrectly and timestamps are used.</p><p>I will look into these two questions in more detail in the chapter on replication methods for weak consistency models.</p><p>What is order and why is it important?</p><p>What do you mean \"what is order\"?</p><p>I mean, why are we so obsessed with order in the first place? Why do we care whether A happened before B? Why don't we care about some other property, like \"color\"?</p><p>Well, my crazy friend, let's go back to the definition of distributed systems to answer that.</p><p>As you may remember, I described distributed programming as the art of solving the same problem that you can solve on a single computer using multiple computers.</p><p>This is, in fact, at the core of the obsession with order. Any system that can only do one thing at a time will create a total order of operations. Like people passing through a single door, every operation will have a well-defined predecessor and successor. That's basically the programming model that we've worked very hard to preserve.</p><p>The traditional model is: a single program, one process, one memory space running on one CPU. The operating system abstracts away the fact that there might be multiple CPUs and multiple programs, and that the memory on the computer is actually shared among many programs. I'm not saying that threaded programming and event-oriented programming don't exist; it's just that they are special abstractions on top of the \"one/one/one\" model. Programs are written to be executed in an ordered fashion: you start from the top, and then go down towards the bottom.</p><p>Order as a property has received so much attention because the easiest way to define \"correctness\" is to say \"it works like it would on a single machine\". And that usually means that a) we run the same operations and b) that we run them in the same order - even if there are multiple machines.</p><p>The nice thing about distributed systems that preserve order (as defined for a single system) is that they are generic. You don't need to care about what the operations are, because they will be executed exactly like on a single machine. This is great because you know that you can use the same system no matter what the operations are.</p><p>In reality, a distributed program runs on multiple nodes; with multiple CPUs and multiple streams of operations coming in. You can still assign a total order, but it requires either accurate clocks or some form of communication. You could timestamp each operation using a completely accurate clock then use that to figure out the total order. Or you might have some kind of communication system that makes it possible to assign sequential numbers as in a total order.</p><p>The natural state in a distributed system is <a href=\"https://en.wikipedia.org/wiki/Partially_ordered_set\">partial order</a>. Neither the network nor independent nodes make any guarantees about relative order; but at each node, you can observe a local order.</p><p>A <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a> is a binary relation that defines an order for every element in some set.</p><p>Two distinct elements are  when one of them is greater than the other. In a partially ordered set, some pairs of elements are not comparable and hence a partial order doesn't specify the exact order of every item.</p><p>Both total order and partial order are <a href=\"https://en.wikipedia.org/wiki/Transitive_relation\">transitive</a> and <a href=\"https://en.wikipedia.org/wiki/Antisymmetric_relation\">antisymmetric</a>. The following statements hold in both a total order and a partial order for all a, b and c in X:</p><pre>If a ‚â§ b and b ‚â§ a then a = b (antisymmetry);\nIf a ‚â§ b and b ‚â§ c then a ‚â§ c (transitivity);</pre><p>However, a total order is <a href=\"https://en.wikipedia.org/wiki/Total_relation\">total</a>:</p><pre>a ‚â§ b or b ‚â§ a (totality) for all a, b in X</pre><pre>a ‚â§ a (reflexivity) for all a in X</pre><p>Note that totality implies reflexivity; so a partial order is a weaker variant of total order.\nFor some elements in a partial order, the totality property does not hold - in other words, some of the elements are not comparable.</p><p>Git branches are an example of a partial order. As you probably know, the git revision control system allows you to create multiple branches from a single base branch - e.g. from a master branch. Each branch represents a history of source code changes derived based on a common ancestor:</p><pre>[ branch A (1,2,0)]  [ master (3,0,0) ]  [ branch B (1,0,2) ]\n[ branch A (1,1,0)]  [ master (2,0,0) ]  [ branch B (1,0,1) ]\n                  \\  [ master (1,0,0) ]  /</pre><p>The branches A and B were derived from a common ancestor, but there is no definite order between them: they represent different histories and cannot be reduced to a single linear history without additional work (merging). You could, of course, put all the commits in some arbitrary order (say, sorting them first by ancestry and then breaking ties by sorting A before B or B before A) - but that would lose information by forcing a total order where none existed.</p><p>In a system consisting of one node, a total order emerges by necessity: instructions are executed and messages are processed in a specific, observable order in a single program. We've come to rely on this total order - it makes executions of programs predictable. This order can be maintained on a distributed system, but at a cost: communication is expensive, and time synchronization is difficult and fragile.</p><p>Time is a source of order - it allows us to define the order of operations - which coincidentally also has an interpretation that people can understand (a second, a minute, a day and so on).</p><p>In some sense, time is just like any other integer counter. It just happens to be important enough that most computers have a dedicated time sensor, also known as a clock. It's so important that we've figured out how to synthesize an approximation of the same counter using some imperfect physical system (from wax candles to cesium atoms). By \"synthesize\", I mean that we can approximate the value of the integer counter in physically distant places via some physical property without communicating it directly.</p><p>Timestamps really are a shorthand value for representing the state of the world from the start of the universe to the current moment - if something occurred at a particular timestamp, then it was potentially influenced by everything that happened before it. This idea can be generalized into a causal clock that explicitly tracks causes (dependencies) rather than simply assuming that everything that preceded a timestamp was relevant. Of course, the usual assumption is that we should only worry about the state of the specific system rather than the whole world.</p><p>Assuming that time progresses at the same rate everywhere - and that is a big assumption which I'll return to in a moment - time and timestamps have several useful interpretations when used in a program. The three interpretations are:</p><ul></ul><p>. When I say that time is a source of order, what I mean is that:</p><ul><li>we can attach timestamps to unordered events to order them</li><li>we can use timestamps to enforce a specific ordering of operations or the delivery of messages (for example, by delaying an operation if it arrives out of order)</li><li>we can use the value of a timestamp to determine whether something happened chronologically before something else</li></ul><p> - time as a universally comparable value. The absolute value of a timestamp can be interpreted as a date, which is useful for people. Given a timestamp of when a downtime started from a log file, you can tell that it was last Saturday, when there was a <a href=\"https://twitter.com/AWSFail/statuses/218915147060752384\">thunderstorm</a>.</p><p> - durations measured in time have some relation to the real world. Algorithms generally don't care about the absolute value of a clock or its interpretation as a date, but they might use durations to make some judgment calls. In particular, the amount of time spent waiting can provide clues about whether a system is partitioned or merely experiencing high latency.</p><p>By their nature, the components of distributed systems do not behave in a predictable manner. They do not guarantee any specific order, rate of advance, or lack of delay. Each node does have some local order - as execution is (roughly) sequential - but these local orders are independent of each other.</p><p>Imposing (or assuming) order is one way to reduce the space of possible executions and possible occurrences. Humans have a hard time reasoning about things when things can happen in any order - there just are too many permutations to consider.</p><h2>Does time progress at the same rate everywhere?</h2><p>We all have an intuitive concept of time based on our own experience as individuals. Unfortunately, that intuitive notion of time makes it easier to picture total order rather than partial order. It's easier to picture a sequence in which things happen one after another, rather than concurrently. It is easier to reason about a single order of messages than to reason about messages arriving in different orders and with different delays.</p><p>However, when implementing distributing systems we want to avoid making strong assumptions about time and order, because the stronger the assumptions, the more fragile a system is to issues with the \"time sensor\" - or the onboard clock. Furthermore, imposing an order carries a cost. The more temporal nondeterminism that we can tolerate, the more we can take advantage of distributed computation.</p><p>There are three common answers to the question \"does time progress at the same rate everywhere?\". These are:</p><ul></ul><p>These correspond roughly to the three timing assumptions that I mentioned in the second chapter: the synchronous system model has a global clock, the partially synchronous model has a local clock, and in the asynchronous system model one cannot use clocks at all. Let's look at these in more detail.</p><h3>Time with a \"global-clock\" assumption</h3><p>The global clock assumption is that there is a global clock of perfect accuracy, and that everyone has access to that clock. This is the way we tend to think about time, because in human interactions small differences in time don't really matter.</p><p>The global clock is basically a source of total order (exact order of every operation on all nodes even if those nodes have never communicated).</p><p>However, this is an idealized view of the world: in reality, clock synchronization is only possible to a limited degree of accuracy. This is limited by the lack of accuracy of clocks in commodity computers, by latency if a clock synchronization protocol such as <a href=\"https://en.wikipedia.org/wiki/Network_Time_Protocol\">NTP</a> is used and fundamentally by <a href=\"https://en.wikipedia.org/wiki/Time_dilation\">the nature of spacetime</a>.</p><p>Assuming that clocks on distributed nodes are perfectly synchronized means assuming that clocks start at the same value and never drift apart. It's a nice assumption because you can use timestamps freely to determine a global total order - bound by clock drift rather than latency - but this is a <a href=\"http://queue.acm.org/detail.cfm?id=1773943\">nontrivial</a> operational challenge and a potential source of anomalies. There are many different scenarios where a simple failure - such as a user accidentally changing the local time on a machine, or an out-of-date machine joining a cluster, or synchronized clocks drifting at slightly different rates and so on that can cause hard-to-trace anomalies.</p><p>Nevertheless, there are some real-world systems that make this assumption. Facebook's <a href=\"https://en.wikipedia.org/wiki/Apache_Cassandra\">Cassandra</a> is an example of a system that assumes clocks are synchronized. It uses timestamps to resolve conflicts between writes - the write with the newer timestamp wins. This means that if clocks drift, new data may be ignored or overwritten by old data; again, this is an operational challenge (and from what I've heard, one that people are acutely aware of). Another interesting example is Google's <a href=\"https://research.google.com/archive/spanner.html\">Spanner</a>: the paper describes their TrueTime API, which synchronizes time but also estimates worst-case clock drift.</p><h3>Time with a \"Local-clock\" assumption</h3><p>The second, and perhaps more plausible assumption is that each machine has its own clock, but there is no global clock. It means that you cannot use the local clock in order to determine whether a remote timestamp occurred before or after a local timestamp; in other words, you cannot meaningfully compare timestamps from two different machines.</p><p>The local clock assumption corresponds more closely to the real world. It assigns a partial order: events on each system are ordered but events cannot be ordered across systems by only using a clock.</p><p>However, you can use timestamps to order events on a single machine; and you can use timeouts on a single machine as long as you are careful not to allow the clock to jump around. Of course, on a machine controlled by an end-user this is probably assuming too much: for example, a user might accidentally change their date to a different value while looking up a date using the operating system's date control.</p><h3>Time with a \"No-clock\" assumption</h3><p>Finally, there is the notion of logical time. Here, we don't use clocks at all and instead track causality in some other way. Remember, a timestamp is simply a shorthand for the state of the world up to that point - so we can use counters and communication to determine whether something happened before, after or concurrently with something else.</p><p>This way, we can determine the order of events between different machines, but cannot say anything about intervals and cannot use timeouts (since we assume that there is no \"time sensor\"). This is a partial order: events can be ordered on a single system using a counter and no communication, but ordering events across systems requires a message exchange.</p><p>One of the most cited papers in distributed systems is Lamport's paper on <a href=\"http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf\">time, clocks and the ordering of events</a>. Vector clocks, a generalization of that concept (which I will cover in more detail), are a way to track causality without using clocks. Cassandra's cousins Riak (Basho) and Voldemort (Linkedin) use vector clocks rather than assuming that nodes have access to a global clock of perfect accuracy. This allows those systems to avoid the clock accuracy issues mentioned earlier.</p><p>When clocks are not used, the maximum precision at which events can be ordered across distant machines is bound by communication latency.</p><h2>How is time used in a distributed system?</h2><p>What is the benefit of time?</p><ol><li>Time can define order across a system (without communication)</li><li>Time can define boundary conditions for algorithms</li></ol><p>The order of events is important in distributed systems, because many properties of distributed systems are defined in terms of the order of operations/events:</p><ul><li>where correctness depends on (agreement on) correct event ordering, for example serializability in a distributed database</li><li>order can be used as a tie breaker when resource contention occurs, for example if there are two orders for a widget, fulfill the first and cancel the second one</li></ul><p>A global clock would allow operations on two different machines to be ordered without the two machines communicating directly. Without a global clock, we need to communicate in order to determine order.</p><p>Time can also be used to define boundary conditions for algorithms - specifically, to distinguish between \"high latency\" and \"server or network link is down\". This is a very important use case; in most real-world systems timeouts are used to determine whether a remote machine has failed, or whether it is simply experiencing high network latency. Algorithms that make this determination are called failure detectors; and I will discuss them fairly soon.</p><h2>Vector clocks (time for causal order)</h2><p>Earlier, we discussed the different assumptions about the rate of progress of time across a distributed system. Assuming that we cannot achieve accurate clock synchronization - or starting with the goal that our system should not be sensitive to issues with time synchronization, how can we order things?</p><p>Lamport clocks and vector clocks are replacements for physical clocks which rely on counters and communication to determine the order of events across a distributed system. These clocks provide a counter that is comparable across different nodes.</p><p> is simple. Each process maintains a counter using the following rules:</p><ul><li>Whenever a process does work, increment the counter</li><li>Whenever a process sends a message, include the counter</li><li>When a message is received, set the counter to <code>max(local_counter, received_counter) + 1</code></li></ul><pre>function LamportClock() {\n  this.value = 1;\n}\n\nLamportClock.prototype.get = function() {\n  return this.value;\n}\n\nLamportClock.prototype.increment = function() {\n  this.value++;\n}\n\nLamportClock.prototype.merge = function(other) {\n  this.value = Math.max(this.value, other.value) + 1;\n}</pre><p>A <a href=\"https://en.wikipedia.org/wiki/Lamport_timestamps\">Lamport clock</a> allows counters to be compared across systems, with a caveat: Lamport clocks define a partial order. If <code>timestamp(a) &lt; timestamp(b)</code>:</p><ul><li> may have happened before  or</li><li> may be incomparable with </li></ul><p>This is known as clock consistency condition: if one event comes before another, then that event's logical clock comes before the others. If  and  are from the same causal history, e.g. either both timestamp values were produced on the same process; or  is a response to the message sent in  then we know that  happened before .</p><p>Intuitively, this is because a Lamport clock can only carry information about one timeline / history; hence, comparing Lamport timestamps from systems that never communicate with each other may cause concurrent events to appear to be ordered when they are not.</p><p>Imagine a system that after an initial period divides into two independent subsystems which never communicate with each other.</p><p>For all events in each independent system, if a happened before b, then ; but if you take two events from the different independent systems (e.g. events that are not causally related) then you cannot say anything meaningful about their relative order.  While each part of the system has assigned timestamps to events, those timestamps have no relation to each other. Two events may appear to be ordered even though they are unrelated.</p><p>However - and this is still a useful property - from the perspective of a single machine, any message sent with  will receive a response with  which is .</p><p> is an extension of Lamport clock, which maintains an array  of N logical clocks - one per each node. Rather than incrementing a common counter, each node increments its own logical clock in the vector by one on each internal event. Hence the update rules are:</p><ul><li>Whenever a process does work, increment the logical clock value of the node in the vector</li><li>Whenever a process sends a message, include the full vector of logical clocks</li><li>When a message is received:<ul><li>update each element in the vector to be </li><li>increment the logical clock value representing the current node in the vector</li></ul></li></ul><p>Again, expressed as code:</p><pre>function VectorClock(value) {\n  // expressed as a hash keyed by node id: e.g. { node1: 1, node2: 3 }\n  this.value = value || {};\n}\n\nVectorClock.prototype.get = function() {\n  return this.value;\n};\n\nVectorClock.prototype.increment = function(nodeId) {\n  if(typeof this.value[nodeId] == 'undefined') {\n    this.value[nodeId] = 1;\n  } else {\n    this.value[nodeId]++;\n  }\n};\n\nVectorClock.prototype.merge = function(other) {\n  var result = {}, last,\n      a = this.value,\n      b = other.value;\n  // This filters out duplicate keys in the hash\n  (Object.keys(a)\n    .concat(b))\n    .sort()\n    .filter(function(key) {\n      var isDuplicate = (key == last);\n      last = key;\n      return !isDuplicate;\n    }).forEach(function(key) {\n      result[key] = Math.max(a[key] || 0, b[key] || 0);\n    });\n  this.value = result;\n};</pre><p>This illustration (<a href=\"https://en.wikipedia.org/wiki/Vector_clock\">source</a>) shows a vector clock:</p><p>Each of the three nodes (A, B, C) keeps track of the vector clock. As events occur, they are timestamped with the current value of the vector clock. Examining a vector clock such as  lets us accurately identify the messages that (potentially) influenced that event.</p><p>The issue with vector clocks is mainly that they require one entry per node, which means that they can potentially become very large for large systems. A variety of techniques have been applied to reduce the size of vector clocks (either by performing periodic garbage collection, or by reducing accuracy by limiting the size).</p><p>We've looked at how order and causality can be tracked without physical clocks. Now, let's look at how time durations can be used for cutoff.</p><h2>Failure detectors (time for cutoff)</h2><p>As I stated earlier, the amount of time spent waiting can provide clues about whether a system is partitioned or merely experiencing high latency. In this case, we don't need to assume a global clock of perfect accuracy - it is simply enough that there is a reliable-enough local clock.</p><p>Given a program running on one node, how can it tell that a remote node has failed? In the absence of accurate information, we can infer that an unresponsive remote node has failed after some reasonable amount of time has passed.</p><p>But what is a \"reasonable amount\"? This depends on the latency between the local and remote nodes. Rather than explicitly specifying algorithms with specific values (which would inevitably be wrong in some cases), it would be nicer to deal with a suitable abstraction.</p><p>A failure detector is a way to abstract away the exact timing assumptions. Failure detectors are implemented using heartbeat messages and timers. Processes exchange heartbeat messages. If a message response is not received before the timeout occurs, then the process suspects the other process.</p><p>A failure detector based on a timeout will carry the risk of being either overly aggressive (declaring a node to have failed) or being overly conservative (taking a long time to detect a crash). How accurate do failure detectors need to be for them to be usable?</p><p><a href=\"https://www.google.com/search?q=Unreliable%20Failure%20Detectors%20for%20Reliable%20Distributed%20Systems\">Chandra et al.</a> (1996) discuss failure detectors in the context of solving consensus - a problem that is particularly relevant since it underlies most replication problems where the replicas need to agree in environments with latency and network partitions.</p><p>They characterize failure detectors using two properties, completeness and accuracy:</p><dl><dd>Every crashed process is eventually suspected by every correct process.</dd><dd>Every crashed process is eventually suspected by some correct process.</dd><dd>No correct process is suspected ever.</dd><dd>Some correct process is never suspected.</dd></dl><p>Completeness is easier to achieve than accuracy; indeed, all failure detectors of importance achieve it - all you need to do is not to wait forever to suspect someone. Chandra et al. note that a failure detector with weak completeness can be transformed to one with strong completeness (by broadcasting information about suspected processes), allowing us to concentrate on the spectrum of accuracy properties.</p><p>Avoiding incorrectly suspecting non-faulty processes is hard unless you are able to assume that there is a hard maximum on the message delay. That assumption can be made in a synchronous system model - and hence failure detectors can be strongly accurate in such a system. Under system models that do not impose hard bounds on message delay, failure detection can at best be eventually accurate.</p><p>Chandra et al. show that even a very weak failure detector - the eventually weak failure detector ‚ãÑW (eventually weak accuracy + weak completeness) - can be used to solve the consensus problem. The diagram below (from the paper) illustrates the relationship between system models and problem solvability:</p><p>As you can see above, certain problems are not solvable without a failure detector in asynchronous systems. This is because without a failure detector (or strong assumptions about time bounds e.g. the synchronous system model), it is not possible to tell whether a remote node has crashed, or is simply experiencing high latency. That distinction is important for any system that aims for single-copy consistency: failed nodes can be ignored because they cannot cause divergence, but partitioned nodes cannot be safely ignored.</p><p>How can one implement a failure detector? Conceptually, there isn't much to a simple failure detector, which simply detects failure when a timeout expires. The most interesting part relates to how the judgments are made about whether a remote node has failed.</p><p>Ideally, we'd prefer the failure detector to be able to adjust to changing network conditions and to avoid hardcoding timeout values into it. For example, Cassandra uses an <a href=\"https://www.google.com/search?q=The+Phi+accrual+failure+detector\">accrual failure detector</a>, which is a failure detector that outputs a suspicion level (a value between 0 and 1) rather than a binary \"up\" or \"down\" judgment. This allows the application using the failure detector to make its own decisions about the tradeoff between accurate detection and early detection.</p><p>Earlier, I alluded to having to pay the cost for order. What did I mean?</p><p>If you're writing a distributed system, you presumably own more than one computer. The natural (and realistic) view of the world is a partial order, not a total order. You can transform a partial order into a total order, but this requires communication, waiting and imposes restrictions that limit how many computers can do work at any particular point in time.</p><p>All clocks are mere approximations bound by either network latency (logical time) or by physics. Even keeping a simple integer counter in sync across multiple nodes is a challenge.</p><p>While time and order are often discussed together, time itself is not such a useful property. Algorithms don't really care about time as much as they care about more abstract properties:</p><ul><li>the causal ordering of events</li><li>failure detection (e.g. approximations of upper bounds on message delivery)</li><li>consistent snapshots (e.g. the ability to examine the state of a system at some point in time; not discussed here)</li></ul><p>Imposing a total order is possible, but expensive. It requires you to proceed at the common (lowest) speed. Often the easiest way to ensure that events are delivered in some defined order is to nominate a single (bottleneck) node through which all operations are passed.</p><p>Is time / order / synchronicity really necessary? It depends. In some use cases, we want each intermediate operation to move the system from one consistent state to another. For example, in many cases we want the responses from a database to represent all of the available information, and we want to avoid dealing with the issues that might occur if the system could return an inconsistent result.</p><p>But in other cases, we might not need that much time / order / synchronization. For example, if you are running a long running computation, and don't really care about what the system does until the very end - then you don't really need much synchronization as long as you can guarantee that the answer is correct.</p><p>Synchronization is often applied as a blunt tool across all operations, when only a subset of cases actually matter for the final outcome. When is order needed to guarantee correctness? The CALM theorem - which I will discuss in the last chapter - provides one answer.</p><p>In other cases, it is acceptable to give an answer that only represents the best known estimate - that is, is based on only a subset of the total information contained in the system. In particular, during a network partition one may need to answer queries with only a part of the system being accessible. In other use cases, the end user cannot really distinguish between a relatively recent answer that can be obtained cheaply and one that is guaranteed to be correct and is expensive to calculate. For example, is the Twitter follower count for some user X, or X+1? Or are movies A, B and C the absolutely best answers for some query? Doing a cheaper, mostly correct \"best effort\" can be acceptable.</p><p>In the next two chapters we'll examine replication for fault-tolerant strongly consistent systems - systems which provide strong guarantees while being increasingly resilient to failures. These systems provide solutions for the first case: when you need to guarantee correctness and are willing to pay for it. Then, we'll discuss systems with weak consistency guarantees, which can remain available in the face of partitions, but that can only give you a \"best effort\" answer.</p><h3>Lamport clocks, vector clocks</h3><p>The replication problem is one of many problems in distributed systems. I've chosen to focus on it over other problems such as leader election, failure detection, mutual exclusion, consensus and global snapshots because it is often the part that people are most interested in. One way in which parallel databases are differentiated is in terms of their replication features, for example. Furthermore, replication provides a context for many subproblems, such as leader election, failure detection, consensus and atomic broadcast.</p><p>Replication is a group communication problem. What arrangement and communication pattern gives us the performance and availability characteristics we desire? How can we ensure fault tolerance, durability and non-divergence in the face of network partitions and simultaneous node failure?</p><p>Again, there are many ways to approach replication. The approach I'll take here just looks at high level patterns that are possible for a system with replication. Looking at this visually helps keep the discussion focused on the overall pattern rather than the specific messaging involved. My goal here is to explore the design space rather than to explain the specifics of each algorithm.</p><p>Let's first define what replication looks like. We assume that we have some initial database, and that clients make requests which change the state of the database.</p><p>The arrangement and communication pattern can then be divided into several stages:</p><ol><li>(Request) The client sends a request to a server</li><li>(Sync) The synchronous portion of the replication takes place</li><li>(Response) A response is returned to the client</li><li>(Async) The asynchronous portion of the replication takes place</li></ol><p>This model is loosely based on <a href=\"https://www.google.com/search?q=understanding+replication+in+databases+and+distributed+systems\">this article</a>. Note that the pattern of messages exchanged in each portion of the task depends on the specific algorithm: I am intentionally trying to get by without discussing the specific algorithm.</p><p>Given these stages, what kind of communication patterns can we create? And what are the performance and availability implications of the patterns we choose?</p><p>The first pattern is synchronous replication (also known as active, or eager, or push, or pessimistic replication). Let's draw what that looks like:</p><p>Here, we can see three distinct stages: first, the client sends the request. Next, what we called the synchronous portion of replication takes place. The term refers to the fact that the client is blocked - waiting for a reply from the system.</p><p>During the synchronous phase, the first server contacts the two other servers and waits until it has received replies from all the other servers. Finally, it sends a response to the client informing it of the result (e.g. success or failure).</p><p>All this seems straightforward. What can we say of this specific arrangement of communication patterns, without discussing the details of the algorithm during the synchronous phase? First, observe that this is a write N - of - N approach: before a response is returned, it has to be seen and acknowledged by every server in the system.</p><p>From a performance perspective, this means that the system will be as fast as the slowest server in it. The system will also be very sensitive to changes in network latency, since it requires every server to reply before proceeding.</p><p>Given the N-of-N approach, the system cannot tolerate the loss of any servers. When a server is lost, the system can no longer write to all the nodes, and so it cannot proceed. It might be able to provide read-only access to the data, but modifications are not allowed after a node has failed in this design.</p><p>This arrangement can provide very strong durability guarantees: the client can be certain that all N servers have received, stored and acknowledged the request when the response is returned. In order to lose an accepted update, all N copies would need to be lost, which is about as good a guarantee as you can make.</p><p>Let's contrast this with the second pattern - asynchronous replication (a.k.a. passive replication, or pull replication, or lazy replication). As you may have guessed, this is the opposite of synchronous replication:</p><p>Here, the master (/leader / coordinator) immediately sends back a response to the client. It might at best store the update locally, but it will not do any significant work synchronously and the client is not forced to wait for more rounds of communication to occur between the servers.</p><p>At some later stage, the asynchronous portion of the replication task takes place. Here, the master contacts the other servers using some communication pattern, and the other servers update their copies of the data. The specifics depend on the algorithm in use.</p><p>What can we say of this specific arrangement without getting into the details of the algorithm? Well, this is a write 1 - of - N approach: a response is returned immediately and update propagation occurs sometime later.</p><p>From a performance perspective, this means that the system is fast: the client does not need to spend any additional time waiting for the internals of the system to do their work. The system is also more tolerant of network latency, since fluctuations in internal latency do not cause additional waiting on the client side.</p><p>This arrangement can only provide weak, or probabilistic durability guarantees. If nothing goes wrong, the data is eventually replicated to all N machines. However, if the only server containing the data is lost before this can take place, the data is permanently lost.</p><p>Given the 1-of-N approach, the system can remain available as long as at least one node is up (at least in theory, though in practice the load will probably be too high). A purely lazy approach like this provides no durability or consistency guarantees; you may be allowed to write to the system, but there are no guarantees that you can read back what you wrote if any faults occur.</p><p>Finally, it's worth noting that passive replication cannot ensure that all nodes in the system always contain the same state. If you accept writes at multiple locations and do not require that those nodes synchronously agree, then you will run the risk of divergence: reads may return different results from different locations (particularly after nodes fail and recover), and global constraints (which require communicating with everyone) cannot be enforced.</p><p>I haven't really mentioned the communication patterns during a read (rather than a write), because the pattern of reads really follows from the pattern of writes: during a read, you want to contact as few nodes as possible. We'll discuss this a bit more in the context of quorums.</p><p>We've only discussed two basic arrangements and none of the specific algorithms. Yet we've been able to figure out quite a bit of about the possible communication patterns as well as their performance, durability guarantees and availability characteristics.</p><h2>An overview of major replication approaches</h2><p>Having discussed the two basic replication approaches: synchronous and asynchronous replication, let's have a look at the major replication algorithms.</p><p>There are many, many different ways to categorize replication techniques. The second distinction (after sync vs. async) I'd like to introduce is between:</p><ul><li>Replication methods that prevent divergence (single copy systems) and</li><li>Replication methods that risk divergence (multi-master systems)</li></ul><p>The first group of methods has the property that they \"behave like a single system\". In particular, when partial failures occur, the system ensures that only a single copy of the system is active. Furthermore, the system ensures that the replicas are always in agreement. This is known as the consensus problem.</p><p>Several processes (or computers) achieve consensus if they all agree on some value. More formally:</p><ol><li>Agreement: Every correct process must agree on the same value.</li><li>Integrity: Every correct process decides at most one value, and if it decides some value, then it must have been proposed by some process.</li><li>Termination: All processes eventually reach a decision.</li><li>Validity: If all correct processes propose the same value V, then all correct processes decide V.</li></ol><p>Mutual exclusion, leader election, multicast and atomic broadcast are all instances of the more general problem of consensus. Replicated systems that maintain single copy consistency need to solve the consensus problem in some way.</p><p>The replication algorithms that maintain single-copy consistency include:</p><ul><li>1n messages (asynchronous primary/backup)</li><li>2n messages (synchronous primary/backup)</li><li>4n messages (2-phase commit, Multi-Paxos)</li><li>6n messages (3-phase commit, Paxos with repeated leader election)</li></ul><p>These algorithms vary in their fault tolerance (e.g. the types of faults they can tolerate). I've classified these simply by the number of messages exchanged during an execution of the algorithm, because I think it is interesting to try to find an answer to the question \"what are we buying with the added message exchanges?\"</p><p>The diagram below, adapted from Ryan Barret at <a href=\"https://www.google.com/events/io/2009/sessions/TransactionsAcrossDatacenters.html\">Google</a>, describes some of the aspects of the different options:</p><p>The consistency, latency, throughput, data loss and failover characteristics in the diagram above can really be traced back to the two different replication methods: synchronous replication (e.g. waiting before responding) and asynchronous replication. When you wait, you get worse performance but stronger guarantees. The throughput difference between 2PC and quorum systems will become apparent when we discuss partition (and latency) tolerance.</p><p>In that diagram, algorithms enforcing weak (/eventual) consistency are lumped up into one category (\"gossip\"). However, I will discuss replication methods for weak consistency - gossip and (partial) quorum systems - in more detail. The \"transactions\" row really refers more to global predicate evaluation, which is not supported in systems with weak consistency (though local predicate evaluation can be supported).</p><p>It is worth noting that systems enforcing weak consistency requirements have fewer generic algorithms, and more techniques that can be selectively applied. Since systems that do not enforce single-copy consistency are free to act like distributed systems consisting of multiple nodes, there are fewer obvious objectives to fix and the focus is more on giving people a way to reason about the characteristics of the system that they have.</p><ul><li>Client-centric consistency models attempt to provide more intelligible consistency guarantees while allowing for divergence.</li><li>CRDTs (convergent and commutative replicated datatypes) exploit semilattice properties (associativity, commutativity, idempotency) of certain state and operation-based data types.</li><li>Confluence analysis (as in the Bloom language) uses information regarding the monotonicity of computations to maximally exploit disorder.</li><li>PBS (probabilistically bounded staleness) uses simulation and information collected from a real world system to characterize the expected behavior of partial quorum systems.</li></ul><p>I'll talk about all of these a bit  further on, first; let's look at the replication algorithms that maintain single-copy consistency.</p><h2>Primary/backup replication</h2><p>Primary/backup replication (also known as primary copy replication master-slave replication or log shipping) is perhaps the most commonly used replication method, and the most basic algorithm. All updated are performed on the primary, and a log of operations (or alternatively, changes) is shipped across the network to the backup replicas. There are two variants:</p><ul><li>asynchronous primary/backup replication and</li><li>synchronous primary/backup replication</li></ul><p>The synchronous version requires two messages (\"update\" + \"acknowledge receipt\") while the asynchronous version could run with just one (\"update\").</p><p>P/B is very common. For example, by default MySQL replication uses the asynchronous variant. MongoDB also uses P/B (with some additional procedures for failover). All operations are performed on one master server, which serializes them to a local log, which is then replicated asynchronously to the backup servers.</p><p>As we discussed earlier in the context of asynchronous replication, any asynchronous replication algorithm can only provide weak durability guarantees. In MySQL replication this manifests as replication lag: the asynchronous backups are always at least one operation behind the primary. If the primary fails, then the updates that have not yet been sent to the backups are lost.</p><p>The synchronous variant of primary/backup replication ensures that writes have been stored on other nodes before returning back to the client - at the cost of waiting for responses from other replicas. However, it is worth noting that even this variant can only offer weak guarantees. Consider the following simple failure scenario:</p><ul><li>the primary receives a write and sends it to the backup</li><li>the backup persists and ACKs the write</li><li>and then primary fails before sending ACK to the client</li></ul><p>The client now assumes that the commit failed, but the backup committed it; if the backup is promoted to primary, it will be incorrect. Manual cleanup may be needed to reconcile the failed primary or divergent backups.</p><p>I am simplifying here of course. While all primary/backup replication algorithms follow the same general messaging pattern, they differ in their handling of failover, replicas being offline for extended periods and so on. However, it is not possible to be resilient to inopportune failures of the primary in this scheme.</p><p>What is key in the log-shipping / primary/backup based schemes is that they can only offer a best-effort guarantee (e.g. they are susceptible to lost updates or incorrect updates if nodes fail at inopportune times). Furthermore, P/B schemes are susceptible to split-brain, where the failover to a backup kicks in due to a temporary network issue and causes both the primary and backup to be active at the same time.</p><p>To prevent inopportune failures from causing consistency guarantees to be violated; we need to add another round of messaging, which gets us the two phase commit protocol (2PC).</p><p><a href=\"https://en.wikipedia.org/wiki/Two-phase_commit_protocol\">Two phase commit</a> (2PC) is a protocol used in many classic relational databases. For example, MySQL Cluster (not to be confused with the regular MySQL) provides synchronous replication using 2PC. The diagram below illustrates the message flow:</p><pre>[ Coordinator ] -&gt; OK to commit?     [ Peers ]\n                &lt;- Yes / No\n\n[ Coordinator ] -&gt; Commit / Rollback [ Peers ]\n                &lt;- ACK</pre><p>In the first phase (voting), the coordinator sends the update to all the participants. Each participant processes the update and votes whether to commit or abort. When voting to commit, the participants store the update onto a temporary area (the write-ahead log). Until the second phase completes, the update is considered temporary.</p><p>In the second phase (decision), the coordinator decides the outcome and informs every participant about it. If all participants voted to commit, then the update is taken from the temporary area and made permanent.</p><p>Having a second phase in place before the commit is considered permanent is useful, because it allows the system to roll back an update when a node fails. In contrast, in primary/backup (\"1PC\"), there is no step for rolling back an operation that has failed on some nodes and succeeded on others, and hence the replicas could diverge.</p><p>2PC is prone to blocking, since a single node failure (participant or coordinator) blocks progress until the node has recovered. Recovery is often possible thanks to the second phase, during which other nodes are informed about the system state. Note that 2PC assumes that the data in stable storage at each node is never lost and that no node crashes forever. Data loss is still possible if the data in the stable storage is corrupted in a crash.</p><p>The details of the recovery procedures during node failures are quite complicated so I won't get into the specifics. The major tasks are ensuring that writes to disk are durable (e.g. flushed to disk rather than cached) and making sure that the right recovery decisions are made (e.g. learning the outcome of the round and then redoing or undoing an update locally).</p><p>As we learned in the chapter regarding CAP, 2PC is a CA - it is not partition tolerant. The failure model that 2PC addresses does not include network partitions; the prescribed way to recover from a node failure is to wait until the network partition heals. There is no safe way to promote a new coordinator if one fails; rather a manual intervention is required. 2PC is also fairly latency-sensitive, since it is a write N-of-N approach in which writes cannot proceed until the slowest node acknowledges them.</p><p>2PC strikes a decent balance between performance and fault tolerance, which is why it has been popular in relational databases. However, newer systems often use a partition tolerant consensus algorithm, since such an algorithm can provide automatic recovery from temporary network partitions as well as more graceful handling of increased between-node latency.</p><p>Let's look at partition tolerant consensus algorithms next.</p><h2>Partition tolerant consensus algorithms</h2><p>Partition tolerant consensus algorithms are as far as we're going to go in terms of fault-tolerant algorithms that maintain single-copy consistency. There is a further class of fault tolerant algorithms: algorithms that tolerate <a href=\"https://en.wikipedia.org/wiki/Byzantine_fault_tolerance\">arbitrary (Byzantine) faults</a>; these include nodes that fail by acting maliciously. Such algorithms are rarely used in commercial systems, because they are more expensive to run and more complicated to implement - and hence I will leave them out.</p><p>When it comes to partition tolerant consensus algorithms, the most well-known algorithm is the Paxos algorithm. It is, however, notoriously difficult to implement and explain, so I will focus on Raft, a recent (~early 2013) algorithm designed to be easier to teach and implement. Let's first take a look at network partitions and the general characteristics of partition tolerant consensus algorithms.</p><h3>What is a network partition?</h3><p>A network partition is the failure of a network link to one or several nodes. The nodes themselves continue to stay active, and they may even be able to receive requests from clients on their side of the network partition. As we learned earlier - during the discussion of the CAP theorem - network partitions do occur and not all systems handle them gracefully.</p><p>Network partitions are tricky because during a network partition, it is not possible to distinguish between a failed remote node and the node being unreachable. If a network partition occurs but no nodes fail, then the system is divided into two partitions which are simultaneously active. The two diagrams below illustrate how a network partition can look similar to a node failure.</p><p>A system of 2 nodes, with a failure vs. a network partition:</p><p>A system of 3 nodes, with a failure vs. a network partition:</p><p>A system that enforces single-copy consistency must have some method to break symmetry: otherwise, it will split into two separate systems, which can diverge from each other and can no longer maintain the illusion of a single copy.</p><p>Network partition tolerance for systems that enforce single-copy consistency requires that during a network partition, only one partition of the system remains active since during a network partition it is not possible to prevent divergence (e.g. CAP theorem).</p><p>This is why partition tolerant consensus algorithms rely on a majority vote. Requiring a majority of nodes - rather than all of the nodes (as in 2PC) - to agree on updates allows a minority of the nodes to be down, or slow, or unreachable due to a network partition. As long as  nodes are up and accessible, the system can continue to operate.</p><p>Partition tolerant consensus algorithms use an odd number of nodes (e.g. 3, 5 or 7). With just two nodes, it is not possible to have a clear majority after a failure. For example, if the number of nodes is three, then the system is resilient to one node failure; with five nodes the system is resilient to two node failures.</p><p>When a network partition occurs, the partitions behave asymmetrically. One partition will contain the majority of the nodes. Minority partitions will stop processing operations to prevent divergence during a network partition, but the majority partition can remain active. This ensures that only a single copy of the system state remains active.</p><p>Majorities are also useful because they can tolerate disagreement: if there is a perturbation or failure, the nodes may vote differently. However, since there can be only one majority decision, a temporary disagreement can at most block the protocol from proceeding (giving up liveness) but it cannot violate the single-copy consistency criterion (safety property).</p><p>There are two ways one might structure a system: all nodes may have the same responsibilities, or nodes may have separate, distinct roles.</p><p>Consensus algorithms for replication generally opt for having distinct roles for each node. Having a single fixed leader or master server is an optimization that makes the system more efficient, since we know that all updates must pass through that server. Nodes that are not the leader just need to forward their requests to the leader.</p><p>Note that having distinct roles does not preclude the system from recovering from the failure of the leader (or any other role). Just because roles are fixed during normal operation doesn't mean that one cannot recover from failure by reassigning the roles after a failure (e.g. via a leader election phase). Nodes can reuse the result of a leader election until node failures and/or network partitions occur.</p><p>Both Paxos and Raft make use of distinct node roles. In particular, they have a leader node (\"proposer\" in Paxos) that is responsible for coordination during normal operation. During normal operation, the rest of the nodes are followers (\"acceptors\" or \"voters\" in Paxos).</p><p>Each period of normal operation in both Paxos and Raft is called an epoch (\"term\" in Raft). During each epoch only one node is the designated leader (a similar system is <a href=\"https://en.wikipedia.org/wiki/Japanese_era_name\">used in Japan</a> where era names change upon imperial succession).</p><p>After a successful election, the same leader coordinates until the end of the epoch. As shown in the diagram above (from the Raft paper), some elections may fail, causing the epoch to end immediately.</p><p>Epochs act as a logical clock, allowing other nodes to identify when an outdated node starts communicating - nodes that were partitioned or out of operation will have a smaller epoch number than the current one, and their commands are ignored.</p><p>During normal operation, a partition-tolerant consensus algorithm is rather simple. As we've seen earlier, if we didn't care about fault tolerance, we could just use 2PC. Most of the complexity really arises from ensuring that once a consensus decision has been made, it will not be lost and the protocol can handle leader changes as a result of a network or node failure.</p><p>All nodes start as followers; one node is elected to be a leader at the start. During normal operation, the leader maintains a heartbeat which allows the followers to detect if the leader fails or becomes partitioned.</p><p>When a node detects that a leader has become non-responsive (or, in the initial case, that no leader exists), it switches to an intermediate state (called \"candidate\" in Raft) where it increments the term/epoch value by one, initiates a leader election and competes to become the new leader.</p><p>In order to be elected a leader, a node must receive a majority of the votes. One way to assign votes is to simply assign them on a first-come-first-served basis; this way, a leader will eventually be elected. Adding a random amount of waiting time between attempts at getting elected will reduce the number of nodes that are simultaneously attempting to get elected.</p><h3>Numbered proposals within an epoch</h3><p>During each epoch, the leader proposes one value at a time to be voted upon. Within each epoch, each proposal is numbered with a unique strictly increasing number. The followers (voters / acceptors) accept the first proposal they receive for a particular proposal number.</p><p>During normal operation, all proposals go through the leader node. When a client submits a proposal (e.g. an update operation), the leader contacts all nodes in the quorum. If no competing proposals exist (based on the responses from the followers), the leader proposes the value. If a majority of the followers accept the value, then the value is considered to be accepted.</p><p>Since it is possible that another node is also attempting to act as a leader, we need to ensure that once a single proposal has been accepted, its value can never change. Otherwise a proposal that has already been accepted might for example be reverted by a competing leader. Lamport states this as:</p><blockquote><p>P2: If a proposal with value  is chosen, then every higher-numbered proposal that is chosen has value .</p></blockquote><p>Ensuring that this property holds requires that both followers and proposers are constrained by the algorithm from ever changing a value that has been accepted by a majority. Note that \"the value can never change\" refers to the value of a single execution (or run / instance / decision) of the protocol. A typical replication algorithm will run multiple executions of the algorithm, but most discussions of the algorithm focus on a single run to keep things simple. We want to prevent the decision history from being altered or overwritten.</p><p>In order to enforce this property, the proposers must first ask the followers for their (highest numbered) accepted proposal and value. If the proposer finds out that a proposal already exists, then it must simply complete this execution of the protocol, rather than making its own proposal. Lamport states this as:</p><blockquote><p>P2b. If a proposal with value  is chosen, then every higher-numbered proposal issued by any proposer has value .</p></blockquote><blockquote><p>P2c. For any  and , if a proposal with value  and number  is issued [by a leader], then there is a set  consisting of a majority of acceptors [followers] such that either (a) no acceptor in  has accepted any proposal numbered less than , or (b)  is the value of the highest-numbered proposal among all proposals numbered less than  accepted by the followers in .</p></blockquote><p>This is the core of the Paxos algorithm, as well as algorithms derived from it. The value to be proposed is not chosen until the second phase of the protocol. Proposers must sometimes simply retransmit a previously made decision to ensure safety (e.g. clause b in P2c) until they reach a point where they know that they are free to impose their own proposal value (e.g. clause a).</p><p>If multiple previous proposals exist, then the highest-numbered proposal value is proposed. Proposers may only attempt to impose their own value if there are no competing proposals at all.</p><p>To ensure that no competing proposals emerge between the time the proposer asks each acceptor about its most recent value, the proposer asks the followers not to accept proposals with lower proposal numbers than the current one.</p><p>Putting the pieces together, reaching a decision using Paxos requires two rounds of communication:</p><pre>[ Proposer ] -&gt; Prepare(n)                                [ Followers ]\n             &lt;- Promise(n; previous proposal number\n                and previous value if accepted a\n                proposal in the past)\n\n[ Proposer ] -&gt; AcceptRequest(n, own value or the value   [ Followers ]\n                associated with the highest proposal number\n                reported by the followers)\n                &lt;- Accepted(n, value)</pre><p>The prepare stage allows the proposer to learn of any competing or previous proposals. The second phase is where either a new value or a previously accepted value is proposed. In some cases - such as if two proposers are active at the same time (dueling); if messages are lost; or if a majority of the nodes have failed - then no proposal is accepted by a majority. But this is acceptable, since the decision rule for what value to propose converges towards a single value (the one with the highest proposal number in the previous attempt).</p><p>Indeed, according to the FLP impossibility result, this is the best we can do: algorithms that solve the consensus problem must either give up safety or liveness when the guarantees regarding bounds on message delivery do not hold. Paxos gives up liveness: it may have to delay decisions indefinitely until a point in time where there are no competing leaders, and a majority of nodes accept a proposal. This is preferable to violating the safety guarantees.</p><p>Of course, implementing this algorithm is much harder than it sounds. There are many small concerns which add up to a fairly significant amount of code even in the hands of experts. These are issues such as:</p><ul><li>practical optimizations:<ul><li>avoiding repeated leader election via leadership leases (rather than heartbeats)</li><li>avoiding repeated propose messages when in a stable state where the leader identity does not change</li></ul></li><li>ensuring that followers and proposers do not lose items in stable storage and that results stored in stable storage are not subtly corrupted (e.g. disk corruption)</li><li>enabling cluster membership to change in a safe manner (e.g. base Paxos depends on the fact that majorities always intersect in one node, which does not hold if the membership can change arbitrarily)</li><li>procedures for bringing a new replica up to date in a safe and efficient manner after a crash, disk loss or when a new node is provisioned</li><li>procedures for snapshotting and garbage collecting the data required to guarantee safety after some reasonable period (e.g. balancing storage requirements and fault tolerance requirements)</li></ul><h2>Partition-tolerant consensus algorithms: Paxos, Raft, ZAB</h2><p>Hopefully, this has given you a sense of how a partition-tolerant consensus algorithm works. I encourage you to read one of the papers in the further reading section to get a grasp of the specifics of the different algorithms.</p><p>. Paxos is one of the most important algorithms when writing strongly consistent partition tolerant replicated systems. It is used in many of Google's systems, including the <a href=\"https://research.google.com/archive/chubby.html\">Chubby lock manager</a> used by <a href=\"https://research.google.com/archive/bigtable.html\">BigTable</a>/<a href=\"https://research.google.com/pubs/pub36971.html\">Megastore</a>, the Google File System as well as <a href=\"https://research.google.com/archive/spanner.html\">Spanner</a>.</p><p>Paxos is named after the Greek island of Paxos, and was originally presented by Leslie Lamport in a paper called \"The Part-Time Parliament\" in 1998. It is often considered to be difficult to implement, and there have been a series of papers from companies with considerable distributed systems expertise explaining further practical details (see the further reading). You might want to read Lamport's commentary on this issue <a href=\"http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#lamport-paxos\">here</a> and <a href=\"http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#paxos-simple\">here</a>.</p><p>The issues mostly relate to the fact that Paxos is described in terms of a single round of consensus decision making, but an actual working implementation usually wants to run multiple rounds of consensus efficiently. This has led to the development of many <a href=\"https://en.wikipedia.org/wiki/Paxos_algorithm\">extensions on the core protocol</a> that anyone interested in building a Paxos-based system still needs to digest. Furthermore, there are additional practical challenges such as how to facilitate cluster membership change.</p><p>. ZAB - the Zookeeper Atomic Broadcast protocol is used in Apache Zookeeper. Zookeeper is a system which provides coordination primitives for distributed systems, and is used by many Hadoop-centric distributed systems for coordination (e.g. <a href=\"http://hbase.apache.org/\">HBase</a>, <a href=\"http://storm-project.net/\">Storm</a>, <a href=\"http://kafka.apache.org/\">Kafka</a>). Zookeeper is basically the open source community's version of Chubby. Technically speaking atomic broadcast is a problem different from pure consensus, but it still falls under the category of partition tolerant algorithms that ensure strong consistency.</p><p>. Raft is a recent (2013) addition to this family of algorithms. It is designed to be easier to teach than Paxos, while providing the same guarantees. In particular, the different parts of the algorithm are more clearly separated and the paper also describes a mechanism for cluster membership change. It has recently seen adoption in <a href=\"https://github.com/coreos/etcd\">etcd</a> inspired by ZooKeeper.</p><h2>Replication methods with strong consistency</h2><p>In this chapter, we took a look at replication methods that enforce strong consistency. Starting with a contrast between synchronous work and asynchronous work, we worked our way up to algorithms that are tolerant of increasingly complex failures. Here are some of the key characteristics of each of the algorithms:</p><ul><li>Replicated log, slaves are not involved in executing operations</li><li>No bounds on replication delay</li><li>Manual/ad-hoc failover, not fault tolerant, \"hot backup\"</li></ul><ul><li>Unanimous vote: commit or abort</li><li>2PC cannot survive simultaneous failure of the coordinator and a node during a commit</li><li>Not partition tolerant, tail latency sensitive</li></ul><ul><li>Robust to n/2-1 simultaneous failures as part of protocol</li><li>Less sensitive to tail latency</li></ul><p>Now that we've taken a look at protocols that can enforce single-copy consistency under an increasingly realistic set of supported failure cases, let's turn our attention at the world of options that opens up once we let go of the requirement of single-copy consistency.</p><p>By and large, it is hard to come up with a single dimension that defines or characterizes the protocols that allow for replicas to diverge. Most such protocols are highly available, and the key issue is more whether or not the end users find the guarantees, abstractions and APIs useful for their purpose in spite of the fact that the replicas may diverge when node and/or network failures occur.</p><p>Why haven't weakly consistent systems been more popular?</p><p>As I stated in the introduction, I think that much of distributed programming is about dealing with the implications of two consequences of distribution:</p><ul><li>that information travels at the speed of light</li><li>that independent things fail independently</li></ul><p>The implication that follows from the limitation on the speed at which information travels is that nodes experience the world in different, unique ways. Computation on a single node is easy, because everything happens in a predictable global total order. Computation on a distributed system is difficult, because there is no global total order.</p><p>For the longest while (e.g. decades of research), we've solved this problem by introducing a global total order. I've discussed the many methods for achieving strong consistency by creating order (in a fault-tolerant manner) where there is no naturally occurring total order.</p><p>Of course, the problem is that enforcing order is expensive. This breaks down in particular with large scale internet systems, where a system needs to remain available. A system enforcing strong consistency doesn't behave like a distributed system: it behaves like a single system, which is bad for availability during a partition.</p><p>Furthermore, for each operation, often a majority of the nodes must be contacted - and often not just once, but twice (as you saw in the discussion on 2PC). This is particularly painful in systems that need to be geographically distributed to provide adequate performance for a global user base.</p><p>So behaving like a single system by default is perhaps not desirable.</p><p>Perhaps what we want is a system where we can write code that doesn't use expensive coordination, and yet returns a \"usable\" value. Instead of having a single truth, we will allow different replicas to diverge from each other - both to keep things efficient but also to tolerate partitions - and then try to find a way to deal with the divergence in some manner.</p><p>Eventual consistency expresses this idea: that nodes can for some time diverge from each other, but that eventually they will agree on the value.</p><p>Within the set of systems providing eventual consistency, there are two types of system designs:</p><p><em>Eventual consistency with probabilistic guarantees</em>. This type of system can detect conflicting writes at some later point, but does not guarantee that the results are equivalent to some correct sequential execution. In other words, conflicting updates will sometimes result in overwriting a newer value with an older one and some anomalies can be expected to occur during normal operation (or during partitions).</p><p>In recent years, the most influential system design offering single-copy consistency is Amazon's Dynamo, which I will discuss as an example of a system that offers eventual consistency with probabilistic guarantees.</p><p><em>Eventual consistency with strong guarantees</em>. This type of system guarantees that the results converge to a common value equivalent to some correct sequential execution. In other words, such systems do not produce any anomalous results; without any coordination you can build replicas of the same service, and those replicas can communicate in any pattern and receive the updates in any order, and they will eventually agree on the end result as long as they all see the same information.</p><p>CRDT's (convergent replicated data types) are data types that guarantee convergence to the same value in spite of network delays, partitions and message reordering. They are provably convergent, but the data types that can be implemented as CRDT's are limited.</p><p>The CALM (consistency as logical monotonicity) conjecture is an alternative expression of the same principle: it equates logical monotonicity with convergence. If we can conclude that something is logically monotonic, then it is also safe to run without coordination. Confluence analysis - in particular, as applied for the Bloom programming language - can be used to guide programmer decisions about when and where to use the coordination techniques from strongly consistent systems and when it is safe to execute without coordination.</p><h2>Reconciling different operation orders</h2><p>What does a system that does not enforce single-copy consistency look like?  Let's try to make this more concrete by looking at a few examples.</p><p>Perhaps the most obvious characteristic of systems that do not enforce single-copy consistency is that they allow replicas to diverge from each other. This means that there is no strictly defined pattern of communication: replicas can be separated from each other and yet continue to be available and accept writes.</p><p>Let's imagine a system of three replicas, each of which is partitioned from the others. For example, the replicas might be in different datacenters and for some reason unable to communicate. Each replica remains available during the partition, accepting both reads and writes from some set of clients:</p><pre>[Clients]   - &gt; [A]\n\n--- Partition ---\n\n[Clients]   - &gt; [B]\n\n--- Partition ---\n\n[Clients]   - &gt; [C]</pre><p>After some time, the partitions heal and the replica servers exchange information. They have received different updates from different clients and have diverged each other, so some sort of reconciliation needs to take place. What we would like to happen is that all of the replicas converge to the same result.</p><pre>[A] \\\n    --&gt; [merge]\n[B] /     |\n          |\n[C] ----[merge]---&gt; result</pre><p>Another way to think about systems with weak consistency guarantees is to imagine a set of clients sending messages to two replicas in some order. Because there is no coordination protocol that enforces a single total order, the messages can get delivered in different orders at the two replicas:</p><pre>[Clients]  --&gt; [A]  1, 2, 3\n[Clients]  --&gt; [B]  2, 3, 1</pre><p>This is, in essence, the reason why we need coordination protocols. For example, assume that we are trying to concatenate a string and the operations in messages 1, 2 and 3 are:</p><pre>1: { operation: concat('Hello ') }\n2: { operation: concat('World') }\n3: { operation: concat('!') }</pre><p>Then, without coordination, A will produce \"Hello World!\", and B will produce \"World!Hello \".</p><pre>A: concat(concat(concat('', 'Hello '), 'World'), '!') = 'Hello World!'\nB: concat(concat(concat('', 'World'), '!'), 'Hello ') = 'World!Hello '</pre><p>This is, of course, incorrect. Again, what we'd like to happen is that the replicas converge to the same result.</p><p>Keeping these two examples in mind, let's look at Amazon's Dynamo first to establish a baseline, and then discuss a number of novel approaches to building systems with weak consistency guarantees, such as CRDT's and the CALM theorem.</p><p>Amazon's Dynamo system design (2007) is probably the best-known system that offers weak consistency guarantees but high availability. It is the basis for many other real world systems, including LinkedIn's Voldemort, Facebook's Cassandra and Basho's Riak.</p><p>Dynamo is an eventually consistent, highly available key-value store. A key value store is like a large hash table: a client can set values via  and retrieve them by key using . A Dynamo cluster consists of N peer nodes; each node has a set of keys which is it responsible for storing.</p><p>Dynamo prioritizes availability over consistency; it does not guarantee single-copy consistency. Instead, replicas may diverge from each other when values are written; when a key is read, there is a read reconciliation phase that attempts to reconcile differences between replicas before returning the value back to the client.</p><p>For many features on Amazon, it is more important to avoid outages than it is to ensure that data is perfectly consistent, as an outage can lead to lost business and a loss of credibility. Furthermore, if the data is not particularly important, then a weakly consistent system can provide better performance and higher availability at a lower cost than a traditional RDBMS.</p><p>Since Dynamo is a complete system design, there are many different parts to look at beyond the core replication task. The diagram below illustrates some of the tasks; notably, how a write is routed to a node and written to multiple replicas.</p><pre>[ Client ]\n    |\n( Mapping keys to nodes )\n    |\n    V\n[ Node A ]\n    |     \\\n( Synchronous replication task: minimum durability )\n    |        \\\n[ Node B]  [ Node C ]\n    A\n    |\n( Conflict detection; asynchronous replication task:\n  ensuring that partitioned / recovered nodes recover )\n    |\n    V\n[ Node D]</pre><p>After looking at how a write is initially accepted, we'll look at how conflicts are detected, as well as the asynchronous replica synchronization task. This task is needed because of the high availability design, in which nodes may be temporarily unavailable (down or partitioned). The replica synchronization task ensures that nodes can catch up fairly rapidly even after a failure.</p><p>Whether we are reading or writing, the first thing that needs to happen is that we need to locate where the data should live on the system. This requires some type of key-to-node mapping.</p><p>In Dynamo, keys are mapped to nodes using a hashing technique known as <a href=\"https://github.com/mixu/vnodehash\">consistent hashing</a> (which I will not discuss in detail). The main idea is that a key can be mapped to a set of nodes responsible for it by a simple calculation on the client. This means that a client can locate keys without having to query the system for the location of each key; this saves system resources as hashing is generally faster than performing a remote procedure call.</p><p>Once we know where a key should be stored, we need to do some work to persist the value. This is a synchronous task; the reason why we will immediately write the value onto multiple nodes is to provide a higher level of durability (e.g. protection from the immediate failure of a node).</p><p>Just like Paxos or Raft, Dynamo uses quorums for replication. However, Dynamo's quorums are sloppy (partial) quorums rather than strict (majority) quorums.</p><p>Informally, a strict quorum system is a quorum system with the property that any two quorums (sets) in the quorum system overlap. Requiring a majority to vote for an update before accepting it guarantees that only a single history is admitted since each majority quorum must overlap in at least one node. This was the property that Paxos, for example, relied on.</p><p>Partial quorums do not have that property; what this means is that a majority is not required and that different subsets of the quorum may contain different versions of the same data. The user can choose the number of nodes to write to and read from:</p><ul><li>the user can choose some number W-of-N nodes required for a write to succeed; and</li><li>the user can specify the number of nodes (R-of-N) to be contacted during a read.</li></ul><p> and  specify the number of nodes that need to be involved to a write or a read. Writing to more nodes makes writes slightly slower but increases the probability that the value is not lost; reading from more nodes increases the probability that the value read is up to date.</p><p>The usual recommendation is that , because this means that the read and write quorums overlap in one node - making it less likely that a stale value is returned. A typical configuration is  (e.g. a total of three replicas for each value); this means that the user can choose between:</p><pre> R = 1, W = 3;\n R = 2, W = 2 or\n R = 3, W = 1</pre><p>More generally, again assuming :</p><ul><li>, : fast reads, slow writes</li><li>, : fast writes, slow reads</li><li> and : favorable to both</li></ul><p>N is rarely more than 3, because keeping that many copies of large amounts of data around gets expensive!</p><p>As I mentioned earlier, the Dynamo paper has inspired many other similar designs. They all use the same partial quorum based replication approach, but with different defaults for N, W and R:</p><ul><li>Basho's Riak (N = 3, R = 2, W = 2 default)</li><li>Linkedin's Voldemort (N = 2 or 3, R = 1, W = 1 default)</li><li>Apache's Cassandra (N = 3, R = 1, W = 1 default)</li></ul><p>There is another detail: when sending a read or write request, are all N nodes asked to respond (Riak), or only a number of nodes that meets the minimum (e.g. R or W; Voldemort). The \"send-to-all\" approach is faster and less sensitive to latency (since it only waits for the fastest R or W nodes of N) but also less efficient, while the \"send-to-minimum\" approach is more sensitive to latency (since latency communicating with a single node will delay the operation) but also more efficient (fewer messages / connections overall).</p><p>What happens when the read and write quorums overlap, e.g. ()? Specifically, it is often claimed that this results in \"strong consistency\".</p><h3>Is R + W &gt; N the same as \"strong consistency\"?</h3><p>It's not completely off base: a system where  can detect read/write conflicts, since any read quorum and any write quorum share a member. E.g. at least one node is in both quorums:</p><pre>   1     2   N/2+1     N/2+2    N\n  [...] [R]  [R + W]   [W]    [...]</pre><p>This guarantees that a previous write will be seen by a subsequent read. However, this only holds if the nodes in N never change. Hence, Dynamo doesn't qualify, because in Dynamo the cluster membership can change if nodes fail.</p><p>Dynamo is designed to be always writable. It has a mechanism which handles node failures by adding a different, unrelated server into the set of nodes responsible for certain keys when the original server is down. This means that the quorums are no longer guaranteed to always overlap. Even  would not qualify, since while the quorum sizes are equal to N, the nodes in those quorums can change during a failure. Concretely, during a partition, if a sufficient number of nodes cannot be reached, Dynamo will add new nodes to the quorum from unrelated but accessible nodes.</p><p>Furthermore, Dynamo doesn't handle partitions in the manner that a system enforcing a strong consistency model would: namely, writes are allowed on both sides of a partition, which means that for at least some time the system does not act as a single copy. So calling  \"strongly consistent\" is misleading; the guarantee is merely probabilistic - which is not what strong consistency refers to.</p><h3>Conflict detection and read repair</h3><p>Systems that allow replicas to diverge must have a way to eventually reconcile two different values. As briefly mentioned during the partial quorum approach, one way to do this is to detect conflicts at read time, and then apply some conflict resolution method. But how is this done?</p><p>In general, this is done by tracking the causal history of a piece of data by supplementing it with some metadata. Clients must keep the metadata information when they read data from the system, and must return back the metadata value when writing to the database.</p><p>We've already encountered a method for doing this: vector clocks can be used to represent the history of a value. Indeed, this is what the original Dynamo design uses for detecting conflicts.</p><p>However, using vector clocks is not the only alternative. If you look at many practical system designs, you can deduce quite a bit about how they work by looking at the metadata that they track.</p><p>. When a system does not track metadata, and only returns the value (e.g. via a client API), it cannot really do anything special about concurrent writes. A common rule is that the last writer wins: in other words, if two writers are writing at the same time, only the value from the slowest writer is kept around.</p><p>. Nominally, the value with the higher timestamp value wins. However, if time is not carefully synchronized, many odd things can happen where old data from a system with a faulty or fast clock overwrites newer values. Facebook's Cassandra is a Dynamo variant that uses timestamps instead of vector clocks.</p><p>. Version numbers may avoid some of the issues related with using timestamps. Note that the smallest mechanism that can accurately track causality when multiple histories are possible are vector clocks, not version numbers.</p><p>. Using vector clocks, concurrent and out of date updates can be detected. Performing read repair then becomes possible, though in some cases (concurrent changes) we need to ask the client to pick a value. This is because if the changes are concurrent and we know nothing more about the data (as is the case with a simple key-value store), then it is better to ask than to discard data arbitrarily.</p><p>When reading a value, the client contacts  of  nodes and asks them for the latest value for a key. It takes all the responses, discards the values that are strictly older (using the vector clock value to detect this). If there is only one unique vector clock + value pair, it returns that. If there are multiple vector clock + value pairs that have been edited concurrently (e.g. are not comparable), then all of those values are returned.</p><p>As is obvious from the above, read repair may return multiple values. This means that the client / application developer must occasionally handle these cases by picking a value based on some use-case specific criterion.</p><p>In addition, a key component of a practical vector clock system is that the clocks cannot be allowed to grow forever - so there needs to be a procedure for occasionally garbage collecting the clocks in a safe manner to balance fault tolerance with storage requirements.</p><h3>Replica synchronization: gossip and Merkle trees</h3><p>Given that the Dynamo system design is tolerant of node failures and network partitions, it needs a way to deal with nodes rejoining the cluster after being partitioned, or when a failed node is replaced or partially recovered.</p><p>Replica synchronization is used to bring nodes up to date after a failure, and for periodically synchronizing replicas with each other.</p><p>Gossip is a probabilistic technique for synchronizing replicas. The pattern of communication (e.g. which node contacts which node) is not determined in advance. Instead, nodes have some probability  of attempting to synchronize with each other. Every  seconds, each node picks a node to communicate with. This provides an additional mechanism beyond the synchronous task (e.g. the partial quorum writes) which brings the replicas up to date.</p><p>Gossip is scalable, and has no single point of failure, but can only provide probabilistic guarantees.</p><p>In order to make the information exchange during replica synchronization efficient, Dynamo uses a technique called Merkle trees, which I will not cover in detail. The key idea is that a data store can be hashed at multiple different levels of granularity: a hash representing the whole content, half the keys, a quarter of the keys and so on.</p><p>By maintaining this fairly granular hashing, nodes can compare their data store content much more efficiently than a naive technique. Once the nodes have identified which keys have different values, they exchange the necessary information to bring the replicas up to date.</p><h3>Dynamo in practice: probabilistically bounded staleness (PBS)</h3><p>And that pretty much covers the Dynamo system design:</p><ul><li>consistent hashing to determine key placement</li><li>partial quorums for reading and writing</li><li>conflict detection and read repair via vector clocks and</li><li>gossip for replica synchronization</li></ul><p>How might we characterize the behavior of such a system? A fairly recent paper from Bailis et al. (2012) describes an approach called <a href=\"http://pbs.cs.berkeley.edu/\">PBS</a> (probabilistically bounded staleness) uses simulation and data collected from a real world system to characterize the expected behavior of such a system.</p><p>PBS estimates the degree of inconsistency by using information about the anti-entropy (gossip) rate, the network latency and local processing delay to estimate the expected level of consistency of reads. It has been implemented in Cassandra, where timing information is piggybacked on other messages and an estimate is calculated based on a sample of this information in a Monte Carlo simulation.</p><p>Based on the paper, during normal operation eventually consistent data stores are often faster and can read a consistent state within tens or hundreds of milliseconds. The table below illustrates amount of time required from a 99.9% probability of consistent reads given different  and  settings on empirical timing data from LinkedIn (SSD and 15k RPM disks) and Yammer:</p><p>For example, going from ,  to ,  in the Yammer case reduces the inconsistency window from 1352 ms to 202 ms - while keeping the read latencies lower (32.6 ms) than the fastest strict quorum (, ; 219.27 ms).</p><p>For more details, have a look at the <a href=\"http://pbs.cs.berkeley.edu/\">PBS website</a>  and the associated paper.</p><p>Let's look back at the examples of the kinds of situations that we'd like to resolve. The first scenario consisted of three different servers behind partitions; after the partitions healed, we wanted the servers to converge to the same value. Amazon's Dynamo made this possible by reading from  out of  nodes and then performing read reconciliation.</p><p>In the second example, we considered a more specific operation: string concatenation. It turns out that there is no known technique for making string concatenation resolve to the same value without imposing an order on the operations (e.g. without expensive coordination). However, there are operations which can be applied safely in any order, where a simple register would not be able to do so. As Pat Helland wrote:</p><blockquote><p>... operation-centric work can be made commutative (with the right operations and the right semantics) where a simple READ/WRITE semantic does not lend itself to commutativity.</p></blockquote><p>For example, consider a system that implements a simple accounting system with the  and  operations in two different ways:</p><ul><li>using a register with  and  operations, and</li><li>using a integer data type with native  and  operations</li></ul><p>The latter implementation knows more about the internals of the data type, and so it can preserve the intent of the operations in spite of the operations being reordered. Debiting or crediting can be applied in any order, and the end result is the same:</p><pre>100 + credit(10) + credit(20) = 130 and\n100 + credit(20) + credit(10) = 130</pre><p> However, writing a fixed value cannot be done in any order: if writes are reordered, the one of the writes will overwrite the other:</p><pre>100 + write(110) + write(130) = 130 but\n100 + write(130) + write(110) = 110</pre><p>Let's take the example from the beginning of this chapter, but use a different operation. In this scenario, clients are sending messages to two nodes, which see the operations in different orders:</p><pre>[Clients]  --&gt; [A]  1, 2, 3\n[Clients]  --&gt; [B]  2, 3, 1</pre><p>Instead of string concatenation, assume that we are looking to find the largest value (e.g. MAX()) for a set of integers. The messages 1, 2 and 3 are:</p><pre>1: { operation: max(previous, 3) }\n2: { operation: max(previous, 5) }\n3: { operation: max(previous, 7) }</pre><p>Then, without coordination, both A and B will converge to 7, e.g.:</p><pre>A: max(max(max(0, 3), 5), 7) = 7\nB: max(max(max(0, 5), 7), 3) = 7</pre><p>In both cases, two replicas see updates in different order, but we are able to merge the results in a way that has the same result in spite of what the order is. The result converges to the same answer in both cases because of the merge procedure () we used.</p><p>It is likely not possible to write a merge procedure that works for all data types. In Dynamo, a value is a binary blob, so the best that can be done is to expose it and ask the application to handle each conflict.</p><p>However, if we know that the data is of a more specific type, handling these kinds of conflicts becomes possible. CRDT's are data structures designed to provide data types that will always converge, as long as they see the same set of operations (in any order).</p><h2>CRDTs: Convergent replicated data types</h2><p>CRDTs (convergent replicated datatypes) exploit knowledge regarding the commutativity and associativity of specific operations on specific datatypes.</p><p>In order for a set of operations to converge on the same value in an environment where replicas only communicate occasionally, the operations need to be order-independent and insensitive to (message) duplication/redelivery. Thus, their operations need to be:</p><ul><li>Associative (), so that grouping doesn't matter</li><li>Commutative (), so that order of application doesn't matter</li><li>Idempotent (), so that duplication does not matter</li></ul><p>It turns out that these structures are already known in mathematics; they are known as join or meet <a href=\"https://en.wikipedia.org/wiki/Semilattice\">semilattices</a>.</p><p>A <a href=\"https://en.wikipedia.org/wiki/Lattice_%28order%29\">lattice</a> is a partially ordered set with a distinct top (least upper bound) and a distinct bottom (greatest lower bound). A semilattice is like a lattice, but one that only has a distinct top or bottom. A join semilattice is one with a distinct top (least upper bound) and a meet semilattice is one with a distinct bottom (greatest lower bound).</p><p>Any data type that be expressed as a semilattice can be implemented as a data structure which guarantees convergence. For example, calculating the  of a set of values will always return the same result regardless of the order in which the values were received, as long as all values are eventually received, because the  operation is associative, commutative and idempotent.</p><p>For example, here are two lattices: one drawn for a set, where the merge operator is  and one drawn for a strictly increasing integer counter, where the merge operator is :</p><pre>   { a, b, c }              7\n  /      |    \\            /  \\\n{a, b} {b,c} {a,c}        5    7\n  |  \\  /  | /           /   |  \\\n  {a} {b} {c}            3   5   7</pre><p>With data types that can be expressed as semilattices, you can have replicas communicate in any pattern and receive the updates in any order, and they will eventually agree on the end result as long as they all see the same information. That is a powerful property that can be guaranteed as long as the prerequisites hold.</p><p>However, expressing a data type as a semilattice often requires some level of interpretation. Many data types have operations which are not in fact order-independent. For example, adding items to a set is associative, commutative and idempotent. However, if we also allow items to be removed from a set, then we need some way to resolve conflicting operations, such as  and . What does it mean to remove an element if the local replica never added it? This resolution has to be specified in a manner that is order-independent, and there are several different choices with different tradeoffs.</p><p>This means that several familiar data types have more specialized implementations as CRDT's which make a different tradeoff in order to resolve conflicts in an order-independent manner. Unlike a key-value store which simply deals with registers (e.g. values that are opaque blobs from the perspective of the system), someone using CRDTs must use the right data type to avoid anomalies.</p><p>Some examples of the different data types specified as CRDT's include:</p><ul><li>Counters<ul><li>Grow-only counter (merge = max(values); payload = single integer)</li><li>Positive-negative counter (consists of two grow counters, one for increments and another for decrements)</li></ul></li><li>Registers<ul><li>Last Write Wins -register (timestamps or version numbers; merge = max(ts); payload = blob)</li><li>Multi-valued -register (vector clocks; merge = take both)</li></ul></li><li>Sets<ul><li>Grow-only set (merge = union(items); payload = set; no removal)</li><li>Two-phase set (consists of two sets, one for adding, and another for removing; elements can be added once and removed once)</li><li>Unique set (an optimized version of the two-phase set)</li><li>Last write wins set (merge = max(ts); payload = set)</li><li>Positive-negative set (consists of one PN-counter per set item)</li></ul></li><li>Graphs and text sequences (see the paper)</li></ul><p>To ensure anomaly-free operation, you need to find the right data type for your specific application - for example, if you know that you will only remove an item once, then a two-phase set works; if you will only ever add items to a set and never remove them, then a grow-only set works.</p><p>Not all data structures have known implementations as CRDTs, but there are CRDT implementations for booleans, counters, sets, registers and graphs in the recent (2011) <a href=\"http://hal.inria.fr/docs/00/55/55/88/PDF/techreport.pdf\">survey paper from Shapiro et al</a>.</p><p>Interestingly, the register implementations correspond directly with the implementations that key value stores use: a last-write-wins register uses timestamps or some equivalent and simply converges to the largest timestamp value; a multi-valued register corresponds to the Dynamo strategy of retaining, exposing and reconciling concurrent changes. For the details, I recommend that you take a look at the papers in the further reading section of this chapter.</p><p>The CRDT data structures were based on the recognition that data structures expressible as semilattices are convergent. But programming is about more than just evolving state, unless you are just implementing a data store.</p><p>Clearly, order-independence is an important property of any computation that converges: if the order in which data items are received influences the result of the computation, then there is no way to execute a computation without guaranteeing order.</p><p>However, there are many programming models in which the order of statements does not play a significant role. For example, in the <a href=\"https://en.wikipedia.org/wiki/MapReduce\">MapReduce model</a>, both the Map and the Reduce tasks are specified as stateless tuple-processing tasks that need to be run on a dataset. Concrete decisions about how and in what order data is routed to the tasks is not specified explicitly, instead, the batch job scheduler is responsible for scheduling the tasks to run on the cluster.</p><p>Similarly, in SQL one specifies the query, but not how the query is executed. The query is simply a declarative description of the task, and it is the job of the query optimizer to figure out an efficient way to execute the query (across multiple machines, databases and tables).</p><p>Of course, these programming models are not as permissive as a general purpose programming language. MapReduce tasks need to be expressible as stateless tasks in an acyclic dataflow program; SQL statements can execute fairly sophisticated computations but many things are hard to express in it.</p><p>However, it should be clear from these two examples that there are many kinds of data processing tasks which are amenable to being expressed in a declarative language where the order of execution is not explicitly specified. Programming models which express a desired result while leaving the exact order of statements up to an optimizer to decide often have semantics that are order-independent. This means that such programs may be possible to execute without coordination, since they depend on the inputs they receive but not necessarily the specific order in which the inputs are received.</p><p>The key point is that such programs  safe to execute without coordination. Without a clear rule that characterizes what is safe to execute without coordination, and what is not, we cannot implement a program while remaining certain that the result is correct.</p><p>This is what the CALM theorem is about. The CALM theorem is based on a recognition of the link between logical monotonicity and useful forms of eventual consistency (e.g. confluence / convergence). It states that logically monotonic programs are guaranteed to be eventually consistent.</p><p>Then, if we know that some computation is logically monotonic, then we know that it is also safe to execute without coordination.</p><p>To better understand this, we need to contrast monotonic logic (or monotonic computations) with <a href=\"http://plato.stanford.edu/entries/logic-nonmonotonic/\">non-monotonic logic</a> (or non-monotonic computations).</p><dl><dd>if sentence  is a consequence of a set of premises , then it can also be inferred from any set  of premises extending </dd></dl><p>Most standard logical frameworks are monotonic: any inferences made within a framework such as first-order logic, once deductively valid, cannot be invalidated by new information. A non-monotonic logic is a system in which that property does not hold - in other words, if some conclusions can be invalidated by learning new knowledge.</p><p>Within the artificial intelligence community, non-monotonic logics are associated with <a href=\"http://plato.stanford.edu/entries/reasoning-defeasible/\">defeasible reasoning</a> - reasoning, in which assertions made utilizing partial information can be invalidated by new knowledge. For example, if we learn that Tweety is a bird, we'll assume that Tweety can fly; but if we later learn that Tweety is a penguin, then we'll have to revise our conclusion.</p><p>Monotonicity concerns the relationship between premises (or facts about the world) and conclusions (or assertions about the world). Within a monotonic logic, we know that our results are retraction-free: <a href=\"https://en.wikipedia.org/wiki/Monotonicity_of_entailment\">monotone</a> computations do not need to be recomputed or coordinated; the answer gets more accurate over time. Once we know that Tweety is a bird (and that we're reasoning using monotonic logic), we can safely conclude that Tweety can fly and that nothing we learn can invalidate that conclusion.</p><p>While any computation that produces a human-facing result can be interpreted as an assertion about the world (e.g. the value of \"foo\" is \"bar\"), it is difficult to determine whether a computation in a von Neumann machine based programming model is monotonic, because it is not exactly clear what the relationship between facts and assertions are and whether those relationships are monotonic.</p><p>However, there are a number of programming models for which determining monotonicity is possible. In particular, <a href=\"https://en.wikipedia.org/wiki/Relational_algebra\">relational algebra</a> (e.g. the theoretical underpinnings of SQL) and <a href=\"https://en.wikipedia.org/wiki/Datalog\">Datalog</a> provide highly expressive languages that have well-understood interpretations.</p><p>Both basic Datalog and relational algebra (even with recursion) are known to be monotonic. More specifically, computations expressed using a certain set of basic operators are known to be monotonic (selection, projection, natural join, cross product, union and recursive Datalog without negation), and non-monotonicity is introduced by using more advanced operators (negation, set difference, division, universal quantification, aggregation).</p><p>This means that computations expressed using a significant number of operators (e.g. map, filter, join, union, intersection) in those systems are logically monotonic; any computations using those operators are also monotonic and thus safe to run without coordination. Expressions that make use of negation and aggregation, on the other hand, are not safe to run without coordination.</p><p>It is important to realize the connection between non-monotonicity and operations that are expensive to perform in a distributed system. Specifically, both  and  can be considered to be a form of negation. As Joe Hellerstein <a href=\"http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-90.pdf\">writes</a>:</p><blockquote><p>To establish the veracity of a negated predicate in a distributed setting, an evaluation strategy has to start \"counting to 0\" to determine emptiness, and wait until the distributed counting process has definitely terminated. Aggregation is the generalization of this idea.</p></blockquote><blockquote><p>This idea can be seen from the other direction as well. Coordination protocols are themselves aggregations, since they entail voting: Two-Phase Commit requires unanimous votes, Paxos consensus requires majority votes, and Byzantine protocols require a 2/3 majority. Waiting requires counting.</p></blockquote><p>If, then we can express our computation in a manner in which it is possible to test for monotonicity, then we can perform a whole-program static analysis that detects which parts of the program are eventually consistent and safe to run without coordination (the monotonic parts) - and which parts are not (the non-monotonic ones).</p><p>Note that this requires a different kind of language, since these inferences are hard to make for traditional programming languages where sequence, selection and iteration are at the core. Which is why the Bloom language was designed.</p><h2>What is non-mononicity good for?</h2><p>The difference between monotonicity and non-monotonicity is interesting. For example, adding two numbers is monotonic, but calculating an aggregation over two nodes containing numbers is not. What's the difference? One of these is a computation (adding two numbers), while the other is an assertion (calculating an aggregate).</p><p>How does a computation differ from an assertion? Let's consider the query \"is pizza a vegetable?\". To answer that, we need to get at the core: when is it acceptable to infer that something is (or is not) true?</p><p>There are several acceptable answers, each corresponding to a different set of assumptions regarding the information that we have and the way we ought to act upon it - and we've come to accept different answers in different contexts.</p><p>In everyday reasoning, we make what is known as the <a href=\"https://en.wikipedia.org/wiki/Open_world_assumption\">open-world assumption</a>: we assume that we do not know everything, and hence cannot make conclusions from a lack of knowledge. That is, any sentence may be true, false or unknown.</p><pre>                                OWA +             |  OWA +\n                                Monotonic logic   |  Non-monotonic logic\nCan derive P(true)      |   Can assert P(true)    |  Cannot assert P(true)\nCan derive P(false)     |   Can assert P(false)   |  Cannot assert P(true)\nCannot derive P(true)   |   Unknown               |  Unknown\nor P(false)</pre><p>When making the open world assumption, we can only safely assert something we can deduce from what is known. Our information about the world is assumed to be incomplete.</p><p>Let's first look at the case where we know our reasoning is monotonic. In this case, any (potentially incomplete) knowledge that we have cannot be invalidated by learning new knowledge. So if we can infer that a sentence is true based on some deduction, such as \"things that contain two tablespoons of tomato paste are vegetables\" and \"pizza contains two tablespoons of tomato paste\", then we can conclude that \"pizza is a vegetable\". The same goes for if we can deduce that a sentence is false.</p><p>However, if we cannot deduce anything - for example, the set of knowledge we have contains customer information and nothing about pizza or vegetables - then under the open world assumption we have to say that we cannot conclude anything.</p><p>With non-monotonic knowledge, anything we know right now can potentially be invalidated. Hence, we cannot safely conclude anything, even if we can deduce true or false from what we currently know.</p><p>However, within the database context, and within many computer science applications we prefer to make more definite conclusions. This means assuming what is known as the <a href=\"https://en.wikipedia.org/wiki/Closed_world_assumption\">closed-world assumption</a>: that anything that cannot be shown to be true is false. This means that no explicit declaration of falsehood is needed. In other words, the database of facts that we have is assumed to be complete (minimal), so that anything not in it can be assumed to be false.</p><p>For example, under the CWA, if our database does not have an entry for a flight between San Francisco and Helsinki, then we can safely conclude that no such flight exists.</p><p>We need one more thing to be able to make definite assertions: <a href=\"https://en.wikipedia.org/wiki/Circumscription_%28logic%29\">logical circumscription</a>. Circumscription is a formalized rule of conjecture. Domain circumscription conjectures that the known entities are all there are. We need to be able to assume that the known entities are all there are in order to reach a definite conclusion.</p><pre>                                CWA +             |  CWA +\n                                Circumscription + |  Circumscription +\n                                Monotonic logic   |  Non-monotonic logic\nCan derive P(true)      |   Can assert P(true)    |  Can assert P(true)\nCan derive P(false)     |   Can assert P(false)   |  Can assert P(false)\nCannot derive P(true)   |   Can assert P(false)   |  Can assert P(false)\nor P(false)</pre><p>In particular, non-monotonic inferences need this assumption. We can only make a confident assertion if we assume that we have complete information, since additional information may otherwise invalidate our assertion.</p><p>What does this mean in practice? First, monotonic logic can reach definite conclusions as soon as it can derive that a sentence is true (or false). Second, nonmonotonic logic requires an additional assumption: that the known entities are all there is.</p><p>So why are two operations that are on the surface equivalent different? Why is adding two numbers monotonic, but calculating an aggregation over two nodes not? Because the aggregation does not only calculate a sum but also asserts that it has seen all of the values. And the only way to guarantee that is to coordinate across nodes and ensure that the node performing the calculation has really seen all of the values within the system.</p><p>Thus, in order to handle nonmonotonicity one needs to either use distributed coordination to ensure that assertions are made only after all the information is known or make assertions with the caveat that the conclusion can be invalidated later on.</p><p>Handling non-monotonicity is important for reasons of expressiveness. This comes down to being able to express non-monotone things; for example, it is nice to be able to say that the total of some column is X. The system must detect that this kind of computation  requires a global coordination boundary to ensure that we have seen all the entities.</p><p>Purely monotone systems are rare. It seems that most applications operate under the closed-world assumption even when they have incomplete data, and we humans are fine with that. When a database tells you that a direct flight between San Francisco and Helsinki does not exist, you will probably treat this as \"according to this database, there is no direct flight\", but you do not rule out the possibility that that in reality such a flight might still exist.</p><p>Really, this issue only becomes interesting when replicas can diverge (e.g. during a partition or due to delays during normal operation). Then there is a need for a more specific consideration: whether the answer is based on just the current node, or the totality of the system.</p><p>Further, since nonmonotonicity is caused by making an assertion, it seems plausible that many computations can proceed for a long time and only apply coordination at the point where some result or assertion is passed to a 3rd party system or end user. Certainly it is not necessary for every single read and write operation within a system to enforce a total order, if those reads and writes are simply a part of a long running computation.</p><p>The <a href=\"http://www.bloom-lang.net/\">Bloom language</a> is a language designed to make use of the CALM theorem. It is a Ruby DSL which has its formal basis in a temporal logic programming language called Dedalus.</p><p>In Bloom, each node has a database consisting of collections and lattices. Programs are expressed as sets of unordered statements which interact with collections (sets of facts) and lattices (CRDTs). Statements are order-independent by default, but one can also write non-monotonic functions.</p><h4>The CALM theorem, confluence analysis and Bloom</h4><h4>Dynamo; PBS; optimistic replication</h4><p>If you've made it this far, thank you.</p><p>If you liked the book, follow me on <a href=\"https://github.com/mixu/\">Github</a> (or <a href=\"https://twitter.com/mikitotakada\">Twitter</a>). I love seeing that I've had some kind of positive impact. \"Create more value than you capture\" and all that.</p><p>Many many thanks to: logpath, alexras, globalcitizen, graue, frankshearar, roryokane, jpfuentes2, eeror, cmeiklejohn, stevenproctor eos2102 and steveloughran for their help! Of course, any mistakes and omissions that remain are my fault!</p><p>It's worth noting that my chapter on eventual consistency is fairly Berkeley-centric; I'd like to change that. I've also skipped one prominent use case for time: consistent snapshots. There are also a couple of topics which I should expand on: namely, an explicit discussion of safety and liveness properties and a more detailed discussion of consistent hashing. However, I'm off to <a href=\"https://thestrangeloop.com/\">Strange Loop 2013</a>, so whatever.</p><p>If this book had a chapter 6, it would probably be about the ways in which one can make use of and deal with large amounts of data. It seems that the most common type of \"big data\" computation is one in which <a href=\"https://en.wikipedia.org/wiki/SPMD\">a large dataset is passed through a single simple program</a>. I'm not sure what the subsequent chapters would be (perhaps high performance computing, given that the current focus has been on feasibility), but I'll probably know in a couple of years.</p><h2>Books about distributed systems</h2><h4>Distributed Algorithms (Lynch)</h4><p>This is probably the most frequently recommended book on distributed algorithms. I'd also recommend it, but with a caveat. It is very comprehensive, but written for a graduate student audience, so you'll spend a lot of time reading about synchronous systems and shared memory algorithms before getting to things that are most interesting to a practitioner.</p><h4>Introduction to Reliable and Secure Distributed Programming (Cachin, Guerraoui &amp; Rodrigues)</h4><p>For a practitioner, this is a fun one. It's short and full of actual algorithm implementations.</p><h4>Replication: Theory and Practice</h4><p>If you're interested in replication, this book is amazing. The chapter on replication is largely based on a synthesis of the interesting parts of this book plus more recent readings.</p><h4>Distributed Systems: An Algorithmic Approach (Ghosh)</h4><h4>Introduction to Distributed Algorithms (Tel)</h4><p>This book is on traditional transactional information systems, e.g. local RDBMS's. There are two chapters on distributed transactions at the end, but the focus of the book is on transaction processing.</p><h4>Transaction Processing: Concepts and Techniques by Gray and Reuter</h4><p>A classic. I find that Weikum &amp; Vossen is more up to date.</p><p>Here are some additional lists of recommended papers:</p>",
      "contentLength": 153294,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgo8j9/distributed_systems_for_fun_and_profit/"
    },
    {
      "title": "Hyprland 0.54 Released As A \"Massive\" Update To This Wayland Compositor",
      "url": "https://www.phoronix.com/news/Hyprland-0.54-Released",
      "date": 1772237961,
      "author": "/u/anh0516",
      "guid": 49040,
      "unread": true,
      "content": "<p>Michael Larabel is the principal author of Phoronix.com and founded the site in 2004 with a focus on enriching the Linux hardware experience. Michael has written more than 20,000 articles covering the state of Linux hardware support, Linux performance, graphics drivers, and other topics. Michael is also the lead developer of the Phoronix Test Suite, Phoromatic, and OpenBenchmarking.org automated benchmarking software. He can be followed via <a href=\"https://twitter.com/MichaelLarabel\">Twitter</a>, <a href=\"https://www.linkedin.com/in/michaellarabel/\">LinkedIn</a>, or contacted via <a href=\"https://www.michaellarabel.com/\">MichaelLarabel.com</a>.</p>",
      "contentLength": 500,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rgnrby/hyprland_054_released_as_a_massive_update_to_this/"
    },
    {
      "title": "GNOME GitLab Redirecting Some Git Traffic To GitHub For Reducing Costs",
      "url": "https://www.phoronix.com/news/GNOME-GitHub-GitLab-Redirect",
      "date": 1772237737,
      "author": "/u/anh0516",
      "guid": 49025,
      "unread": true,
      "content": "<p>Michael Larabel is the principal author of Phoronix.com and founded the site in 2004 with a focus on enriching the Linux hardware experience. Michael has written more than 20,000 articles covering the state of Linux hardware support, Linux performance, graphics drivers, and other topics. Michael is also the lead developer of the Phoronix Test Suite, Phoromatic, and OpenBenchmarking.org automated benchmarking software. He can be followed via <a href=\"https://twitter.com/MichaelLarabel\">Twitter</a>, <a href=\"https://www.linkedin.com/in/michaellarabel/\">LinkedIn</a>, or contacted via <a href=\"https://www.michaellarabel.com/\">MichaelLarabel.com</a>.</p>",
      "contentLength": 500,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rgno7l/gnome_gitlab_redirecting_some_git_traffic_to/"
    },
    {
      "title": "[OpenGL C++] 3D Voxel Engine Tutorial",
      "url": "https://youtube.com/playlist?list=PLQ7CpbxNS-_YP1WhUAVmxRQuF_a4PLju_&amp;si=GMhtbEdFJ461Wdr2",
      "date": 1772233939,
      "author": "/u/BrawlyxHariyama",
      "guid": 49177,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgm4nt/opengl_c_3d_voxel_engine_tutorial/"
    },
    {
      "title": "Trolley - Run terminal apps anywhere (pairs well with Bubbletea)",
      "url": "https://github.com/weedonandscott/trolley",
      "date": 1772232885,
      "author": "/u/weedonandscott",
      "guid": 49002,
      "unread": true,
      "content": "<p>Happy to share the early version of Trolley, which lets you wrap your TUI app and distribute to non-technical users on Linux, Mac, and maybe Windows (not tested yet).</p><p>This came about after writing a small TUI to allow a friend to back up their entire Vimeo library, and finding that while they enjoyed the simplicity and speed of the TUI, they did not like having to use the shell to get there, nor did they want to install a terminal like Ghostty for a better experience.</p><p>Trolley makes it easy to package apps for that kind of person. It's still very early. The CLI is decent for an alpha state, as it's more my area. The runtime code is new to me, but thankfully much of it is based around Ghostty's GUIs so I made it work with a bit of AI help.</p><p>Let me know what you think!</p>",
      "contentLength": 772,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rgloz5/trolley_run_terminal_apps_anywhere_pairs_well/"
    },
    {
      "title": "[R] ContextCache: Persistent KV Cache with Content-Hash Addressing ‚Äî 29x TTFT speedup for tool-calling LLMs",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rglj2n/r_contextcache_persistent_kv_cache_with/",
      "date": 1772232477,
      "author": "/u/PlayfulLingonberry73",
      "guid": 49026,
      "unread": true,
      "content": "<p>We present ContextCache, a persistent KV cache system for tool-calling LLMs that eliminates redundant prefill computation for tool schema tokens.</p><p>Motivation: In tool-augmented LLM deployments, tool schemas (JSON function definitions) are prepended to every request but rarely change between calls. Standard inference re-processes these tokens from scratch each time.</p><p>Approach: We cache the KV states produced during the initial prefill of tool schemas, indexed by a content hash (SHA256 of sorted schema texts). On subsequent requests with the same tool set, we restore cached KV states and only run forward pass on the user query suffix.</p><p>Key finding: Per-tool independent caching fails catastrophically (tool selection accuracy drops from 85% to 10%) because models rely on cross-tool attention during prefill. Group caching ‚Äî caching all tools as a single block ‚Äî preserves full-prefill quality exactly across seen, held-out, and unseen tool splits.</p><p>Results (Qwen3-8B, 4-bit NF4):</p><p>Cached TTFT remains constant (~200ms) from 5 to 50 tools</p><p>Full prefill grows from 466ms to 5,625ms over the same range</p><p>29x speedup at 50 tools, with 99% of prompt tokens skipped per request</p><p>Zero quality degradation: group_cached matches full_prefill on TSA, PF1, and EM across all evaluation splits</p><p>Limitations: Eager attention causes OOM at 75+ tools on 24GB GPU. Flash attention integration would extend the practical range.</p>",
      "contentLength": 1403,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "context-logger - Structured context propagation for log crate, something missing in Rust logs",
      "url": "https://github.com/alekseysidorov/context-logger",
      "date": 1772232078,
      "author": "/u/AlekseySidorov",
      "guid": 49192,
      "unread": true,
      "content": "<p>Hi All, I am glad to release a new version of my library. It makes it easy to attach key value context to your logs without boilerplate</p><p>```rust use context_logger::{ContextLogger, LogContext}; use log::info;</p><p>fn main() { let env_logger = env_logger::builder().build(); let max_level = env_logger.filter(); ContextLogger::new(env_logger) .default_record(\"version\", \"0.1.3\") .init(max_level);</p><pre><code>let ctx = LogContext::new() .record(\"request_id\", \"req-123\") .record(\"user_id\", 42); let _guard = ctx.enter(); info!(\"handling request\"); // version, request_id, user_id included </code></pre>",
      "contentLength": 566,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/rust/comments/1rgld2c/contextlogger_structured_context_propagation_for/"
    },
    {
      "title": "A new California law says all operating systems, including Linux, need to have some form of age verification at account setup",
      "url": "https://x.com/LundukeJournal/status/2026783141298360692",
      "date": 1772231509,
      "author": "/u/ANiceGobletofTea",
      "guid": 49020,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rgl4hy/a_new_california_law_says_all_operating_systems/"
    },
    {
      "title": "Trump orders federal agencies to stop using Anthropic AI tech ‚Äòimmediately‚Äô",
      "url": "https://www.reddit.com/r/artificial/comments/1rgkegx/trump_orders_federal_agencies_to_stop_using/",
      "date": 1772229805,
      "author": "/u/ValueInvestingIsDead",
      "guid": 49001,
      "unread": true,
      "content": "<li><p>President Donald Trump ordered U.S. government agencies to ‚Äúimmediately cease‚Äù using technology from the artificial intelligence company Anthropic.</p></li><li><p>The AI startup faces pressure by the Defense Department to comply with demands that it can use the company‚Äôs technology without restrictions sought by Anthropic.</p></li><li><p>The company wants the Pentagon to assure it that the AI models will not be used for fully autonomous weapons or mass domestic surveillance of Americans.</p></li><li><p>Another major AI company, OpenAI, said it has the same ‚Äúred lines‚Äù as Anthropic regarding the use of its technology by the Pentagon and other customers.</p></li><li><p>The president also said there would be a six-month phase-out for agencies such as the Defense Department, which ‚Äúare using Anthropic‚Äôs products, at various levels.‚Äù</p></li>",
      "contentLength": 792,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "My first ever Linux installation.",
      "url": "https://www.reddit.com/r/linux/comments/1rgk4qd/my_first_ever_linux_installation/",
      "date": 1772229185,
      "author": "/u/FriesWithMacSauce",
      "guid": 49003,
      "unread": true,
      "content": "<p>I own a pawn shop and have a whole wall of Windows laptops for dirt cheap and I can‚Äôt get rid of them. So I‚Äôm doing an experiment. I installed Linux onto this cheap Dell and I‚Äôm going to try and sell it for $75. I‚Äôve never used Linux before, I‚Äôm an Apple user. But I gotta say in comparison to Windows 10/11, Ubuntu is truly a breath of fresh air. So snappy and light weight. I feel like this computer has been rescued and is ready to live a second life instead of going to the landfill. </p>",
      "contentLength": 498,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Anyone running production Redis on without Bitnami images/charts now?",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rgjuxu/anyone_running_production_redis_on_without/",
      "date": 1772228553,
      "author": "/u/dkargatzis_",
      "guid": 49005,
      "unread": true,
      "content": "<p>I was a long-time user of the Bitnami Redis Helm chart. When Broadcom sunsetted the free Bitnami images in 2025 and moved everything to the unsupported bitnamilegacy registry (no more updates or security patches), I switched to the legacy images as a temporary workaround.</p><p>Now I'm looking for a permanent, actively maintained, ideally free / open-source solution: </p><p>- a solid Helm chart (or lightweight operator if it's better) - preferably uses official redis Docker images (or equally trusted free ones)<p> - good support for persistence, scaling, monitoring (Prometheus), TLS, etc.</p> - bonus points for HA (Sentinel + failover), I don't strictly need full sharded Redis Cluster unless someone strongly recommends it</p><p>What are you all using in production? Any charts / operators you can recommend that feel \"set it and forget it\" for long term?</p>",
      "contentLength": 836,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Fastest way to remove duplicate UUIDS from a list",
      "url": "https://www.reddit.com/r/golang/comments/1rgjhat/fastest_way_to_remove_duplicate_uuids_from_a_list/",
      "date": 1772227692,
      "author": "/u/Fun-Result-8489",
      "guid": 49175,
      "unread": true,
      "content": "<p>Lets say that you have an array of UUIDS and you want to remove all the duplicates. </p><p>Obviously what you can do is to create a  nested in another  and check for each element if it exists more than once in the list. </p><p>I thought that this might not be ideal performance wise, so I came up with another simple plan. While you iterate the list, you populate a map that has as a key the UUID of that specific entry. If the key is present obviously you know that this is a duplicate! Izi pizy. </p><p>So I was wondering whether something like that is a common practice to deal with such a problem. Is there any big issue with that solution that I should be aware of ? Or is there any better solution for that problem ?</p>",
      "contentLength": 701,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Autocomplete for types from unimported packages (like GoLand)",
      "url": "https://www.reddit.com/r/golang/comments/1rgj71y/autocomplete_for_types_from_unimported_packages/",
      "date": 1772227023,
      "author": "/u/Hot_Perspective_5931",
      "guid": 48980,
      "unread": true,
      "content": "<p>I‚Äôm having an issue with code completion in  (LSP) and was hoping someone could help.</p><p>For example, in one package:</p><pre><code>package model type Price struct { bid float64 ask float64 } </code></pre><pre><code>package usage func test() { Pri... } </code></pre><p>In this case, I‚Äôd like  to appear in the completion suggestions even though the  package hasn‚Äôt been imported yet.</p><p>Right now,  only shows up after I manually type  and import the package. In GoLand, I really like that it suggests symbols from unimported packages automatically and adds the import for me.</p><p>I‚Äôve tried enabling options like  and fuzzy matching in , but I haven‚Äôt been able to get the same behavior in Neovim.</p><p>Is there any way to achieve GoLand-like auto-completion for unimported packages using gopls in Neovim?</p>",
      "contentLength": 742,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Rust or Zig for small WASM numerical compute kernels?",
      "url": "https://www.reddit.com/r/rust/comments/1rgi2mh/rust_or_zig_for_small_wasm_numerical_compute/",
      "date": 1772224438,
      "author": "/u/dupontcyborg",
      "guid": 49113,
      "unread": true,
      "content": "<p>Hi <a href=\"https://www.reddit.com/r/rust\">r/rust</a>! I'm building <a href=\"https://github.com/dupontcyborg/numpy-ts\">numpy-ts</a>, a NumPy-like numerical lib in TypeScript. I just tagged 1.0 after reaching 94% coverage of NumPy's API.</p><p>I'm now evaluating WASM acceleration for compute-bound hot paths (e.g., linalg, sorting, etc.). So I prototyped identical kernels in both Zig and Rust targeting wasm32 with SIMD128 enabled.</p><p>The results were interesting: performance and binary sizes are essentially identical (~7.5 KB gzipped total for 5 kernel files each). Both compile through LLVM, so I  the WASM output is nearly the same.</p><ul><li>Deeper ecosystem if we ever need exotic math (erf, gamma, etc.)</li><li>Much wider developer adoption which somewhat de-risks a project like this</li></ul><ul><li>`@setFloatMode(.optimized)` lets LLVM auto-vectorize reductions without hand-writing SIMD</li><li>Vector types (`@Vector(4, f64)`) are more ergonomic than Rust's `core::arch::wasm32` intrinsics</li><li>No unsafe wrapper for code that's inherently raw pointer math (which feels like a waste of Rust's borrow-checker)</li></ul><p>I'm asking <a href=\"https://www.reddit.com/r/zig\">r/zig</a> a similar question, but for those of you who chose Rust for WASM applications, what else should I think about?</p>",
      "contentLength": 1088,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Anyone here still running Linux on an Apple TV?",
      "url": "https://www.reddit.com/r/linux/comments/1rghu6g/anyone_here_still_running_linux_on_an_apple_tv/",
      "date": 1772223915,
      "author": "/u/L0stG33k",
      "guid": 48966,
      "unread": true,
      "content": "<p>Took a bit more fuss than a standard PC... but finally got it slimmed down and running on a modern distro. Popped out the wifi card, and she idles at a mere 12W from the wall socket. I'm having fun with it. Anyone still using one of these as a media box, seed box, server, ?</p><p>For those who don't already know, the original Apple TV Gen 1 was just an intel PC. Kind of like an ultra cheap version of the Intel Mac Mini. But it doesn't use a PC BIOS (or standard EFI for that matter), so you need a mach kernel to bootstrap any alt OS you intend to run.</p><p>Specs: Intel Pentium M 1 GHz GeForce Mobile 10/100 MB Ethernet Built-in 5V PSU</p><p>Kinda funny, this is running the same OS as my server, but with 1/128th the ram.</p>",
      "contentLength": 707,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "[D] Edge AI Projects on Jetson Orin ‚Äì Ideas?",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rghtsb/d_edge_ai_projects_on_jetson_orin_ideas/",
      "date": 1772223886,
      "author": "/u/___loki__",
      "guid": 48967,
      "unread": true,
      "content": "<p>I‚Äôve got access to a bunch of NVIDIA Jetson Orins through my lab and I want to do something cool and deployable. For context, I‚Äôve previously built a small language model (SLM) from scratch and have experience in real-time ML pipelines, computer vision, anomaly detection, and explainable AI. I‚Äôve also deployed AI models on edge devices for real-time monitoring systems.</p><p>I‚Äôm looking for ideas/ research areas that could get me hired tbh, and relevant for industry or research, ideally something that demonstrates strong AI-ML + deployment skills and can stand out on a resume.</p><p>Any creative, ambitious, or edge-focused suggestions would be amazing! Thanks in Advance:)</p>",
      "contentLength": 674,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Software engineers should be a little bit cynical",
      "url": "https://www.seangoedecke.com/a-little-bit-cynical/",
      "date": 1772219856,
      "author": "/u/fagnerbrack",
      "guid": 48968,
      "unread": true,
      "content": "<blockquote><p>I have no doubt that [Sean‚Äôs] advice is quite effective for navigating the upper levels of an organization dedicated to producing a large, mature software product. But what is lost is any sort of conception of value. Is it too naive to say that engineers are more than ‚Äútools in a political game‚Äù, they are specialized professionals whose role is to apply their expertise towards solving meaningful problems?</p></blockquote><blockquote><p>The irony is that this kind of thinking destroys a company‚Äôs ability to actually make money ‚Ä¶ the idea that engineers should begin with a self-conception of doing what their manager tells them to is, to me, very bleak. It may be a good way to operate smoothly within a bureaucratic organization, and of course, one must often make compromises and take direction, but it is a bad way to do good work.</p></blockquote><p>I can see why people would think this way. But I  working in big tech companies! I do see myself as a professional solving meaningful problems. And I think navigating the organization to put real features or improvements in the hands of users is an excellent way - maybe the best way - to do good work.</p><p>Why do I write such cynical posts, then? Well, I think that a small amount of cynicism is necessary in order to think clearly about how organizations work, and to avoid falling into the trap of being overly cynical. In general, I think <strong>good engineers ought to be a little bit cynical</strong>.</p><h3>The idealist view is more cynical than idealists think</h3><p>One doctrinaire ‚Äúidealist‚Äù view of software engineering goes something like this. I‚Äôm obviously expressing it in its most lurid form, but I do think many people believe this more or less literally:</p><blockquote><p>We live in a late-stage-capitalist hellscape, where large companies are run by aspiring robber barons who have no serious convictions beyond desiring power. All those companies want is for obedient engineering drones to churn out bad code fast, so they can goose the (largely fictional) stock price. Meanwhile, end-users are left holding the bag: paying more for worse software, being hassled by advertisements, and dealing with bugs that are unprofitable to fix. The only thing an ethical software engineer can do is to try and find some temporary niche where they can defy their bosses and do real, good engineering work, or to retire to a hobby farm and write elegant open-source software in their free time.</p></blockquote><p>When you write it all out, I think it‚Äôs clear to see that this is  cynical. At the very least, it‚Äôs a cynical way to view your coworkers and bosses, who are largely people like you: doing a job, balancing a desire to do good work with the need to please their own bosses. It‚Äôs a cynical way to view the C-staff of a company. I think it‚Äôs also inaccurate: from my limited experience, the people who run large tech companies really do want to deliver good software to users.</p><p>It‚Äôs idealistic only in the sense that it does not accept the need for individual software engineers to compromise. According to this view,  never need to write bad software. No matter how hard the company tells you to compromise and just get something out, you‚Äôre morally required to plant your feet and tell them to go to hell. In fact, by doing so, you‚Äôre taking a stand against the general degeneration of the modern software world. You‚Äôre protecting - unsung, like Batman - the needs of the end-user who will never know you exist.</p><p>I can certainly see the appeal of this view! But I don‚Äôt think it‚Äôs an  appeal. It comes from seeing the world as fundamentally corrupted and selfish, and believing that real positive change is impossible. In other words, <strong>I think it‚Äôs a  appeal.</strong></p><h3>The cynical view is more idealistic than idealists think</h3><p>I don‚Äôt see a hard distinction between engineers being ‚Äútools in a political game‚Äù and professionals who solve meaningful problems. In fact, I think that in practice <strong>almost all meaningful problems are solved by playing political games</strong>.</p><p>There are very few problems that you can solve entirely on your own. Software engineers encounter more of these problems than average, because the nature of software means that a single engineer can have huge leverage by sitting down and making a single code change. But in order to make changes to large products - for instance, to make it possible for GitHub‚Äôs 150M users to <a href=\"https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions\">use LaTeX in markdown</a> - you need to coordinate with many other people at the company, which means you need to be involved in politics.</p><p>It is just a plain fact that software engineers are not the movers and shakers in large tech organizations. They do not set the direction of the company. To the extent that they have political influence, it‚Äôs in how they translate the direction of the company into specific technical changes. But <strong>that is actually quite a lot of influence!</strong></p><p>Large tech companies serve hundreds of millions (or billions) of users. Small changes to these products can have a massive positive or negative effect in the aggregate. As I see it, choosing to engage in the messy, political process of making these changes - instead of washing your hands of it as somehow impure - is an act of idealism. </p><p>I think the position of a software engineer in a large tech company is similar to people who go into public service: idealistically hoping that they can do some good, despite knowing that they themselves will never set the broad strokes of government policy.</p><p>Of course, big-tech software engineers are paid far better, so many people who go into this kind of work in fact are purely financially-motivated cynics. But I‚Äôm not one of them! I think it‚Äôs possible, by doing good work, to help steer the giant edifice of a large tech company for the better.</p><p>Cynical writing is like most medicines: the dose makes the poison. A healthy amount of cynicism can serve as an inoculation from being overly cynical.</p><p>If you don‚Äôt have an slightly cynical explanation for why engineers write bad code in large tech companies - such as the one I write about <a href=\"https://www.seangoedecke.com/bad-code-at-big-companies\">here</a> - you risk adopting an overly cynical one. For instance, you might think that big tech engineers are being <a href=\"https://news.ycombinator.com/item?id=46082989\">deliberately demoralized</a> as part of an anti-labor strategy to prevent them from unionizing, which is nuts. Tech companies are simply not set up to engage in these kind of conspiracies.</p><p>If you don‚Äôt have a slightly cynical explanation for why large tech companies sometimes make inefficient decisions - such as <a href=\"https://www.seangoedecke.com/seeing-like-a-software-company\">this one</a> - you risk adopting an overly cynical one. For instance, you might think that tech companies are full of incompetent <a href=\"https://news.ycombinator.com/item?id=46133179\">losers</a>, which is simply not true. Tech companies have a normal mix of strong and <a href=\"https://www.seangoedecke.com/weak-engineers\">weak engineers</a>.</p><p><strong>Idealist writing is massively over-represented in writing about software engineering</strong>. There is no shortage of books or blog posts (correctly) explaining that we ought to value good code, that we ought to be kind to our colleagues, that we ought to work on projects with positive real-world impact, and so on. There  a shortage of writing that accurately describes how big tech companies operate.</p><p>Of course, cynical writing can harm people: by making them sad, or turning them into bitter cynics. But <strong>idealist writing can harm people too</strong>. There‚Äôs a whole generation of software engineers who came out of the 2010s with a  model of how big tech companies work, and who are effectively being fed into the woodchipper in the 2020s. They would be better off if they internalized a correct model of how these companies work: not just less likely to get into trouble, but better at achieving their own idealist goals.</p><p>edit: this post got some traction on <a href=\"https://news.ycombinator.com/item?id=46414723\">Hacker News</a>, with many comments. Some <a href=\"https://news.ycombinator.com/item?id=46415077\">commenters</a> said that it‚Äôs incoherent to say ‚Äúwhat I do is good, actually‚Äù when my employer is engaged in various unethical activity. Fair enough! But this post isn‚Äôt about whether it‚Äôs ethical to work for Microsoft or not. It‚Äôs a followup to <a href=\"https://www.seangoedecke.com/bad-code-at-big-companies\"><em>How good engineers write bad code at big companies</em></a> - the main cynicism I‚Äôm interested in here is not ‚Äúbig tech is evil‚Äù, but ‚Äúbig tech is incompetent‚Äù.</p><p>Some <a href=\"https://news.ycombinator.com/item?id=46415535\">other</a><a href=\"https://news.ycombinator.com/item?id=46414906\">commenters</a> challenged my claim that C-staff want to deliver good software by pointing out that they‚Äôre not willing to trade off their personal success to do so. Sure, I agree with that. The kind of person willing to sacrifice their career for things doesn‚Äôt typically make it to a C-level position. But it‚Äôs not always zero-sum. Good software makes money for software companies, after all.</p><p>I also saw two commenters link <a href=\"https://en.wikipedia.org/wiki/High-Tech_Employee_Antitrust_Litigation\">this</a> as an example of big tech companies actually being engaged in conspiracies against their employees. I‚Äôm not convinced. Companies  structurally set up to collude on salaries, but they‚Äôre not set up to deliberately make their employees sad - they just don‚Äôt have that kind of fine-grained control over the culture! To the extent they have any control, they try to make their employees happy so they‚Äôll work for less money and not leave.</p>",
      "contentLength": 8909,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgg1wr/software_engineers_should_be_a_little_bit_cynical/"
    },
    {
      "title": "Signed distance field fonts",
      "url": "https://www.redblobgames.com/articles/sdf-fonts/",
      "date": 1772219360,
      "author": "/u/ketralnis",
      "guid": 49058,
      "unread": true,
      "content": "<section><p>The normal way to render fonts is to read a font file containing  paths, then render those paths to the screen. These fonts support the full set of characters, sizes, and effects. Many games will pre-render the fonts to  form, but this limits the set of characters, sizes, and effects. A  () texture can be used as an intermediate format between the original vector font and fonts pre-rendered to bitmaps. It allows all sizes but not all characters or effects.</p><p>Rendering a resized bitmap font leads to blurry or jagged edges:</p><figure></figure><p>Rendering a resized distance field font leads to smooth edges:</p><figure><figcaption>Resizing a distance field font</figcaption></figure><p>We don‚Äôt have to  the resized distance field. It is generated implicitly by the GPU fragment shader, for ‚Äúfree‚Äù. We can use a single low resolution distance field to generate high resolution output at any size. <strong>That‚Äôs the magic of SDF fonts</strong>!</p><p>SDF <strong>is not always the best choice</strong> for fonts. I‚Äôve attempted to summarize the pros and cons:</p><table><tbody><tr></tr><tr></tr><tr></tr><tr></tr></tbody></table><ul><li>note: there are newer GPU-accelerated font rendering systems that use the vectors. I have not yet explored these.</li></ul><p><strong>On this page I‚Äôll show how I use msdfgen with WebGL.</strong></p></section><section><p>We can think of a signed distance field as a ‚Äúheight map‚Äù in a landscape. The area above the water will be filled in. The area by the coastline will become the border color. The area underwater can be transparent, but could be used for glow, shadow, or other effects.</p><figure><figcaption>Landscape view of a signed distance field</figcaption></figure></section><section><p>The SDF texture contains distances encoded as 0‚Äì255. In msdfgen, 255 is ‚Äúinside‚Äù the font and 0 is ‚Äúoutside‚Äù:</p><figure><figcaption>A single glyph‚Äôs distance field</figcaption></figure><p>To render the distance map to a glyph, we first interpret the 0‚Äì255 values as a signed distance. I‚Äôve chosen to use distances in ‚Äúem‚Äù units. <em>I am reversing the direction</em> so that high values are outside and low values are inside, the same as <a href=\"https://iquilezles.org/articles/distfunctions/\">Inigo Quilez‚Äôs convention</a>. I have found that the reverse direction makes thickness, outline, and glow calculations easier.</p><figure><figcaption>100*distance_em at each point</figcaption></figure><p>In msdfgen, the  parameter sets the distance range in ‚Äúem‚Äù units, so I‚Äôll use that to map 0 to the high value (+5%) and 255 to the low value (-5%):</p><table><thead><tr></tr></thead><tbody></tbody></table><p>We can either remember the values we passed to  or we can recover it from msdfgen‚Äôs JSON export. I haven‚Äôt studied other SDF font libraries to see how they store this information.</p><ul><li> = <code>(atlas.distanceRangeMiddle - atlas.distanceRange/2) / atlas.size</code></li><li> = <code>(atlas.distanceRangeMiddle + atlas.distanceRange/2) / atlas.size</code></li></ul><p>The simplest thing is to draw pixels with <code>distance_em &lt; threshold_em</code>:</p><p>Here‚Äôs an implementation in a fragment shader:</p><div><pre> 300 es\nprecision ;\n;\n; ;\n\n;\n;\n() {\n   = (u_atlas, v_st).r;\n   = (u_aemrange[1], u_aemrange[0], texel);\n  o_frag_color = (distance_em &lt; u_threshold_em ? 1.0 : 0.0);\n}\n</pre></div><p>How do we set the uniform values?</p><dl><dd>Use . These represent the distances at pixel=0 and pixel=255.</dd><dd>I recommend . Increase this (e.g. by +0.01) to make the font thicker.</dd></dl><p>We‚Äôll use other threshold values later to place outlines, shadows, and glow effects.</p><p>To add antialiasing, we can go smoothly instead of abruptly from 0 to 1 using a transition. Think of the ‚Äúcurves‚Äù tool in an image editor. <strong>Move the width slider to 0</strong> to see how it looks with a hard threshold:</p><p>When distance is  we want opacity 1.0. When distance is  we want opacity 0.0. That‚Äôs a straight line with slope of -1/width. The formula works out as . Then we clamp opacity to 0.0‚Äì1.0. Here‚Äôs a shader implementation, avoiding the divide by multiplying by 1/width instead:</p><div><pre> 300 es\nprecision ;\n;\n;\n;\n;\n;\n;\n\n() {\n   = (u_atlas, v_st).r;\n   = (u_aemrange[1], u_aemrange[0], texel);\n   = u_screen_px_scale * u_antialias_per_em;\n   = ((u_threshold_em - distance_em) * inverse_width + 0.5, 0.0, 1.0);\n  o_frag_color = u_color * opacity; }\n</pre></div><p>How do we set the uniform values?</p><dl><dd>This value represents how much antialiasing happens per ‚Äúem‚Äù distance. I recommend antialiasing over 1 . We need to convert that to ‚Äúem‚Äù units, and we also need to factor in any scaling between the GL pixel size and the screen size (e.g. FSR/DLSS, or render to texture). In msdfgen, set the uniform to .</dd><dd><ol><li><p>If you know the size of the output text (common in 2D), calculate the width ahead of time on the CPU and pass it in as a uniform. In msdfgen, pick  glyph that contains  and , and calculate:</p><div><pre> = atlas.glyphs.find((g) =&gt; g.atlasBounds &amp;&amp; g.planeBounds);\n = glyph.atlasBounds.right - glyph.atlasBounds.left;\n = (glyph.planeBounds.right - glyph.planeBounds.left) *\n                   gl.canvas.width * fontSize;\n = outputSizePx / inputSizePx;\n</pre></div><p>We can further optimize the shader by passing in  as a uniform.</p></li><li><div><pre>() {\n   = ((u_atlas, 0));\n   = (v_st);\n   = atlas_size * gradient;\n  (0.5 * (atlas_size, gradient) / (product.x * product.y), 1.0);\n}\n</pre></div></li></ol></dd></dl><p><em>Tweaking antialiasing feels like a ‚Äúdark art‚Äù to me.</em> I‚Äôve collected some notes in the <a href=\"https://www.redblobgames.com/articles/sdf-fonts/appendix.html#antialiasing\">appendix</a>.</p><p>Valve‚Äôs 2007 paper about SDF font rendering shows how to use a single distance field to represent fonts. A single distance field will have rounded corners. We can sharpen corners by increasing the resolution of the texture, but a better way is to use multiple signed distance fields (MSDF). The msdfgen library generates three distance fields and stores them in the red, green, and blue channels of the texture. When running , use  instead of .</p><p>In the <a href=\"https://www.redblobgames.com/articles/sdf-fonts/appendix.html#msdf\">appendix</a> I show more comparison screenshots at different resolutions, including examples where a single distance field looks nicer than multiple distance fields. I especially prefer the single distance field for glow and shadow effects. Each font + distance range behaves differently at different sizes, so <strong>I recommend comparing with your choice of font</strong>.</p><p>In the shader, SDF and MSDF are similar. Following the <a href=\"https://github.com/Chlumsky/msdfgen\">msdfgen page</a>, replace</p><div><pre>() {\n   = (u_atlas, v_st).r;\n  ‚Ä¶\n}\n</pre></div><div><pre>() {\n  ((rgb.r, rgb.g), ((rgb.r, rgb.g), rgb.b));\n}\n\n() {\n   = median((u_atlas, v_st).rgb);\n  ‚Ä¶\n}\n</pre></div></section><section><p>So far we‚Äôve covered how to render a single character. To render a string, we‚Äôll need two more ingredients:</p><ol><li>. This is a single ‚Äúsprite sheet‚Äù image that contains all the characters we might want to use in a bitmap or SDF font.</li><li>. This calculates the location on screen for each character in the string. Also called ‚Äú<a href=\"https://en.wikipedia.org/wiki/Text_shaping\">text shaping</a>‚Äù.</li></ol><p>Some libraries will calculate a single character‚Äôs SDF, and leave you to generate the atlas using your own sprite sheet / font atlas generator. I used  which generates both the SDF and the atlas at the same time. It stores the atlas texture coordinates in .</p><p>The layout in many Western alphabets is left to right on each line. There‚Äôs a ‚Äúbaseline‚Äù y value and a ‚Äúcursor‚Äù x value. After each character, we advance the cursor to the right. At the end of the line, we move the cursor back to the left an dincrease the y value. But many languages don‚Äôt work the same way. For full layout across languages, consider using <a href=\"https://harfbuzz.github.io/harfbuzzjs/\">HarfBuzz</a>.</p><p>The <a href=\"https://www.redblobgames.com/articles/sdf-fonts/appendix.html#using-msdfgen\">appendix</a> has more implementation details when using msdfgen.</p></section><section><p>The 2007 work is much simpler and easier to implement on GPUs. However it suffers from rounded corners, and recommends multiple channels to get sharp corners. The later work is from 2016: Chlumsky not only wrote an amazing thesis about calculating and storing multiple distance the red/green/blue channels (not adaptive, and no voronoi), he wrote an open source <a href=\"https://github.com/Chlumsky/msdfgen\">msdfgen</a> library that implemented the algorithm.</p><p>This page was getting long so I‚Äôve put some partially organized notes into an <a href=\"https://www.redblobgames.com/articles/sdf-fonts/appendix.html\">appendix</a> page.</p></section>",
      "contentLength": 7387,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgfu27/signed_distance_field_fonts/"
    },
    {
      "title": "[Media] My Rust-based Git Client evolved into a full \"Developer Hub\" (HTTP Client, Mock Data Gen & Monaco Editor built-in)",
      "url": "https://www.reddit.com/r/rust/comments/1rgff2e/media_my_rustbased_git_client_evolved_into_a_full/",
      "date": 1772218445,
      "author": "/u/gusta_rsf",
      "guid": 48957,
      "unread": true,
      "content": "<p>A few months ago, I shared  here, a performant desktop Git client I built using Rust (Tauri) to escape heavy Electron wrappers. The feedback was incredibly helpful, but while using it daily, I noticed a lingering workflow issue: the constant context-switching. I was still alt-tabbing between my Git GUI, Postman, DB seeders, and a separate editor just to resolve simple conflicts or test an endpoint.</p><p>So, I decided to expand the scope. ArezGit has officially evolved from just a version control tool into a unified , built to eliminate that friction.</p><p><strong>The Tech Stack remains snappy:</strong></p><ul><li> Rust (handling heavy lifting, generation engines, and  bindings).</li><li> React + TypeScript + Styled Components.</li><li> Tauri for seamless, memory-efficient IPC.</li></ul><p><strong>What‚Äôs new in this evolution:</strong></p><ul><li> Test your REST APIs directly inside your repository workspace. Support for custom headers, auth tokens, query params, and raw/form-data payloads.</li><li><strong>High-Performance Mock Data Generator:</strong> Visually build data schemas (UUIDs, names, emails, dates, etc) and let the Rust engine generate and export up to 1,000,000 rows to JSON, CSV, or raw SQL inserts.</li><li><strong>Native Monaco Code Editor:</strong> Edit files without leaving the app. Powered by the same engine as VS Code, featuring a multi-tab environment.</li><li><strong>Visual Conflict Resolver:</strong> A Monaco-based 3-way merge tool to handle \"Ours vs Theirs\" without the headache.</li><li> Built-in Pomodoro timer, stopwatch, and a local task/notes manager inherently linked to your active project context.</li></ul><p>The app is packaged for  () and  (), with the macOS (Apple Silicon &amp; Intel) build actively in the pipeline.</p><p>It is still <strong>100% Free for public repositories</strong> and open-source work (which includes access to the core Git features, the visual graph, and the Dev Hub tools).</p><p>I built this to scratch my own itch for a distraction-free, high-performance environment, and I'd love to hear your thoughts on this \"all-in-one\" approach.</p>",
      "contentLength": 1882,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Aks cost analysis doubt",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rgf90m/aks_cost_analysis_doubt/",
      "date": 1772218077,
      "author": "/u/dqdevops",
      "guid": 48958,
      "unread": true,
      "content": "<p>I have a question. Aks uses vmss as nodepools. does Aks cost analysis add on can be used to calculate all costs that the vmss will have. my question is if it takes in consideration when the vmss is not being used and so on. I have a big discrepancy between the Aks cost analysis price and the price I had to pay of that vmss. I guess I‚Äôm looking for a guide for having all the costs included (idle and unalocatted), or if this tool is not for this purpose.</p><p>if you share documentation would be great!</p>",
      "contentLength": 500,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "How do I get to know in advance how far back I can go for the glibc version that can be used as the sysroot to build a modern compiler toolchain from source like GCC-16?",
      "url": "https://www.reddit.com/r/linux/comments/1rgf5ml/how_do_i_get_to_know_in_advance_how_far_back_i/",
      "date": 1772217871,
      "author": "/u/emfloured",
      "guid": 49090,
      "unread": true,
      "content": "<p>{Update}: My bad I could not be explicit about this. The goal here is to produce the most modern C++ compiler (the g++ executable + libstdc++.a) and this compiler should be able to produce binaries that should be able to run on oldest possible Linux OS. g++ manual shows --sysroot flag. If I am not wrong then this is the thing that allows me to set the path to glibc root directory of the version I want (for maximum ABI compatibility this will be the same glibc that is used to build the GCC compiler itself).</p><p>The goal here is to build the cutting edge C++26 capable GCC compiler from source that can generate an executable that targets the oldest possible glibc runtime.</p><p>There doesn't seem to be any docs in the gcc-trunk that tells you about this. GNU's official website also doesn't have this kind of information anywhere.</p><p>I mean it's fair to assume that the  at the time of this post (some C++26) most likely can not be built with the glibc as its sysroot from year 1994 or even 2006.</p><p>So what is the minimum number here? What is the proper way to know this?<p> Is the trial-and-error; trying to build GCC using many older glibc versions the only way to know this what works or doesn't?</p></p><p>Something tells me that the hacky methods to look at the glibc symbols version using ,  etc isn't the most reliable way, unless somebody tells me that IT IS the only way.</p>",
      "contentLength": 1354,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Meetup Go & Robotics in Arcueil (south Paris) 11th march",
      "url": "https://golangfranca.org/en/news/rencontre-edge-golang-robotique-11-mars-2026/",
      "date": 1772217490,
      "author": "/u/golangparis",
      "guid": 48956,
      "unread": true,
      "content": "<div>\nAs robots leave the laboratory to move into warehouses, hospitals and industrial sites, a strategic question emerges: which language and system to pilot a distributed, connected and mission-critical fleet?\n</div><p>This question will be addressed on the evening of Wednesday March 11 during the next Golang Paris meetup in partnership with <a href=\"https://www.openstreetmap.org/node/13536461411#map=15/48.81263/2.34657\">MOVU Robotics</a>, as part of the <a href=\"https://golangfranca.org/en/news/field-day-golang-robotique-11-mars-2026/\">Field Day Go &amp; Robotics</a> day.</p><img src=\"https://golangfranca.org/images/gophers_on_the_edge.jpg\" width=\"100%\"><div><ul></ul></div>",
      "contentLength": 390,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rgez34/meetup_go_robotics_in_arcueil_south_paris_11th/"
    },
    {
      "title": "Good on Anthropic for declining the Pentagon deal",
      "url": "https://www.reddit.com/r/artificial/comments/1rgdx5q/good_on_anthropic_for_declining_the_pentagon_deal/",
      "date": 1772215180,
      "author": "/u/Bubbly-Air7302",
      "guid": 48935,
      "unread": true,
      "content": "<div><p>shame on Sam Altman for putting users‚Äô security at risk by trying to finagle a deal now. #TheRealAmericanPsycho</p></div>   submitted by   <a href=\"https://www.reddit.com/user/Bubbly-Air7302\"> /u/Bubbly-Air7302 </a>",
      "contentLength": 150,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Allocating on the Stack (go)",
      "url": "https://go.dev/blog/allocation-optimizations",
      "date": 1772214772,
      "author": "/u/ketralnis",
      "guid": 49004,
      "unread": true,
      "content": "<p>We‚Äôre always looking for ways to make Go programs faster. In the last\n2 releases, we have concentrated on mitigating a particular source of\nslowness, heap allocations. Each time a Go program allocates memory\nfrom the heap, there‚Äôs a fairly large chunk of code that needs to run\nto satisfy that allocation. In addition, heap allocations present\nadditional load on the garbage collector.  Even with recent\nenhancements like <a href=\"https://go.dev/blog/greenteagc\">Green Tea</a>, the garbage collector\nstill incurs substantial overhead.</p><p>So we‚Äôve been working on ways to do more allocations on the stack\ninstead of the heap.  Stack allocations are considerably cheaper to\nperform (sometimes completely free).  Moreover, they present no load\nto the garbage collector, as stack allocations can be collected\nautomatically together with the stack frame itself. Stack allocations\nalso enable prompt reuse, which is very cache friendly.</p><h2>Stack allocation of constant-sized slices</h2><p>Consider the task of building a slice of tasks to process:</p><pre><code>func process(c chan task) {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>Let‚Äôs walk through what happens at runtime when pulling tasks from the\nchannel  and adding them to the slice .</p><p>On the first loop iteration, there is no backing store for , so\n has to allocate one. Because it doesn‚Äôt know how big the\nslice will eventually be, it can‚Äôt be too aggressive. Currently, it\nallocates a backing store of size 1.</p><p>On the second loop iteration, the backing store now exists, but it is\nfull.  again has to allocate a new backing store, this time of\nsize 2. The old backing store of size 1 is now garbage.</p><p>On the third loop iteration, the backing store of size 2 is\nfull.  has to allocate a new backing store, this time\nof size 4. The old backing store of size 2 is now garbage.</p><p>On the fourth loop iteration, the backing store of size 4 has only 3\nitems in it.  can just place the item in the existing backing\nstore and bump up the slice length. Yay! No call to the allocator for\nthis iteration.</p><p>On the fifth loop iteration, the backing store of size 4 is full, and\n again has to allocate a new backing store, this time of size\n8.</p><p>And so on. We generally double the size of the allocation each time it\nfills up, so we can eventually append most new tasks to the slice\nwithout allocation. But there is a fair amount of overhead in the\n‚Äústartup‚Äù phase when the slice is small. During this startup phase we\nspend a lot of time in the allocator, and produce a bunch of garbage,\nwhich seems pretty wasteful. And it may be that in your program, the\nslice never really gets large. This startup phase may be all you ever\nencounter.</p><p>If this code was a really hot part of your program, you might be\ntempted to start the slice out at a larger size, to avoid all of these\nallocations.</p><pre><code>func process2(c chan task) {\n    tasks := make([]task, 0, 10) // probably at most 10 tasks\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>This is a reasonable optimization to do. It is never incorrect; your\nprogram still runs correctly. If the guess is too small, you get\nallocations from  as before. If the guess is too large, you\nwaste some memory.</p><p>If your guess for the number of tasks was a good one, then there‚Äôs\nonly one allocation site in this program. The  call allocates a\nslice backing store of the correct size, and  never has to do\nany reallocation.</p><p>The surprising thing is that if you benchmark this code with 10\nelements in the channel, you‚Äôll see that you didn‚Äôt reduce the number\nof allocations to 1, you reduced the number of allocations to 0!</p><p>The reason is that the compiler decided to allocate the backing store\non the stack. Because it knows what size it needs to be (10 times the\nsize of a task) it can allocate storage for it in the stack frame of\n instead of on the heap<a href=\"https://go.dev/blog/allocation-optimizations#footnotes\"></a>.  Note\nthat this depends on the fact that the backing store does not <a href=\"https://go.dev/doc/gc-guide#Escape_analysis\">escape\nto the heap</a> inside of .</p><h2>Stack allocation of variable-sized slices</h2><p>But of course, hard coding a size guess is a bit rigid.\nMaybe we can pass in an estimated length?</p><pre><code>func process3(c chan task, lengthGuess int) {\n    tasks := make([]task, 0, lengthGuess)\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>This lets the caller pick a good size for the  slice, which may\nvary depending on where this code is being called from.</p><p>Unfortunately, in Go 1.24 the non-constant size of the backing store\nmeans the compiler can no longer allocate the backing store on the\nstack.  It will end up on the heap, converting our 0-allocation code\nto 1-allocation code. Still better than having  do all the\nintermediate allocations, but unfortunate.</p><p>But never fear, Go 1.25 is here!</p><p>Imagine you decide to do the following, to get the stack allocation\nonly in cases where the guess is small:</p><pre><code>func process4(c chan task, lengthGuess int) {\n    var tasks []task\n    if lengthGuess &lt;= 10 {\n        tasks = make([]task, 0, 10)\n    } else {\n        tasks = make([]task, 0, lengthGuess)\n    }\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>Kind of ugly, but it would work. When the guess is small, you use a\nconstant size  and thus a stack-allocated backing store, and\nwhen the guess is larger you use a variable size  and allocate\nthe backing store from the heap.</p><p>But in Go 1.25, you don‚Äôt need to head down this ugly road. The Go\n1.25 compiler does this transformation for you!  For certain slice\nallocation locations, the compiler automatically allocates a small\n(currently 32-byte) slice backing store, and uses that backing store\nfor the result of the  if the size requested is small\nenough. Otherwise, it uses a heap allocation as normal.</p><p>In Go 1.25,  performs zero heap allocations, if\n is small enough that a slice of that length fits into 32\nbytes. (And of course that  is a correct guess for how\nmany items are in .)</p><p>We‚Äôre always improving the performance of Go, so upgrade to the latest\nGo release and <a href=\"https://youtu.be/FUm0pfgWehI?si=QRTt_JYwr-cRHDNJ&amp;t=960\" rel=\"noreferrer\" target=\"_blank\">be\nsurprised</a> by\nhow much faster and memory efficient your program becomes!</p><h2>Stack allocation of append-allocated slices</h2><p>Ok, but you still don‚Äôt want to have to change your API to add this\nweird length guess. Anything else you could do?</p><pre><code>func process(c chan task) {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>In Go 1.26, we allocate the same kind of small, speculative backing\nstore on the stack, but now we can use it directly at the \nsite.</p><p>On the first loop iteration, there is no backing store for , so\n uses a small, stack-allocated backing store as the first\nallocation. If, for instance, we can fit 4 s in that backing store,\nthe first  allocates a backing store of length 4 from the stack.</p><p>The next 3 loop iterations append directly to the stack backing store,\nrequiring no allocation.</p><p>On the 4th iteration, the stack backing store is finally full and we\nhave to go to the heap for more backing store. But we have avoided\nalmost all of the startup overhead described earlier in this article.\nNo heap allocations of size, 1, 2, and 4, and none of the garbage that\nthey eventually become. If your slices are small, maybe you will never\nhave a heap allocation.</p><h2>Stack allocation of append-allocated escaping slices</h2><p>Ok, this is all good when the  slice doesn‚Äôt escape. But what if\nI‚Äôm returning the slice? Then it can‚Äôt be allocated on the stack, right?</p><p>Right! The backing store for the slice returned by  below\ncan‚Äôt be allocated on the stack, because the stack frame for \ndisappears when  returns.</p><pre><code>func extract(c chan task) []task {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    return tasks\n}\n</code></pre><p>But you might think, the  slice can‚Äôt be allocated on the\nstack. But what about all those intermediate slices that just become\ngarbage? Maybe we can allocate those on the stack?</p><pre><code>func extract2(c chan task) []task {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    tasks2 := make([]task, len(tasks))\n    copy(tasks2, tasks)\n    return tasks2\n}\n</code></pre><p>Then the  slice never escapes . It can benefit from\nall of the optimizations described above. Then at the very end of\n, when we know the final size of the slice, we do one heap\nallocation of the required size, copy our s into it, and return\nthe copy.</p><p>But do you really want to write all that additional code? It seems\nerror prone. Maybe the compiler can do this transformation for us?</p><p>For escaping slices, the compiler will transform the original \ncode to something like this:</p><pre><code>func extract3(c chan task) []task {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    tasks = runtime.move2heap(tasks)\n    return tasks\n}\n</code></pre><p> is a special compiler+runtime function that is the\nidentity function for slices that are already allocated in the heap.\nFor slices that are on the stack, it allocates a new slice on the\nheap, copies the stack-allocated slice to the heap copy, and returns\nthe heap copy.</p><p>This ensures that for our original  code, if the number of\nitems fits in our small stack-allocated buffer, we perform exactly 1\nallocation of exactly the right size. If the number of items exceeds\nthe capacity our small stack-allocated buffer, we do our normal\ndoubling-allocation once the stack-allocated buffer overflows.</p><p>The optimization that Go 1.26 does is actually better than the\nhand-optimized code, because it does not require the extra\nallocation+copy that the hand-optimized code always does at the end.\nIt requires the allocation+copy only in the case that we‚Äôve exclusively\noperated on a stack-backed slice up to the return point.</p><p>We do pay the cost for a copy, but that cost is almost completely\noffset by the copies in the startup phase that we no longer have to\ndo. (In fact, the new scheme at worst has to copy one more element\nthan the old scheme.)</p><p>Hand optimization can still be beneficial, especially if you have a\ngood estimate of the slice size ahead of time. But hopefully the\ncompiler will now catch a lot of the simple cases for you and allow\nyou to focus on the remaining ones that really matter.</p><p>There are a lot of details that the compiler needs to ensure to get\nall these optimizations right. If you think that one of these\noptimizations is causing correctness or (negative) performance issues\nfor you, you can turn them off with\n<code>-gcflags=all=-d=variablemakehash=n</code>. If turning these optimizations\noff helps, please <a href=\"https://go.dev/issue/new\">file an issue</a> so we can investigate.</p><p> Go stacks do not have any -style mechanism for\ndynamically-sized stack frames. All Go stack frames are constant\nsized.</p>",
      "contentLength": 10579,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgdqfw/allocating_on_the_stack_go/"
    },
    {
      "title": "Helm in production: hard-won lessons and gotchas",
      "url": "https://blog.sneakybugs.com/helm-production-lessons/",
      "date": 1772214256,
      "author": "/u/LKummer",
      "guid": 48941,
      "unread": true,
      "content": "<!DOCTYPE html>",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/kubernetes/comments/1rgdi3v/helm_in_production_hardwon_lessons_and_gotchas/"
    },
    {
      "title": "The Evolution of Async Rust: From Tokio to High-Level Applications",
      "url": "https://blog.jetbrains.com/rust/2026/02/17/the-evolution-of-async-rust-from-tokio-to-high-level-applications/",
      "date": 1772212986,
      "author": "/u/carllerche",
      "guid": 49087,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/rust/comments/1rgcwsn/the_evolution_of_async_rust_from_tokio_to/"
    },
    {
      "title": "What crate in rust should I understand the most before\\after getting into rust async and parallel computing?",
      "url": "https://www.reddit.com/r/rust/comments/1rgc5ww/what_crate_in_rust_should_i_understand_the_most/",
      "date": 1772211486,
      "author": "/u/rudv-ar",
      "guid": 49096,
      "unread": true,
      "content": "<p>I have been learning rust for past one month, slow but still learning. I have just completed borrowing and functions in rust. Next I have lifetimes. To have a solid grasp and understanding of rust basics, what should I do? And also.. </p><p>The rust async is next in my learning path. Is there any specific crate I should learn other than default async in rust? When should I learn it? Before Or after async? </p><p>After Long Comments : Note Yo. Dont downvote me ya. Otherwise my account will vanish. Reddit has a very strict spam detection system and I dont want my account gone just like that. This is a new account. I was just seeking help without knowing what to do. And I am in college. So kindly help me. Correct me if I did some mistake. I want this personal account very much. </p>",
      "contentLength": 772,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Allocating on the Stack",
      "url": "https://go.dev/blog/allocation-optimizations",
      "date": 1772210135,
      "author": "/u/Deleis",
      "guid": 48889,
      "unread": true,
      "content": "<p>We‚Äôre always looking for ways to make Go programs faster. In the last\n2 releases, we have concentrated on mitigating a particular source of\nslowness, heap allocations. Each time a Go program allocates memory\nfrom the heap, there‚Äôs a fairly large chunk of code that needs to run\nto satisfy that allocation. In addition, heap allocations present\nadditional load on the garbage collector.  Even with recent\nenhancements like <a href=\"https://go.dev/blog/greenteagc\">Green Tea</a>, the garbage collector\nstill incurs substantial overhead.</p><p>So we‚Äôve been working on ways to do more allocations on the stack\ninstead of the heap.  Stack allocations are considerably cheaper to\nperform (sometimes completely free).  Moreover, they present no load\nto the garbage collector, as stack allocations can be collected\nautomatically together with the stack frame itself. Stack allocations\nalso enable prompt reuse, which is very cache friendly.</p><h2>Stack allocation of constant-sized slices</h2><p>Consider the task of building a slice of tasks to process:</p><pre><code>func process(c chan task) {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>Let‚Äôs walk through what happens at runtime when pulling tasks from the\nchannel  and adding them to the slice .</p><p>On the first loop iteration, there is no backing store for , so\n has to allocate one. Because it doesn‚Äôt know how big the\nslice will eventually be, it can‚Äôt be too aggressive. Currently, it\nallocates a backing store of size 1.</p><p>On the second loop iteration, the backing store now exists, but it is\nfull.  again has to allocate a new backing store, this time of\nsize 2. The old backing store of size 1 is now garbage.</p><p>On the third loop iteration, the backing store of size 2 is\nfull.  has to allocate a new backing store, this time\nof size 4. The old backing store of size 2 is now garbage.</p><p>On the fourth loop iteration, the backing store of size 4 has only 3\nitems in it.  can just place the item in the existing backing\nstore and bump up the slice length. Yay! No call to the allocator for\nthis iteration.</p><p>On the fifth loop iteration, the backing store of size 4 is full, and\n again has to allocate a new backing store, this time of size\n8.</p><p>And so on. We generally double the size of the allocation each time it\nfills up, so we can eventually append most new tasks to the slice\nwithout allocation. But there is a fair amount of overhead in the\n‚Äústartup‚Äù phase when the slice is small. During this startup phase we\nspend a lot of time in the allocator, and produce a bunch of garbage,\nwhich seems pretty wasteful. And it may be that in your program, the\nslice never really gets large. This startup phase may be all you ever\nencounter.</p><p>If this code was a really hot part of your program, you might be\ntempted to start the slice out at a larger size, to avoid all of these\nallocations.</p><pre><code>func process2(c chan task) {\n    tasks := make([]task, 0, 10) // probably at most 10 tasks\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>This is a reasonable optimization to do. It is never incorrect; your\nprogram still runs correctly. If the guess is too small, you get\nallocations from  as before. If the guess is too large, you\nwaste some memory.</p><p>If your guess for the number of tasks was a good one, then there‚Äôs\nonly one allocation site in this program. The  call allocates a\nslice backing store of the correct size, and  never has to do\nany reallocation.</p><p>The surprising thing is that if you benchmark this code with 10\nelements in the channel, you‚Äôll see that you didn‚Äôt reduce the number\nof allocations to 1, you reduced the number of allocations to 0!</p><p>The reason is that the compiler decided to allocate the backing store\non the stack. Because it knows what size it needs to be (10 times the\nsize of a task) it can allocate storage for it in the stack frame of\n instead of on the heap<a href=\"https://go.dev/blog/allocation-optimizations#footnotes\"></a>.  Note\nthat this depends on the fact that the backing store does not <a href=\"https://go.dev/doc/gc-guide#Escape_analysis\">escape\nto the heap</a> inside of .</p><h2>Stack allocation of variable-sized slices</h2><p>But of course, hard coding a size guess is a bit rigid.\nMaybe we can pass in an estimated length?</p><pre><code>func process3(c chan task, lengthGuess int) {\n    tasks := make([]task, 0, lengthGuess)\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>This lets the caller pick a good size for the  slice, which may\nvary depending on where this code is being called from.</p><p>Unfortunately, in Go 1.24 the non-constant size of the backing store\nmeans the compiler can no longer allocate the backing store on the\nstack.  It will end up on the heap, converting our 0-allocation code\nto 1-allocation code. Still better than having  do all the\nintermediate allocations, but unfortunate.</p><p>But never fear, Go 1.25 is here!</p><p>Imagine you decide to do the following, to get the stack allocation\nonly in cases where the guess is small:</p><pre><code>func process4(c chan task, lengthGuess int) {\n    var tasks []task\n    if lengthGuess &lt;= 10 {\n        tasks = make([]task, 0, 10)\n    } else {\n        tasks = make([]task, 0, lengthGuess)\n    }\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>Kind of ugly, but it would work. When the guess is small, you use a\nconstant size  and thus a stack-allocated backing store, and\nwhen the guess is larger you use a variable size  and allocate\nthe backing store from the heap.</p><p>But in Go 1.25, you don‚Äôt need to head down this ugly road. The Go\n1.25 compiler does this transformation for you!  For certain slice\nallocation locations, the compiler automatically allocates a small\n(currently 32-byte) slice backing store, and uses that backing store\nfor the result of the  if the size requested is small\nenough. Otherwise, it uses a heap allocation as normal.</p><p>In Go 1.25,  performs zero heap allocations, if\n is small enough that a slice of that length fits into 32\nbytes. (And of course that  is a correct guess for how\nmany items are in .)</p><p>We‚Äôre always improving the performance of Go, so upgrade to the latest\nGo release and <a href=\"https://youtu.be/FUm0pfgWehI?si=QRTt_JYwr-cRHDNJ&amp;t=960\" rel=\"noreferrer\" target=\"_blank\">be\nsurprised</a> by\nhow much faster and memory efficient your program becomes!</p><h2>Stack allocation of append-allocated slices</h2><p>Ok, but you still don‚Äôt want to have to change your API to add this\nweird length guess. Anything else you could do?</p><pre><code>func process(c chan task) {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    processAll(tasks)\n}\n</code></pre><p>In Go 1.26, we allocate the same kind of small, speculative backing\nstore on the stack, but now we can use it directly at the \nsite.</p><p>On the first loop iteration, there is no backing store for , so\n uses a small, stack-allocated backing store as the first\nallocation. If, for instance, we can fit 4 s in that backing store,\nthe first  allocates a backing store of length 4 from the stack.</p><p>The next 3 loop iterations append directly to the stack backing store,\nrequiring no allocation.</p><p>On the 4th iteration, the stack backing store is finally full and we\nhave to go to the heap for more backing store. But we have avoided\nalmost all of the startup overhead described earlier in this article.\nNo heap allocations of size, 1, 2, and 4, and none of the garbage that\nthey eventually become. If your slices are small, maybe you will never\nhave a heap allocation.</p><h2>Stack allocation of append-allocated escaping slices</h2><p>Ok, this is all good when the  slice doesn‚Äôt escape. But what if\nI‚Äôm returning the slice? Then it can‚Äôt be allocated on the stack, right?</p><p>Right! The backing store for the slice returned by  below\ncan‚Äôt be allocated on the stack, because the stack frame for \ndisappears when  returns.</p><pre><code>func extract(c chan task) []task {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    return tasks\n}\n</code></pre><p>But you might think, the  slice can‚Äôt be allocated on the\nstack. But what about all those intermediate slices that just become\ngarbage? Maybe we can allocate those on the stack?</p><pre><code>func extract2(c chan task) []task {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    tasks2 := make([]task, len(tasks))\n    copy(tasks2, tasks)\n    return tasks2\n}\n</code></pre><p>Then the  slice never escapes . It can benefit from\nall of the optimizations described above. Then at the very end of\n, when we know the final size of the slice, we do one heap\nallocation of the required size, copy our s into it, and return\nthe copy.</p><p>But do you really want to write all that additional code? It seems\nerror prone. Maybe the compiler can do this transformation for us?</p><p>For escaping slices, the compiler will transform the original \ncode to something like this:</p><pre><code>func extract3(c chan task) []task {\n    var tasks []task\n    for t := range c {\n        tasks = append(tasks, t)\n    }\n    tasks = runtime.move2heap(tasks)\n    return tasks\n}\n</code></pre><p> is a special compiler+runtime function that is the\nidentity function for slices that are already allocated in the heap.\nFor slices that are on the stack, it allocates a new slice on the\nheap, copies the stack-allocated slice to the heap copy, and returns\nthe heap copy.</p><p>This ensures that for our original  code, if the number of\nitems fits in our small stack-allocated buffer, we perform exactly 1\nallocation of exactly the right size. If the number of items exceeds\nthe capacity our small stack-allocated buffer, we do our normal\ndoubling-allocation once the stack-allocated buffer overflows.</p><p>The optimization that Go 1.26 does is actually better than the\nhand-optimized code, because it does not require the extra\nallocation+copy that the hand-optimized code always does at the end.\nIt requires the allocation+copy only in the case that we‚Äôve exclusively\noperated on a stack-backed slice up to the return point.</p><p>We do pay the cost for a copy, but that cost is almost completely\noffset by the copies in the startup phase that we no longer have to\ndo. (In fact, the new scheme at worst has to copy one more element\nthan the old scheme.)</p><p>Hand optimization can still be beneficial, especially if you have a\ngood estimate of the slice size ahead of time. But hopefully the\ncompiler will now catch a lot of the simple cases for you and allow\nyou to focus on the remaining ones that really matter.</p><p>There are a lot of details that the compiler needs to ensure to get\nall these optimizations right. If you think that one of these\noptimizations is causing correctness or (negative) performance issues\nfor you, you can turn them off with\n<code>-gcflags=all=-d=variablemakehash=n</code>. If turning these optimizations\noff helps, please <a href=\"https://go.dev/issue/new\">file an issue</a> so we can investigate.</p><p> Go stacks do not have any -style mechanism for\ndynamically-sized stack frames. All Go stack frames are constant\nsized.</p>",
      "contentLength": 10579,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rgbjga/allocating_on_the_stack/"
    },
    {
      "title": "Understanding alignment - from source to object file (C++)",
      "url": "https://maskray.me/blog/2025-08-24-understanding-alignment-from-source-to-object-file",
      "date": 1772208606,
      "author": "/u/ketralnis",
      "guid": 49153,
      "unread": true,
      "content": "<p>Alignment refers to the practice of placing data or code at memory\naddresses that are multiples of a specific value, typically a power of\n2. This is typically done to meet the requirements of the programming\nlanguage, ABI, or the underlying hardware. Misaligned memory accesses\nmight be expensive or will cause traps on certain architectures.</p><p>This blog post explores how alignment is represented and managed as\nC++ code is transformed through the compilation pipeline: from source\ncode to LLVM IR, assembly, and finally the object file. We'll focus on\nalignment for both variables and functions.</p><h2>Alignment in C++ source code</h2><blockquote><p>Object types have alignment requirements ([basic.fundamental],\n[basic.compound]) which place restrictions on the addresses at which an\nobject of that type may be allocated. An alignment is an\nimplementation-defined integer value representing the number of bytes\nbetween successive addresses at which a given object can be allocated.\nAn object type imposes an alignment requirement on every object of that\ntype; stricter alignment can be requested using the alignment specifier\n([dcl.align]). Attempting to create an object ([intro.object]) in\nstorage that does not meet the alignment requirements of the object's\ntype is undefined behavior.</p></blockquote><p> can be used to request a stricter alignment. <a target=\"_blank\" rel=\"noopener\" href=\"https://eel.is/c++draft/dcl.align\">[decl.align]</a></p><blockquote><p>An alignment-specifier may be applied to a variable or to a class\ndata member, but it shall not be applied to a bit-field, a function\nparameter, or an exception-declaration ([except.handle]). An\nalignment-specifier may also be applied to the declaration of a class\n(in an elaborated-type-specifier ([dcl.type.elab]) or class-head\n([class]), respectively). An alignment-specifier with an ellipsis is a\npack expansion ([temp.variadic]).</p></blockquote><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p>If the strictest  on a declaration is weaker than\nthe alignment it would have without any alignas specifiers, the program\nis ill-formed.</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p>However, the GNU extension <code>__attribute__((aligned(1)))</code>\ncan request a weaker alignment.</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p>In the LLVM Intermediate Representation (IR), both global variables\nand functions can have an  attribute to specify their\nrequired alignment.</p><blockquote><p>An explicit alignment may be specified for a global, which must be a\npower of 2. If not present, or if the alignment is set to zero, the\nalignment of the global is set by the target to whatever it feels\nconvenient. If an explicit alignment is specified, the global is forced\nto have exactly that alignment. Targets and optimizers are not allowed\nto over-align the global if the global has an assigned section. In this\ncase, the extra alignment could be observable: for example, code could\nassume that the globals are densely packed in their section and try to\niterate over them as an array, alignment padding would break this\niteration. For TLS variables, the module flag MaxTLSAlign, if present,\nlimits the alignment to the given value. Optimizers are not allowed to\nimpose a stronger alignment on these variables. The maximum alignment is\n1 &lt;&lt; 32.</p></blockquote><blockquote><p>An explicit alignment may be specified for a function. If not\npresent, or if the alignment is set to zero, the alignment of the\nfunction is set by the target to whatever it feels convenient. If an\nexplicit alignment is specified, the function is forced to have at least\nthat much alignment. All alignments must be a power of 2.</p></blockquote><p>An explicit preferred alignment () may also be\nspecified for a function definition (must be a power of 2). Unlike\n, it is a hint: the final alignment will generally\nland somewhere between the minimum and preferred values. If absent, the\npreferred alignment is determined in a target-specific way\n(<code>STI-&gt;getTargetLowering()-&gt;getPrefFunctionAlignment()</code>).\n(<a target=\"_blank\" rel=\"noopener\" href=\"https://discourse.llvm.org/t/rfc-enhancing-function-alignment-attributes/88019/3\">https://discourse.llvm.org/t/rfc-enhancing-function-alignment-attributes/88019/3</a>)</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p>In addition,  can be used in parameter attributes\nto decorate a pointer or <a target=\"_blank\" rel=\"noopener\" href=\"https://reviews.llvm.org/D115161\">vector of pointers</a>.</p><h2>LLVM back end representation</h2><p><code>AsmPrinter::emitGlobalVariable</code> determines the alignment for\nglobal variables based on a set of nuanced rules:</p><ul><li>With an explicit alignment (),\n<ul><li>If the variable has a section attribute, return\n.</li><li>Otherwise, compute a preferred alignment for the data layout\n(, referred to as ).\nReturn\n<code>pref &lt; explicit ? explicit : max(E, getABITypeAlign)</code>.</li></ul></li><li>Without an explicit alignment: return\n.</li></ul><p> employs a heuristic for global variable\ndefinitions: if the variable's size exceeds 16 bytes and the preferred\nalignment is less than 16 bytes, it sets the alignment to 16 bytes. This\nheuristic balances performance and memory efficiency for common cases,\nthough it may not be optimal for all scenarios. (See <a target=\"_blank\" rel=\"noopener\" href=\"https://discourse.llvm.org/t/preferred-alignment-of-globals-16bytes/24410\">Preferred\nalignment of globals &gt; 16bytes</a> in 2012)</p><p>For assembly output, AsmPrinter emits  (power of\n2 alignment) directives with a zero fill value (i.e. the padding bytes\nare zeros). </p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p> For functions,\n<code>AsmPrinter::emitFunctionHeader</code> emits alignment directives\nbased on the machine function's alignment settings.</p><p> sets the \nalignment from the subtarget:</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p>The  alignment is computed separately by\n<code>MachineFunction::getPreferredAlignment()</code>:</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p>For example,  sets the preferred\nfunction alignment to 16.</p><p>How these are emitted depends on whether the integrated assembler,\n support, and function sections are all\nactive:</p><ul><li>\n(): emit  using the\nexplicit  attribute value (if present), then\n for the preferred alignment. A function without\nan explicit  attribute gets only\n (no ).</li><li><strong>Without function sections</strong>: emit\n using the preferred alignment (old behavior).\n is not used here because its benefit is tied to\nsection size equalling function size (see below).</li></ul><figure><table><tbody><tr><td><pre></pre></td><td><pre></pre></td></tr></tbody></table></figure><p>The emitted  directives omit the fill value\nargument: for code sections, this space is filled with no-op\ninstructions.</p><p>GNU Assembler supports multiple alignment directives:</p><ul><li>: align to 2**3</li><li>: this is identical to  on\nsome targets and  on the others.</li><li> (LLVM extension): sets the section's\n alignment. Unlike , the actual\n stored in the object file is chosen based on\nthe section size: if the section is smaller than , the\nalignment is rounded up to the next power of 2 ‚â• size (rather than\nalways being ). This allows the linker to pack small\nfunctions more tightly while still aligning larger ones.\n<ul><li> size :\n smallest power of 2 ‚â• size</li></ul>\nThis is only useful when each function has its own section\n(), so that section size equals function\nsize and  effectively encodes per-function\nalignment. With a merged  section the total size is\nalways large, so  ends up at \nregardless. Moreover,  only controls where the\nlinker places the section start; alignment between individual functions\nwithin a merged section comes from  NOP padding\nembedded in the section body, which  does not\naffect.</li></ul><p>Clang supports \"direct object emission\" (\ntypically bypasses a separate assembler), the LLVMAsmPrinter directly\nuses the  API. This allows Clang to emit\nthe machine code directly into the object file, bypassing the need to\nparse and interpret alignment directives and instructions from a\ntext-based assembly file.</p><p>These alignment directives has an optional third argument: the\nmaximum number of bytes to skip. If doing the alignment would require\nskipping more bytes than the specified maximum, the alignment is not\ndone at all. GCC's  utilizes this\nfeature.</p><p>In an object file, the section alignment is determined by the\nstrictest alignment directive present in that section. The assembler\nsets the section's overall alignment to the maximum of all these\ndirectives, as if an implicit directive were at the start.</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p>This alignment is stored in the  field\nwithin the ELF section header table. You can inspect this value using\ntools such as  () or\n ().</p><p>The linker combines multiple object files into a single executable.\nWhen it maps input sections from each object file into output sections\nin the final executable, it ensures that section alignments specified in\nthe object files are preserved.</p><h3>How the linker handles\nsection alignment</h3><p>: This is the maximum\n value among all its contributing input\nsections. This ensures the strictest alignment requirements are met.</p><p>: The linker also uses input\n information to position each input section\nwithin the output section. As illustrated in the following example, each\ninput section (like  or )\nis aligned according to its  value before being\nplaced sequentially.</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p> A linker script can override the\ndefault alignment behavior. The  keyword enforces a\nstricter alignment. For example <code>.text : ALIGN(32) { ... }</code>\naligns the section to at least a 32-byte boundary. This is often done to\noptimize for specific hardware or for memory mapping requirements.</p><p>The  keyword on an output section overrides the\ninput section alignments.</p><p>: To achieve the required alignment, the\nlinker may insert padding between sections or before the first input\nsection (if there is a gap after the output section start). The fill\nvalue is determined by the following rules:</p><ul><li>If a non-code section, use zero.</li><li>Otherwise, use a trap or no-op instructin.</li></ul><h3>Padding and section\nreordering</h3><p>Linkers typically preserve the order of input sections from object\nfiles. To minimize the padding required between sections, linker scripts\ncan use a  keyword to arrange input\nsections in descending order of their alignment requirements. Similarly,\nGNU ld supports <a href=\"https://maskray.me/blog/2022-02-06-all-about-common-symbols#sort-common\"></a>\nto sort COMMON symbols by decreasing alignment.</p><p>While this sorting can reduce wasted space, modern linking strategies\noften prioritize other factors, such as cache locality (for performance)\nand data similarity (for Lempel‚ÄìZiv compression ratio), which can\nconflict with sorting by alignment. (Search\n on <a href=\"https://maskray.me/blog/2020-11-15-explain-gnu-linker-options\">Explain GNU style\nlinker options</a>).</p><p>The alignment of a variable or function can be as large as the system\npage size. Some implementations allow a larger alignment. (<a href=\"https://maskray.me/blog/2023-12-17-exploring-the-section-layout-in-linker-output#over-aligned-segment\">Over-aligned\nsegment</a>)</p><p>Some platforms have special rules. For example,</p><ul><li>On SystemZ, the  (load address relative long)\ninstruction cannot generate odd addresses. To prevent GOT indirection,\ncompilers ensure that symbols are at least aligned by 2. (<a href=\"https://maskray.me/blog/2024-02-11-toolchain-notes-on-z-architecture\">Toolchain\nnotes on z/Architecture</a>)</li><li>On AIX, the default alignment mode is : for double\nand long double, the first member of this data type is aligned according\nto its natural alignment value; subsequent members of the aggregate are\naligned on 4-byte boundaries. (<a target=\"_blank\" rel=\"noopener\" href=\"https://reviews.llvm.org/D79719\">https://reviews.llvm.org/D79719</a>)</li></ul><p>The standard representation of the the Itanium C++ ABI requires\nmember function pointers to be even, to distinguish between virtual and\nnon-virtual functions.</p><blockquote><p>In the standard representation, a member function pointer for a\nvirtual function is represented with ptr set to 1 plus the function's\nv-table entry offset (in bytes), converted to a function pointer as if\nby\n<code>reinterpret_cast&lt;fnptr_t&gt;(uintfnptr_t(1 + offset))</code>,\nwhere  is an unsigned integer of the same size\nas .</p></blockquote><p>Conceptually, a pointer to member function is a tuple:</p><ul><li>A function pointer or virtual table index, discriminated by the\nleast significant bit</li><li>A displacement to apply to the  pointer</li></ul><p>Due to the least significant bit discriminator, members function need\na stricter alignment even if <code>__attribute__((aligned(1)))</code> is\nspecified:</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><h2>Architecture considerations</h2><p>Contemporary architectures generally support unaligned memory access,\nlikely with very small performance penalties. However, some\nimplementations might restrict or penalize unaligned accesses heavily,\nor require specific handling. Even on architectures supporting unaligned\naccess, atomic operations might still require alignment.</p><ul><li>On AArch64, a bit in the system control register\n enables alignment check.</li><li>On x86, if the AM bit is set in the CR0 register and the AC bit is\nset in the EFLAGS register, alignment checking of user-mode data\naccessing is enabled.</li></ul><p>Linux's RISC-V port supports\n<code>prctl(PR_SET_UNALIGN, PR_UNALIGN_SIGBUS);</code> to enable strict\nalignment.</p><p><code>clang -fsanitize=alignment</code> can detect misaligned memory\naccess. Check out my <a href=\"https://maskray.me/blog/2023-01-29-all-about-undefined-behavior-sanitizer#fsanitizealignment\">write-up</a>.</p><p>In 1989, US Patent 4814976, which covers \"RISC computer with\nunaligned reference handling and method for the same\" (4 instructions:\nlwl, lwr, swl, and swr), was granted to MIPS Computer Systems Inc. It\ncaused a barrier for other RISC processors, see <a target=\"_blank\" rel=\"noopener\" href=\"https://www.probell.com/lexra/\">The Lexra Story</a>.</p><blockquote><p>Almost every microprocessor in the world can emulate the\nfunctionality of unaligned loads and stores in software. MIPS\nTechnologies did not invent that. By any reasonable interpretation of\nthe MIPS Technologies' patent, Lexra did not infringe. In mid-2001 Lexra\nreceived a ruling from the USPTO that all claims in the the lawsuit were\ninvalid because of prior art in an IBM CISC patent. However, MIPS\nTechnologies appealed the USPTO ruling in Federal court, adding to\nLexra's legal costs and hurting its sales. That forced Lexra into an\nunfavorable settlement. The patent expired on December 23, 2006 at which\npoint it became legal for anybody to implement the complete MIPS-I\ninstruction set, including unaligned loads and stores.</p></blockquote><p>GCC offers a family of performance-tuning options named\n, that instruct the compiler to align certain code\nsegments to specific memory boundaries. These options might improve\nperformance by preventing certain instructions from crossing cache line\nboundaries (or instruction fetch boundaries), which can otherwise cause\nan extra cache miss.</p><ul><li>: Align functions.</li><li>: Align branch targets.</li><li>: Align branch targets, for branch\ntargets where the targets can only be reached by jumping.</li><li>: Align the beginning of loops.</li></ul><p><strong>Inefficiency with Small Functions</strong>: Aligning small\nfunctions can be inefficient and may not be worth the overhead. To\naddress this, GCC introduced <code>-flimit-function-alignment</code> in\n2016. The option sets  directive's max-skip operand\nto the estimated function size minus one.</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p>The max-skip operand, if present, is evaluated at parse time, so you\ncannot do: </p><figure><table><tbody><tr></tr></tbody></table></figure><p>In LLVM, the x86 backend does not implement\n<code>TargetInstrInfo::getInstSizeInBytes</code>, making it challenging\nto implement <code>-flimit-function-alignment</code>.</p><p>: These options don't apply to cold\nfunctions. To ensure that cold functions are also aligned, use\n<code>-fmin-function-alignment=n</code> instead.</p><p>: Aligning functions can make benchmarks\nmore reliable. For example, on x86-64, a hot function less than 32 bytes\nmight be placed in a way that uses one or two cache lines (determined by\n<code>function_addr % cache_line_size</code>), making benchmark results\nnoisy. Using  can ensure the function\nalways occupies a single cache line, leading to more consistent\nperformance measurements.</p><p>LLVM notes: In <code>clang/lib/CodeGen/CodeGenModule.cpp</code>,\n and \nnow set  the minimum alignment and the preferred\nalignment (consistent with GCC). The separate\n<code>-fpreferred-function-alignment=N</code> option controls only the\npreferred alignment hint without affecting the minimum.</p><p>A hardware loop typically consistants of 3 parts:</p><p>A low-overhead loop (also called a zero-overhead loop) is a\nhardware-assisted looping mechanism found in many processor\narchitectures, particularly digital signal processors (DSPs). The\nprocessor includes dedicated registers that store the loop start\naddress, loop end address, and loop count. A hardware loop typically\nconsists of three components:</p><ul><li>Loop setup instruction: Sets the loop end address and iteration\ncount</li><li>Loop body: Contains the actual instructions to be repeated</li><li>Loop end instruction: Jumps back to the loop body if further\niterations are required</li></ul><p>Here is an example from Arm v8.1-M low-overhead branch extension.</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure><p>To minimize the number of cache lines used by the loop body, ideally\nthe loop body (the instruction immediately following DLS) should be\naligned to a 64-byte boundary. However, GNU Assembler lacks a directive\nto specify alignment like \"align DLS to a multiple of 64 plus 60 bytes.\"\nInserting an alignment after the DLS is counterproductive, as it would\nintroduce unwanted NOP instructions at the beginning of the loop body,\nnegating the performance benefits of the low-overhead loop\nmechanism.</p><p>It would be desirable to simulate the functionality with\n<code>.org ((.+4+63) &amp; -64) - 4  // ensure that .+4 is aligned to 64-byte boundary</code>,\nbut this complex expression involves bitwise AND and is not a\nrelocatable expression. LLVM integrated assembler would report\n<code>expected absolute expression</code> while GNU Assembler has a\nsimilar error.</p><p>A potential solution would be to extend the alignment directives with\nan optional offset parameter:</p><figure><table><tbody><tr><td><pre></pre></td></tr></tbody></table></figure>",
      "contentLength": 16004,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgauj3/understanding_alignment_from_source_to_object/"
    },
    {
      "title": "The proposal for generic methods for Go has been officially accepted",
      "url": "https://github.com/golang/go/issues/77273#issuecomment-3962618141",
      "date": 1772208436,
      "author": "/u/ketralnis",
      "guid": 48915,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgartl/the_proposal_for_generic_methods_for_go_has_been/"
    },
    {
      "title": "80386 Protection",
      "url": "https://nand2mario.github.io/posts/2026/80386_protection/",
      "date": 1772208373,
      "author": "/u/ketralnis",
      "guid": 49061,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rgaqti/80386_protection/"
    },
    {
      "title": "People are STILL Writing JavaScript \"DRM\"",
      "url": "https://the-ranty-dev.vercel.app/javascript-drms-are-stupid",
      "date": 1772207175,
      "author": "/u/medy17",
      "guid": 48913,
      "unread": true,
      "content": "<p>A while back, I was browsing Reddit and came across a thread about hotaudio.net. For those unfamiliar, it‚Äôs a website developed by u/fermaw, the very same developer behind the ever-popular gwasi.com.</p><p>If neither of those websites rings a bell, then I need to welcome you to r/GoneWildAudio: an NSFW subreddit for ASMR. Stay and read, the ASMR is only part of this odd tale.</p><p>You see, not too long ago, Soundgasm, Mega, and a few others were quite popular for hosting these audios, but as ToS tightened and taboo topics got more taboo, other platforms popped up to fill the gap.</p><p>HotAudio is one of them, but in a different way. Their claim is offering DRM for ASMRtists‚Äîa rare thing in the ASMR space, let alone the NSFW ASMR space.</p><p>u/fermaw, the aforementioned developer, was bragging in that thread I mentioned earlier about coding a DRM and how he found it rather ‚Äúfun‚Äù to do so.</p><p>I have no doubt it was fun, and believe me, this post is not meant to ridicule anyone or incite any form of hate, but I think calling it ‚ÄúDRM‚Äù is a little far-fetched.</p><p>Long before the days of Denuvo, the now-infamous game DRM, we knew that any such system living in the user‚Äôs accessible memory was vulnerable. So, we shifted to what we call today a Trusted Execution Environment (TEE).</p><p>I‚Äôd like to quote Microsoft here: <em>‚ÄúA Trusted Execution Environment is a segregated area of memory and CPU that‚Äôs protected from the rest of the CPU by using encryption. Any code outside that environment can‚Äôt read or tamper with the data in the TEE. Authorized code can manipulate the data inside the TEE.‚Äù</em></p><p>See what I‚Äôm getting at? JavaScript code is fundamentally a ‚Äúuserland‚Äù thing. The code you ship is accessible to the user to modify and fuck about with however they wish.</p><p>This is the problem with u/fermaw‚Äôs ‚ÄúDRM.‚Äù No matter how many clever keys, nonces, and encrypted file formats he attempts to send to the user, eventually, the very same JavaScript code will need to exit his decryption logic and‚Äîwhoops‚Äîit goes plain Jane into digital and straight to the speakers.</p><h3>On Elephants in the Room: Trusted Execution Environments</h3><p>Before we get into the code, we need to understand why this was always going to end in a bloodbath. The entire history of DRM is, at its core, a history of trying to give someone a locked box while simultaneously handing them the fucking key. The film and music industries have been losing this battle since the first CSS-encrypted DVD was cracked in 1999.</p><p>The modern, professional answer to this problem is the <strong>Trusted Execution Environment</strong>, or TEE.</p><p>As quoted above, a TEE is a hardware-backed secure area of the main processor (like ARM TrustZone or Intel SGX). Technically speaking, the TEE is just the hardware fortress (exceptions exist like TrustZone) whilst a Content Decryption Module (CDM) like Google‚Äôs Widevine, Apple‚Äôs FairPlay, and Microsoft‚Äôs PlayReady use the TEE to ensure cryptographic keys and decrypted media buffers are never exposed to the host operating system let alone the user‚Äôs browser. For the purposes of this article, I may at times refer to them interchangeably but all you need to know is that they work together and in any case, the host OS can‚Äôt whiff any of their farts so to speak.</p><p>However, getting a Widevine licence requires a licensing agreement with Google. It requires native binary integration. It requires infrastructure, legal paperwork, not to mention, shitloads of money. A small NSFW audio hosting platform is not going to get a Widevine licence. They‚Äôd be lucky if Google even returned their emails. Okay maybe not quite but the point is they‚Äôre not getting Widevine.</p><p>So what does HotAudio do then? Based on everything I could observe, they implement a custom JavaScript-based decryption scheme. The audio is served in an encrypted format chunked via the <strong>MediaSource Extensions (MSE)</strong> API and then the player fetches, decrypts, and feeds each chunk to the browser‚Äôs audio engine in real time. It‚Äôs a reasonable-ish approach for a small platform. It stops casual right-clickers. It stops people opening the network tab and downloading the raw response file, only to discover it won‚Äôt play. For most users, that friction is sufficient.</p><p>Unfortunately for HotAudio, every r/DataHoarder user worth their salt knows these types of websites don‚Äôt have proper blackbox DRMs so it‚Äôs only a matter of time before someone with a tool they crafted with spit and spite shows up.</p><p>It just doesn‚Äôt stop someone who understands exactly where the decrypted data has to appear.</p><h3>The ‚ÄúPCM Boundary‚Äù: a Wannabe-DRM Graveyard</h3><p>Let me introduce you to what I call the . PCM (Pulse-Code Modulation) is the raw, uncompressed digital audio format that eventually gets sent to your speakers. It‚Äôs the terminal endpoint of every audio pipeline, regardless of how aggressively encrypted the source was.</p><div><pre>graph TD\n    Server[HotAudio Server] --&gt;|Sends Encrypted audio chunks| JS[JavaScript Player]\n    JS --&gt;|Decrypts using proprietary logic| DecryptedData([Decrypted Data])\n    DecryptedData --&gt;|Calls appendBuffer| Hook[Hook]\n    \n    Hook -.-&gt;|GOLDEN INTERCEPT| SavedAudio[(Captures Pristine Audio File)]\n    \n    Hook --&gt;|Forwards genuine appendBuffer| MSE[MediaSource API]\n    MSE --&gt;|Feeds to codec decoder| Decoder[Browser Decoder]\n    Decoder --&gt;|PCM audio output| Speakers[Speakers]</pre></div><p>For our purposes, we don‚Äôt even need to chase it all the way to raw PCM which is valid avenue albeit in the realm of WEBRips and not defacto ‚Äúdownloaders.‚Äù  just need to find the <em>last point in the pipeline where data is still accessible to JavaScript</em> and that point is the <strong>MediaSource Extensions API</strong>, specifically the <code>SourceBuffer.appendBuffer()</code> method.</p><ol><li>Your JavaScript code creates a  object and attaches it to a  or  element via a blob URL.</li><li>You call <code>mediaSource.addSourceBuffer(mimeType)</code> to declare what codec format you‚Äôll be feeding the buffer.</li><li>You repeatedly call <code>sourceBuffer.appendBuffer(data)</code> to push chunks of (in our case, pre-decrypted) encoded audio data to the browser.</li><li>The browser‚Äôs internal decoder handles the rest: decoding the codec, managing the playback timeline, and routing audio to the hardware.</li></ol><p>Notice how by step 3, the time HotAudio‚Äôs player calls , the data has <em>already been decrypted by their JavaScript code</em>. It has to be. The browser‚Äôs built-in AAC or Opus decoder doesn‚Äôt know a damn thing about HotAudio‚Äôs proprietary encryption scheme. It only speaks standard codecs. The decryption must happen in JavaScript before the data is handed to the browser.</p><p>This means there is a golden moment: the exact instant between ‚ÄúHotAudio‚Äôs player finishes decrypting a chunk‚Äù and ‚Äúthat chunk is handed to the browser‚Äôs media engine.‚Äù If you can intercept  at that instant, you receive every chunk in its pristine, fully decrypted state, on a silver fucking platter.</p><p>Anyways, that is the fundamental vulnerability that no amount of encryption-decryption pipeline sophistication can close. You can make the key as complicated as you like. You can rotate keys per session, per user, per chunk. But eventually, the data has to come out the other end in a form the browser can decode. And that moment is yours to intercept.</p><p>Now. Let‚Äôs talk about how this little war actually played out. Dramatised and Ribbed‚Ñ¢ for your pleasure.</p><h2>Act One: Smash and Grab (V1.0)</h2><p>The first version of my extension was built on a simple observation: HotAudio‚Äôs player was exposing its active audio instance as a global variable. You could just type  into the browser console and there it was; The entire audio source object, sitting in the open like a wallet left on a park bench.</p><p>The approach had two parts. The extension would attempt to modify a JavaScript file that was always shipped with every request: .</p><p>Essentially, this specific block would be appended to the top of nozzle.js before the stream had even begun which would compromise the environment from the get go.</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>This is, without exaggeration, a client-side Man-in-the-Middle attack baked directly into the browser‚Äôs extension API. The site requests its player script; the extension intercepts that network request at the manifest level and silently substitutes its own poisoned version. HotAudio‚Äôs server never even knows.</p><p>Once the hook was in place, the automation script grabbed , muted it, slammed the playback rate to  (can‚Äôt go faster since that is the maximum supported by browsers), and sat back as the browser frantically decoded and fed chunks into the collection array. When the  event fired, the chunks were stitched together with  and downloaded as an  file.</p><p>Of course, this was a patch war. According to various Reddit threads and GitHub Issues, fermaw is known for patrolling subreddits and Issues looking for ways in which devs have attempted bypasses in order to patch them.</p><p>It was only a matter of time. Indeed by week two of the extension‚Äôs public release on GitHub, he had patched the vulnerability.</p><p>First, he stopped exposing his player instance as a predictable global variable. He wrapped his initialisation code tightly so that  no longer pointed to anything useful. Without the player reference, my automation script had nothing to grab, nothing to control, nowhere to start.</p><p>Second, and more cleverly: he implemented a  on . The exact implementation could have been Subresource Integrity (SRI), a custom self-hashing routine, or a server-side nonce system, but the effect was the same. When the browser (or the application itself) loaded the script, it compared the modified file against a canonical hash and if it did not pass the check, the player would never initialise.</p><p>This effectively meant the old method was dead.</p><h2>Act Two: Traps and Dicks. Synonyms and Subs-titutes.</h2><h3>Fermaw‚Äôs In-Memory Defences</h3><p>I suppose at this point, fermaw assumed he was dealing with someone who wasn‚Äôt going to just fuck off. And I wasn‚Äôt. It was as fun for me to try and beat as it was for him to develop.</p><p>His response was to implement <strong>anti-tamper checks at the JavaScript level</strong>. Specifically, he started inspecting his own critical functions using .</p><p>This is a well-known browser security technique. In JavaScript, calling  on a native browser function returns <code>\"function appendBuffer() { [native code] }\"</code>. Calling it on a JavaScript function returns the actual source code. So if your  has been monkey-patched,  will betray you; it‚Äôll return the attacker‚Äôs JavaScript source instead of the expected native code string.</p><p>Fermaw added checks along the lines of:</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>Fermaw also, it seems, started obfuscating and scrambling how his player was initialised, making the  class harder to find via the polling loop. The constructor hijack became unreliable.</p><p>My technique had changed at this point. Since he was trying multiple things, well, I had to as well.</p><p><strong>First:  ‚Äî The Lie That Defeats The Check</strong></p><p>The single most important addition in V2 was a function to make my hooked methods lie about what they are:</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>After hooking any function, I immediately called  on it. From that point on, if fermaw‚Äôs integrity check asked  whether  was native, it would receive the pristine, authentic-looking answer: <code>function appendBuffer() { [native code] }</code>. Basically, it‚Äôs like asking your ex if they cheated on you and they did but they say they didn‚Äôt and you take their word for it because reasons. <strong>Don‚Äôt worry, on √©coute et on ne juge pas.</strong></p><p>Fermaw‚Äôs anti-tamper check was now returning a false negative. The enemy‚Äôs spy was wearing his uniform.</p><p><strong>Second: Ambushing <code>HTMLMediaElement.prototype.play</code></strong></p><p>I gave up entirely on finding the player by name. Instead of looking for  or , I simply staked out the exit. I hooked the most generic, lowest-level method available:</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>The logic is fairly simple: <em>I don‚Äôt give a shit what you name your player object. I don‚Äôt care how deeply you bury it in a closure. I don‚Äôt care what class you instantiate it from. At some point, you have to call . And when you do, I‚Äôll be waiting.</em></p><p>I was confident in that approach because you would not call multiple s on the same page to lead a reverse engineer astray. Why? Because mobile devices typically speaking will pause every other player except one. If fermaw were to do that, it‚Äôd ruin the experience for mobile users even if desktop users would probably be fine. It also makes casting a bitch and a half. Even if you did manage to pepper them around, it would be fairly easily to listen in on all of them and then programmatically pick out the one with actually consistent data being piped out.</p><p>Now then, the moment HotAudio‚Äôs player commanded the browser to begin playback, the hook snapped shut. The audio element, , was grabbed and stored.  ensured the hook was invisible to integrity checks.</p><p><strong>Third: Keep it Untouchable ()</strong></p><p>When hijacking the  constructor, I also used  with a specific, paranoid configuration:</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p> means no code can reassign  to a different value.  means no code can even call  again to change those settings. If fermaw‚Äôs initialisation code tried to restore the original  constructor (a perfectly sensible defensive move) the browser would either fail or throw a . The hook was permanent for the lifetime of the page.</p><h2>Act Three: Choking on Natives (V3.0)</h2><h3>Iframes and the Shadow DOM</h3><p>By this point, fermaw understood that his player instance was being ambushed whenever it called . He tried to isolate the player from the main window context entirely.</p><p>The two primary techniques at his disposal were  and .</p><p>An  creates a completely separate browsing context with its own  object, its own , and most importantly;its own prototype chain. A function hooked on <code>HTMLMediaElement.prototype</code> in the parent  is  the same object as <code>HTMLMediaElement.prototype</code> in the ‚Äôs . They‚Äôre entirely separate objects. If fermaw‚Äôs audio element lived inside an iframe, my prototype hook in the parent window would never fire.</p><p>Shadow DOM is a web component feature that lets you attach an isolated DOM subtree to any HTML element, hidden from the main document‚Äôs standard queries. A  on the main document cannot see inside a Shadow Root unless you specifically traverse into it. If fermaw‚Äôs player was mounted inside a Shadow Root, basic DOM searches would come up empty.</p><p>On top of this, fermaw was likely switching to assigning audio sources via  rather than the  attribute.  accepts a  or  object directly, bypassing the standard URL assignment path that‚Äôs easier to intercept.</p><h3>V3.0 ‚Äî Hooks, Crooks, and Nooks</h3><p>My response was to abandon trying to intercept at the level of individual elements and instead intercept at the level of the browser‚Äôs own . I went straight for <code>HTMLMediaElement.prototype</code> with <code>Object.getOwnPropertyDescriptor</code>, hooking the native  and  setters before any page code could run:</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p><code>HTMLMediaElement.prototype</code> is the browser‚Äôs own internal prototype for all  and  elements and by redefining the property descriptor for  and  on this prototype, I ensured that <em>regardless of where the audio element lives</em> (whether it‚Äôs in the main document, inside an iframe‚Äôs shadow, or buried inside a web component) the moment any source is assigned to it, the hook fires. The element cannot receive audio without announcing itself.</p><p>Even if fermaw‚Äôs code lives in an iframe with its own , the prototype hookery via  injection means my hooks are installed before the iframe can even initialise.</p><p>But the triumphance of V3 is in the  hook which solves a subtle problem. In earlier versions, hooking <code>SourceBuffer.prototype.appendBuffer</code> at the prototype level had a vulnerability in that if fermaw‚Äôs player cached a direct reference to  before the hook was installed (i.e., <code>const myAppend = sourceBuffer.appendBuffer; myAppend.call(sb, data)</code>), the hook would never fire. The player would bypass the prototype entirely and call the original native function through its cached reference.</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>The V3 approach obliterates this race condition by hooking  at the  level, I intercept the  of every . The moment a buffer is created and returned, I immediately install a hooked  directly on that specific instance; before any page code can even see the instance, let alone cache a reference to its methods. The hooked  is installed as an own property of the instance, which takes precedence over the prototype chain. There is no window for fermaw to cache the original. The hook is always first.</p><p>To catch any elements that somehow slipped through all of the above, I added capturing-phase event listeners as a belt-and-braces fallback:</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>The  flag for  is important. Browser events propagate in two phases: first, they travel  the DOM tree from the root to the target (capture phase), then they bubble  from the target back to the root (bubble phase). By listening in the capture phase, my listener fires before any event listener attached by HotAudio‚Äôs player code. Even if fermaw tried to cancel or suppress the event, he‚Äôd be too late because the capturing listener always fires first.</p><p>The combination of all four layers in  at the  prototype level,  and  property descriptor hooks,  prototype hook, and capture-phase event listeners means there is, practically speaking, no architectural escape route left. The entire browser surface area through which a media element can receive and play audio has been covered. How fucking braggadocious of me to say that. I will be humbled in due time. That much is universal law.</p><h3>Automation: Rinsing It in Seconds</h3><p>With the capture hooks in place, the automation script handles the actual download process. The approach has been refined significantly across the three versions, but the core idea has remained fairly constant: trick the browser into buffering the entire audio track as fast as the hardware and network allow, rather than in real time.</p><p>The script grabs the captured audio element, mutes it, sets  to  (the browser maximum), seeks to the beginning, and calls . The browser, in its infinite eagerness to keep the buffer full ahead of the playback position, frantically fetches, decrypts, and feeds chunks into the . Every single one of those chunks passes through the hooked  and gets collected.</p><div><div><p>Worth noting here is that Chrome itself limits this to 16x. The HTML spec has no mandated cap but since this is a Chromium extension; the constraint stands.</p></div></div><p>Of course, fermaw does have protections against this. For one, he aggressively throttles bursty traffic meaning downloads can go from a few hundred KB/s to 50-ish KB/s. Of course, it will in every case be several times faster than listening and recording anyways.</p><p>Fermaw cannot realistically slow down the stream more than that since it would stutter real traffic that has a download-y pattern. There is a possibility that he could enforce IP bans on patterns that display it but it would have to risk blanket bans against possible CGNAT traffic. There are ways to get around it but it prolongs the inevitable.</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>V3 also added . Rather than blindly holding at 16x, the script monitors the audio element‚Äôs  time ranges to assess buffer health. If the buffer ahead of the playback position is shrinking (meaning the network can‚Äôt keep up with the decode speed), the playback rate is reduced to give the fetcher time to catch up. If the buffer is healthy and growing, the rate is nudged back up. This prevents the browser from stalling entirely on slow connections, which would previously break the  event trigger and leave you waiting forever.</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>When the track ends‚Äîdetected either via the  event or via the stall watcher noticing the  approaching it will collect chunks that are stitched together:</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>There is a minor artefact in the final file. The stitched  sometimes contains silent padding at the start or end from incomplete chunks at buffer boundaries. A quick  pass fixes it cleanly:</p><div><pre tabindex=\"0\" data-language=\"bash\"><code data-language=\"bash\"></code></pre></div><p>Across all three versions, there‚Äôs a  or  helper. But the V3 implementation is subtly more robust than the V2 one, and it‚Äôs worth examining why.</p><p>V2‚Äôs version was straightforward:</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>This works, but it has a vulnerability: it hardcodes the native code string manually. If fermaw‚Äôs integrity check was especially paranoid and compared the spoofed string against the  native code string retrieved from a trusted reference (say, by calling <code>Function.prototype.toString.call(originalFunction)</code> on a cached copy of the original), the manually crafted string might not match precisely, particularly across different browser versions or platforms where the exact whitespace or formatting of  strings varies slightly.</p><p>I tried to solve it somewhat elegantly:</p><div><pre tabindex=\"0\" data-language=\"javascript\"><code data-language=\"javascript\"></code></pre></div><p>Instead of hardcoding the expected string, it captures the <em>actual native code string</em> from the original function before hooking it, then returns that exact string. This way, no matter what browser, no matter what platform, the spoofed  returns precisely the same string that the original function would have returned. It is, in effect, a perfect forgery.</p><p>Also note the use of <code>_call.call(_toString, original)</code> rather than simply . This is because  might itself be hooked by the time  is called. By holding cached references to  and <code>Function.prototype.toString</code> at the very beginning of the script (before any page code runs), and invoking them via those cached references, the  function is immune to any tampering that might have happened in the interim. It‚Äôs eating its own tail in the most delightful way.</p><h3>Ethics, Grandstanding, Pretentiousness, and Playing Wise</h3><p>DRM, as an industry institution, has an almost comically bad track record when it comes to actually protecting content. Denuvo which is perhaps the most sophisticated game DRM ever deployed commercially has been cracked for virtually every major game it‚Äôs protected, usually within weeks of release. Every DVD ever made is trivially rippable. Every Blu-ray. Every streaming service has been ripped by someone, somewhere.</p><p>The reason is always the same: the content and the key that decrypts it are both present on the client‚Äôs machine. The user‚Äôs hardware decrypts the content to display it. The user‚Äôs hardware is, definitionally, something the user controls. Any sufficiently motivated person with the right tools can intercept the decrypted output.</p><p>For a small NSFW audio platform run by a solo developer, ‚Äútrue‚Äù blackbox DRMs running with TEEs are not a realistic option. Which brings me to the point I actually want to make:</p><p><strong>The HotAudio DRM isn‚Äôt stupid because fermaw is stupid. It‚Äôs the best that JavaScript-based DRM can be.</strong> He implemented client-side decryption, chunked delivery, and active anti-tamper checks and for the vast majority of users, it absolutely works as friction. Someone who just wants to download an audio file and doesn‚Äôt know what a browser extension is will be stopped completely.</p><p>The problem is that calling it ‚ÄúDRM‚Äù sets expectations it simply cannot meet. Real DRM, you know; the kind that requires a motivated attacker to invest serious time and expertise to defeat; lives in hardware TEEs and requires commercial licensing. JavaScript DRM is not that. It‚Äôs sophisticated friction. And sophisticated friction, while valuable, is a completely different thing.</p><p>The question is whether any DRM serves ASMRtists well. Their audience is, by and large, not composed of sophisticated reverse engineers. The people who appreciate their work enough to want offline copies are, in many cases, their most dedicated fans. The kind who would also pay for a Patreon tier if one were offered. The people who would pirate the content regardless are not meaningfully slowed down by JavaScript DRM; they simply won‚Äôt bother and will move on to freely available content or‚Ä¶ hunt down extensions that do the trick, I suppose.</p><p>I‚Äôm genuinely not convinced the DRM serves the creators it‚Äôs designed to protect. But I acknowledge that this is a harder conversation than just the technical one, and reasonable people can disagree.</p><p>I got all the dopamine I needed from ‚Äúreverse engineering‚Äù this ‚ÄúDRM.‚Äù I don‚Äôt imagine there‚Äôs any point continuing its development considering the fact that I have made my point abundantly clear even beyond this very article.</p><p>I hate DRM, I love FOSS, I love the very idea that the internet should be open and accessible.</p><p>Unfortunately, the Internet is no longer just a toy for the nerds amongst us. For many, it‚Äôs a source of income and a way to put food on the table. So I do understand that DRM is in turn a way for people to feel protected against ‚Äúpirates‚Äù threatening their livelihoods. I don‚Äôt think it works the way it‚Äôs intended to work but I suppose I cannot fault fermaw for wanting to create a solution for the ASMRtists who felt they needed it.</p><p>Just‚Ä¶ don‚Äôt do it with JavaScript ffs.</p>",
      "contentLength": 24577,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rga6md/people_are_still_writing_javascript_drm/"
    },
    {
      "title": "The problem with Dorsey's Block layoffs and the veiled nature of AI productivity growth",
      "url": "https://www.reddit.com/r/artificial/comments/1rga39a/the_problem_with_dorseys_block_layoffs_and_the/",
      "date": 1772206977,
      "author": "/u/spacetwice2021",
      "guid": 48911,
      "unread": true,
      "content": "<p>Jack Dorsey just laid off half of Block's workforce, framing it around AI. The stock went up. This should make you uneasy, and not for the reasons most people are talking about.</p><p>There's a fundamental information problem at the heart of all this. Genuine AI integration, actually embedding it into workflows and organisation, is slow, expensive, and largely invisible to the outside world. Productivity gains from AI take time to show up in the numbers, and even then they're hard to attribute properly. Investors can't see it clearly or early enough to act on it.</p><p>Headcount reductions, on the other hand, are immediate and unambiguous. They show up in a press release, a quarterly filing, a headline. They're legible in a way that real transformation is not.</p><p>The consequence of this asymmetry is predictable. The market rewards what it can observe. And what it can observe is cuts, not capability. For executives whose compensation is tied to shareholder value, the calculus is straightforward. They do what the market rewards, and right now the market is rewarding AI-framed layoffs whether or not the underlying capability is there. This is clearly visible in the rally around the Block stock.</p><p>This is where narrative contagion comes in, which may already be starting. Once a few high-profile companies establish the pattern and get a valuation bump, it sets the benchmark. Boards start asking why they're not keeping pace. The pressure to follow isn't rooted in productivity, but rather the fear of being the company that didn't act while everyone else did. Each announcement reinforces the narrative, which raises the perceived reward for the next one, which produces more announcements. The cycle feeds itself even when genuine productivity increases are still far away (we have yet to see it in the data!).</p><p>The firms most susceptible to this are arguably the ones with the weakest genuine AI integration. Companies that are actually good at deploying AI tend to find it raises the productivity of their remaining workforce and would rather expand. But for some, a headline about workforce transformation is the easiest card to play. The worse the substance, the more you depend on the signal.</p><p>And here's the collective problem. Every company acting in its own rational self-interest of maximising shareholder value by playing the signal game produces an outcome that's irrational in aggregate. The signals partially cancel out as everyone does the same thing, but the jobs don't come back. You end up with widespread displacement, muted productivity gains, and a weakened consumer base that eventually feeds back into the economy these same companies depend on.</p><p>None of this means AI won't eventually justify real restructuring at some companies. It will in all likelihood, even if human work remains a critical bottleneck (which it will for the foreseeable future). But right now there is a meaningful gap between what the market is rewarding and what AI is actually delivering beyond some half-baked Claude Code solutions (don't get me wrong, I love and use CC, but it still has massive problems for large scale and complex work), and the incentive structure is pushing companies to close that gap with optics rather than substance. The people bearing the cost of that gap aren't shareholders, at least for now.</p>",
      "contentLength": 3312,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Do you use gorm or raw sql?",
      "url": "https://www.reddit.com/r/golang/comments/1rg9t4p/do_you_use_gorm_or_raw_sql/",
      "date": 1772206340,
      "author": "/u/Leading-West-4881",
      "guid": 48936,
      "unread": true,
      "content": "<p>For backend development in Go, especially in production systems, do you prefer using an ORM like GORM or writing raw SQL? What are the trade-offs?</p>",
      "contentLength": 146,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "[Log4J] Addressing AI-slop in security reports",
      "url": "https://github.com/apache/logging-log4j2/discussions/4052",
      "date": 1772206090,
      "author": "/u/BlueGoliath",
      "guid": 48938,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rg9p7u/log4j_addressing_aislop_in_security_reports/"
    },
    {
      "title": "Our workflow engine is a markdown file my boss wrote in English and Claude Code running as a K8s job",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rg9b2b/our_workflow_engine_is_a_markdown_file_my_boss/",
      "date": 1772205176,
      "author": "/u/kotrfa",
      "guid": 48873,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Singleton with state per thread/goroutine",
      "url": "https://www.reddit.com/r/golang/comments/1rg98rs/singleton_with_state_per_threadgoroutine/",
      "date": 1772205029,
      "author": "/u/SnooSongs6758",
      "guid": 48868,
      "unread": true,
      "content": "<p>Hi! I'm creating a microservice to answer RESTful requests. In certain scenarios, I need to use a single database transaction for multiple operations. The problem is that I don't want to require all database functions and the domain model to receive a transaction parameter. Imagine having to pass the transaction through all the functions. It seems gross to me.</p><p>I want to create a singleton that holds all transactions from the http request threads, but it seems GoLang doesn't support it. Any idea of how can I implement it?</p>",
      "contentLength": 525,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Claude Code on OpenShift with vLLM and Dev Spaces",
      "url": "https://piotrminkowski.com/2026/02/27/claude-code-on-openshift-with-vllm-and-dev-spaces/",
      "date": 1772202779,
      "author": "/u/piotr_minkowski",
      "guid": 48847,
      "unread": true,
      "content": "<p>This article explains how to&nbsp;run Claude Code on OpenShift as a VSCode plugin and then integrate it with AI models deployed on OpenShift using vLLM. vLLM supports the Anthropic Messages API, which Claude Code by default uses to communicate with Anthropic‚Äôs servers. Claude Code can be installed in several different ways. The VSCode extension for Claude Code is particularly relevant to the topic of this article. You can run VSCode in OpenShift as a container using OpenShift Dev Spaces (Eclipse Che community project). On the other hand, OpenShift relies heavily on vLLM in support for running AI models. This article aims to provide a complete recipe for using OpenShift tools to configure your development environment to run Claude Code and AI models on the same cluster.</p><p>Feel free to use my source code if you‚Äôd like to try it out yourself. To do that, you must clone my sample GitHub&nbsp;<a href=\"https://github.com/piomin/claude-ai-spring-boot.git\">repository</a>. Then you should only follow my instructions. This repository contains several branches, each with an application generated from the same prompt using different models. This article shows how to generate code using the  model running on OpenShift vLLM. So switch to the starting branch ‚Äì .</p><p>The repository version located in the  branch contains the necessary configuration for VSCode and Claude Code to work correctly in the OpenShift environment.</p><p>For this exercise, you must have an AWS account and an OpenShift cluster created there. You must also have the appropriate resources and permissions in your account to create an OpenShift node with a GPU. Of course, you can repeat a very similar exercise on infrastructure other than AWS.</p><p>The following <a href=\"https://piotrminkowski.com/2025/05/12/openshift-ai-with-vllm-and-spring-ai/\">article</a> explains how to install and configure OpenShift AI to run nodes with NVIDIA GPU support and how to deploy AI models on those nodes. In this exercise, I will not show you how to run the model on OpenShift AI, but simply use the vLLM server on a node with a GPU. If you want to automate the installation of operators required to properly serve GPU for AI models on OpenShift, just clone the following <a href=\"https://github.com/piomin/terraform-openshift/tree/master/ai\">repository</a> with Terraform scripts.</p><h2>Enable GPU Support in OpenShift</h2><p>The article mentioned above describes in detail the steps involved in installing a GPU node on OpenShift, so I will only briefly mention a few key points. Several issues also need to be updated. We will run exactly this <a href=\"https://huggingface.co/RedHatAI/gpt-oss-20b\">model</a> from RedHatAI Hugging Face. This model was post-trained with MXFP4 quantization. Therefore, it also requires a specific GPU in order to run properly. In my case, the  machine in AWS is enough. So, we should create a machine pool with at least one node on OpenShift using the  machine.</p><p>Then, you must install and configure the NVIDIA GPU operator. Create the  object using default values and verify its status.</p><p>After that, you must install the Node Feature Discovery operator and create the  object. Once again, you just need to click it in the OpenShift console with the default values, or just use my Terraform script.</p><p>You can use the vLLM server directly to run an AI model. It is pretty straightforward. I‚Äôm using the latest image from the Red Hat repository with NVIDIA GPU support: <code>registry.redhat.io/rhaiis/vllm-cuda-rhel9:3.3</code>. It is important to use exactly this version or a newer one because support for the Anthropic Messaging API is a relatively new feature in vLLM . The  machine provides 4 GPUs, so I will use all available resources for the best possible performance . As I mentioned earlier, I use the  model . For vLLM, it is also important to set the name under which the model is served, as we will use it later in API calls . Finally, don‚Äôt forget to insert your Hugging Face token value .</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p>Let‚Äôs create a Kubernetes  for that model:</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p>The simplest way to expose the model API outside a cluster is via OpenShift . However, we will access the model internally, from a container in which VSCode will be running. So, just in case, here‚Äôs the command that creates a  for the .</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p>Let‚Äôs verify if our pod with the AI model is running. Note which node this pod is running on.</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p>Now, let‚Äôs take a moment to look at the detailed description of our node. As you can see, the current request for the GPU () is .</p><h2>Enable Claude Code in OpenShift Dev Spaces</h2><p>Finally, we can move on to installing OpenShift Dev Spaces and configuring the Claude Code plugin in VSCode. First, find the right operator and install it as shown below. Then, create the devspaces project (namespace) and click the <em>Red Hat OpenShift Dev Spaces instance Specification</em> link when you are in this namespace.</p><p>Then click the Create  button. You can leave the default values everywhere except for the <code>spec.components.pluginRegistry.openVSXURL</code> field. It must contain the  address.</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p>Within a few minutes, Dev Spaces should be available on your cluster.</p><p>Now we can move on to configuring Claude Code. The entire configuration is available in our sample repository. We need to create two configuration files in the repository root:  and <code>.claude/settings.local.json</code>. The extension.json contains a list of recommended extensions for VSCode. Interestingly, all recommended extensions are automatically installed in OpenShift Dev Spaces on startup üôÇ Therefore, we recommend the Claude Code extension.</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><p>The <code>.claude/settings.local.json</code> file specifies Claude Code configuration settings for the current repository. First of all, we must override the default Anthropic API server address with the internal URL in OpenShift of our AI model . To do that, we must use the  environment variable. Our model doesn‚Äôt require an API key (the simplest demo installation), but we still need to set . By default, Claude Code tries to sign in to your Anthropic account. It was unnecessary, and, in addition, in Dev Spaces, it meant I had to log in endlessly. Fortunately, we can omit it using the <code>CLAUDE_CODE_SKIP_AUTH_LOGIN</code> environment variable.</p><div data-code-block-pro-font-family=\"Code-Pro-JetBrains-Mono\"><pre tabindex=\"0\"><code></code></pre></div><h2>Use Claude Code with VSCode</h2><p>Finally, we can run an OpenShift Dev Spaces instance with our sample codebase. Provide the address of the sample Git repository. Don‚Äôt forget you should use the  branch in my repository.</p><p>After a few moments, Dev Spaces starts VSCode in the web browser with our sample repository source code and automatically installs the Claude Code plugin. Then you can just start using Claude to generate your source code. You can repeat the exact same exercise I described in my <a href=\"https://piotrminkowski.com/2026/02/17/create-apps-with-claude-code-on-ollama/\">article</a> about Claude Code on Ollama.</p><p>Below is a screenshot from the battlefield üôÇ</p><p>Claude Code is currently having its momentum. From OpenShift‚Äôs perspective, it is important that the entire development environment can be contained within the RedHat cluster and products in this case. With vLLM, we can run various AI models in OpenShift. In turn, we use Eclipse Che to install and configure an IDE for developers. Claude Code can be easily run and configured on top of those tools.</p>",
      "contentLength": 6821,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/kubernetes/comments/1rg89i2/claude_code_on_openshift_with_vllm_and_dev_spaces/"
    },
    {
      "title": "Bcachefs creator insists his custom LLM is female and \"fully conscious\"",
      "url": "https://www.ursaclimb.com/verticals/news/bcachefs-creator-insists-his-custom-llm-is-female-and-fully-conscious-dfc5f112",
      "date": 1772198337,
      "author": "/u/DontFreeMe",
      "guid": 48822,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rg6ftt/bcachefs_creator_insists_his_custom_llm_is_female/"
    },
    {
      "title": "hledger-tui: just another terminal user interface for managing hledger journal transactions",
      "url": "https://www.reddit.com/r/linux/comments/1rg69s5/hledgertui_just_another_terminal_user_interface/",
      "date": 1772197891,
      "author": "/u/Complete_Tough4505",
      "guid": 48912,
      "unread": true,
      "content": "<p>I've been using hledger for a while to manage my personal finances. The CLI is great, but it gets verbose fast. The built-in UI is limited, and the few alternative projects out there are mostly abandoned or barely maintained.</p><p>So I built my own: hledger-tui, a terminal user interface for hledger built with Python and Textual. View, create, edit, and delete transactions with simple keyboard shortcuts, no need to touch the journal file directly.</p><p>It started as a personal tool, and it still is ‚Äî but I figured someone else might find it useful.</p><p>I'm currently working on a reporting system, so more is coming. There are no official builds for Linux yet, so you'll need to set it up manually ‚Äî the README has everything you need.</p><p>Feedback and bug reports are very welcome.</p>",
      "contentLength": 770,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "The error handling bugs that worry me aren't the ones that crash",
      "url": "https://www.reddit.com/r/golang/comments/1rg5zo7/the_error_handling_bugs_that_worry_me_arent_the/",
      "date": 1772197156,
      "author": "/u/___oe",
      "guid": 49050,
      "unread": true,
      "content": "<p>I recently found error handlers in Grafana Loki, Canonical Juju, and Chromium's LUCI that would panic if they were ever executed (<a href=\"https://github.com/grafana/loki/pull/20668\">Loki</a>, <a href=\"https://github.com/juju/juju/pull/21852\">Juju</a>, <a href=\"https://chromium-review.googlesource.com/c/infra/luci/luci-go/+/7603275\">LUCI</a>).</p><p>But honestly? The fixes were easy. I didn't need to explain much in the pull requests above: the crashes are obvious, and no dependent code relies on the broken behavior.</p><p>Those aren't the bugs I care much about.  advises to \"Crash Early\" because a dead program does a lot less damage than a malfunctioning one. Don't get me wrong, <a href=\"https://blog.cloudflare.com/18-november-2025-outage/#memory-preallocation\">crashing in production is bad</a>, but even an  panic in an error handler gives you a stack trace and a straightforward fix.</p><p>The bugs I'm concerned about are the : error handling code that compiles, passes review, and then quietly does the wrong thing in production. It logs the wrong error. It swallows context. It writes bad state to the database because an  target didn't match what the author assumed.</p><p>We test our happy paths rigorously, but error handlers are often neglected. They‚Äôre the least-exercised code in the codebase, yet when something does go wrong in production, that‚Äôs exactly the code we‚Äôre relying on.</p><p>I built the linter (<a href=\"https://github.com/fillmore-labs/errortype#errortype\"></a>) to catch some of these issues, but static analysis only goes so far.</p><p>So I'm curious: <strong>how do you actually test your error paths?</strong></p><p>Do you use mocks, fault injection, or something else to exercise them? Or (if we're being honest) is it mostly code review and the occasional production incident?</p><p>For an obscure error path that is incredibly hard to trigger, is it even worth the effort to test?</p><p>No judgment ‚Äî I think this is genuinely hard, especially for external dependencies where you can‚Äôt always control what errors come back, or where returned errors change between versions. Would love to hear how your team handles it.</p><p> To explain the background of this post: I've posted three pull request to major open source projects with crashing bugs, and thinking about them I realized that not the crash was the issue, but that the error handling has never been tested. I wondered how many untested error paths exist, and what peoples experiences with them are.</p><p>I'm baffled by the misreading of the article, and wonder where I may have misrepresented what I'm trying to say. And I'm a little repelled by some comments, how little some people are interested in being constructive. While this post might not help Reddit, I hope at least the patches are useful - they, and thinking about the issue was the main part of the work.</p>",
      "contentLength": 2438,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Claude Code as a K8s CronJob - how we do it and what we learned running it in production (with examples)",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rg5c67/claude_code_as_a_k8s_cronjob_how_we_do_it_and/",
      "date": 1772195239,
      "author": "/u/kotrfa",
      "guid": 48813,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Docker, Traefik, and SSE streaming: A post-mortem on building a managed hosting platform",
      "url": "https://clawhosters.com/blog/posts/building-managed-hosting-platform-tech-deep-dive",
      "date": 1772192974,
      "author": "/u/yixn_io",
      "guid": 49021,
      "unread": true,
      "content": "<p>Two weeks ago, ClawHosters went live. Today the platform runs with roughly 50 paying customers and 25 more in trial. All from Reddit, no marketing budget, alongside a regular 40-hour job.</p><p>And I'll tell you right now: none of it went smoothly.</p><p>This isn't a sales pitch for my product. It's a technical post-mortem about building a managed hosting platform for AI agents. Real code, real mistakes, and real nights where the Telegram bot pings at 2 AM because a customer instance is stuck in a crash loop.</p><p>The stack: <a href=\"https://clawhosters.com/en/services/custom-webapps\">Rails 8 monolith</a>, PostgreSQL, Sidekiq with 5 processes and 50 threads total, Clockwork for scheduling, <a href=\"https://docs.hetzner.com/cloud/servers/backups-snapshots/overview/\" target=\"_blank\" rel=\"noopener noreferrer\">Hetzner Cloud API</a> for infrastructure. Each customer gets their own VPS with OpenClaw running in Docker.</p><p>Everything on one server. No Kubernetes, no ECS, no managed database. That's a decision, not a limitation.</p><h2>Why Docker (and Why 70% of My Headaches)</h2><p>The decision to isolate OpenClaw in Docker containers instead of running it directly on the VPS was deliberate. It was also the source of at least 70% of all technical problems. I'd still do it again.</p><p>The problem without Docker: if a customer process goes rogue (and it does, more on that soon), it can eat all memory, fill the disk, corrupt the OS. With Docker I get:</p><p> The OpenClaw container can't touch my host services. SSH, Docker daemon, node_exporter, all unreachable from inside the container.</p><p> 3 GB, 6 GB, or 14 GB depending on tier. OpenClaw hits these regularly.</p><p> Even if the container is completely borked, I can SSH to the host, inspect logs, fix configs, restart. If the customer had trashed the VPS itself, I'd be rebuilding from scratch.</p><p> The  sits on the host filesystem. I can fix configs without even starting the container.</p><p>But Docker brought so many problems that I sometimes wondered if I'd made a terrible mistake.</p><h3>The Docker Problems in Detail</h3><p> pnpm creates symlinks in , and  flat-out refuses to handle them. Updates have to stream files via  instead. Sounds trivial. The error messages were cryptic enough to cost me hours.</p><p><strong>mDNS/Bonjour auto-discovery.</strong> The gateway picks up the Docker bridge IP (172.18.x.x) instead of localhost, causing cryptic \"gatewayUrl override rejected\" errors. Fix: an environment variable that disables the behavior. Finding that variable almost made me lose my mind.</p><p> Node doesn't handle SIGCHLD properly. Without  as PID 1, zombie processes pile up in the container. You don't notice immediately. Only when the process table fills up after a few days.</p><p><strong>Nginx Host header validation.</strong> Nginx inside the container validates the Host header, so direct IP access returns 403. Good for security, but it makes debugging harder because health checks need to send the correct Host header.</p><p><strong>Container recreation destroys runtime state.</strong> This was the biggest one. Every update, every SSH enable, every config change that would normally require recreating the container means losing everything: customer-installed packages, runtime data, conversation history. You can't just <code>docker-compose down &amp;&amp; docker-compose up</code>. I have to  first to preserve the writable layer, then apply changes. For config changes, I built a hot-reload system that sends SIGUSR1 to the process instead of touching the container at all.</p><h3>The Writable Layer Strategy</h3><p>Customers can install packages inside their container. , , , whatever they need. Those changes live in Docker's <a href=\"https://docs.docker.com/engine/storage/drivers/overlayfs-driver/\" target=\"_blank\" rel=\"noopener noreferrer\">writable layer (OverlayFS)</a>. The entire update and maintenance system is designed to preserve this layer.</p><p>I use , never . Before any operation that might recreate the container, I run  to bake the writable layer into the base image. Backup images get cleaned up after successful updates to reclaim disk. They're 15 to 25 GB each.</p><p>Why not volumes? Because the customer potentially modifies files everywhere in the filesystem. A volume for  and one for  and one for... no. The writable layer captures everything regardless of where.</p><h2>5-Layer Subdomain Routing</h2><p>Every customer instance gets a subdomain like <code>my-assistant-x7k2.clawhosters.com</code>. Getting traffic from the browser to the right VPS takes five layers. Yes, five.</p><h3>Layer 1: Cloudflare Wildcard DNS</h3><p>One  record points everything to my server. No per-instance DNS records. Cloudflare terminates SSL publicly, then connects to the server via a 15-year origin certificate.</p><h3>Layer 2: Nginx Regex Match</h3><p>Nginx captures the subdomain with a regex , blocks reserved words (www, api, mail, admin), and forwards to Traefik on port 8090. Critical here:  and <code>proxy_request_buffering off</code>. Why that matters comes in the SSE section.</p><h3>Layer 3: Traefik with Redis-Backed Dynamic Routing</h3><p>This is where it gets interesting. <a href=\"https://doc.traefik.io/traefik/providers/redis/\" target=\"_blank\" rel=\"noopener noreferrer\">Traefik</a> reads its routing table from Redis. When Rails provisions an instance, it writes the routing rules atomically in a Redis MULTI block:</p><pre><code>traefik/http/routers/&lt;subdomain&gt;/rule = \"Host(`&lt;subdomain&gt;.clawhosters.com`)\"\ntraefik/http/services/&lt;subdomain&gt;/loadbalancer/servers/0/url = \"http://&lt;vps-ip&gt;:8080\"\n\n</code></pre><p>It also registers per-instance bcrypt-hashed basic auth middleware. Traefik picks up changes instantly via keyspace notifications. No restart needed.</p><h3>Layer 4: VPS-Side Nginx (Inside Docker)</h3><p>On the customer's VPS, nginx runs as a sidecar container on port 8080. It only accepts the correct Host header and proxies to OpenClaw on internal port 18789. Everything else gets a 403 with \"Access denied. Use your subdomain.\" Last line of defense against direct IP access.</p><h3>Layer 5: Hetzner Firewall + fail2ban</h3><p>Production instances get a Hetzner Cloud Firewall at creation time. It blocks everything except 8080, 9100, 22, and 9993/udp for ZeroTier. The firewall rules only allow incoming connections from my production server's IP, so customer VPS instances aren't directly reachable from the public internet. fail2ban is pre-configured in the snapshot for SSH brute force protection.</p><p>A sync service runs every 10 minutes, adding missing routes and removing orphaned ones. A health service runs every 5 minutes, making actual HTTP requests through Traefik with the correct Host header to verify end-to-end routing. If Traefik's Redis subscription breaks after a Redis restart (it happens), it auto-restarts the Traefik service.</p><h2>The LLM Proxy: SSE Streaming and Why Nginx Breaks Everything</h2><p>Customers can use our managed LLM instead of bringing their own API key. Their OpenClaw points at , which exposes an OpenAI-compatible completions API. It's the same principle I use for individual <a href=\"https://clawhosters.com/en/services/llm-workflows\">LLM workflow projects</a>.</p><p>No token management, no API keys to rotate. Each VPS has a unique Hetzner IPv4 (unique index in the DB). When a request comes in, we look up which instance owns that IP. IPv6 uses PostgreSQL's CIDR containment operator because Hetzner assigns /64 blocks. The OpenClaw config has a dummy apiKey field only because the client refuses to send requests without one.</p><h3>The Three Streaming Nightmares</h3><p><strong>1. TCP chunk fragmentation.</strong> SSE events are delimited by . But HTTP chunks from upstream providers are raw TCP segments. A single chunk can contain half an SSE event, or three events glued together. I had to build a re-framing buffer that accumulates chunks, splits on  boundaries, and only forwards complete events to the client. Sounds simple. Took way too long to get all the edge cases right.</p><p><strong>2. Nginx buffering kills SSE.</strong> This is a <a href=\"https://github.com/gin-gonic/gin/issues/1589\" target=\"_blank\" rel=\"noopener noreferrer\">well-documented problem</a> that hits dozens of projects. But in a multi-layer stack it gets really ugly. Two nginx layers (main server + Traefik's upstream path) means two places where buffering can silently accumulate the entire response before forwarding. Without the fix, the client just hangs for 30 seconds and then gets everything at once. \"Streaming\" in name only.</p><p>As <a href=\"https://oneuptime.com/blog/post/2025-12-16-server-sent-events-nginx/view\" target=\"_blank\" rel=\"noopener noreferrer\">this nginx SSE guide explains</a>, you need , , , <code>chunked_transfer_encoding off</code>, AND  as a response header from Rails. All of them. Not just one.</p><p>I missed the response header and spent hours debugging why streaming worked locally but not in production.</p><pre><code># nginx config for SSE streaming\nlocation /v1/ {\n    proxy_pass http://upstream;\n    proxy_buffering off;\n    proxy_cache off;\n    proxy_http_version 1.1;\n    chunked_transfer_encoding off;\n    proxy_set_header Connection '';\n    proxy_set_header X-Accel-Buffering no;\n}\n\n</code></pre><pre><code># Rails Controller - Response Headers for SSE\nresponse.headers['Content-Type'] = 'text/event-stream'\nresponse.headers['Cache-Control'] = 'no-cache'\nresponse.headers['X-Accel-Buffering'] = 'no'\nresponse.headers['Transfer-Encoding'] = 'chunked'\n\n</code></pre><p><strong>3. Usage billing with streaming.</strong> Providers only send token counts in the very last SSE chunk. But Rails is mid-stream, and you can't hold the entire response in memory (that defeats the purpose of streaming). Solution: a ring buffer of only the last 4 KB of SSE data. After the stream ends, I scan the buffer for the usage JSON. The  block also closes the upstream HTTP connection. Leaked connections pile up fast. Learned that one the hard way.</p><p> Some providers don't actually support streaming for certain models. When a client sends  but the upstream returns a normal JSON response, the controller wraps it into a fake SSE sequence so the client always gets consistent SSE regardless.</p><p>Routes through Anthropic, OpenAI, DeepSeek, Google, OpenRouter, or Nvidia depending on the model. On 5xx from the primary, auto-falls back to OpenRouter with a tier-appropriate model. 4xx errors pass through (that's the caller's problem). Rate limited at 60 req/min general, 10 req/min for reasoning models. Redis down? Fail open.</p><h2>Token Billing: The Gap Between Observability and Invoice</h2><p>The streaming proxy was running. Token data was flowing through. I had no idea what to put on a customer's invoice.</p><p>How do you bill for token usage when every provider counts tokens differently, names them differently, and sometimes doesn't report them at all?</p><p>As <a href=\"https://portkey.ai/blog/tracking-llm-token-usage-across-providers-teams-and-workloads/\" target=\"_blank\" rel=\"noopener noreferrer\">Portkey's token tracking guide</a> documents: \"Different model providers count, tokenize, and bill tokens differently.\" Two identical prompts produce different token counts on GPT-4 vs Claude vs DeepSeek.</p><p>Every provider reports token usage differently.</p><p>Anthropic sends  in the last SSE event with  and . Relatively reliable. OpenAI sends it in the last chunk too, but the format differs slightly. DeepSeek? Sometimes the usage is just missing for certain models. Google Gemini calculates in \"characters\" instead of \"tokens\" in some API versions.</p><p>The ring buffer approach from the streaming section is the first layer. If the tail end of the SSE data contains the usage object, we parse it. If not, we fall back to an estimate based on chunk byte size times a provider-specific factor.</p><h3>Observability vs. Invoice</h3><p>There's a difference between \"I roughly know how many tokens that was\" and \"I can put this on a customer's invoice.\" For observability, a rough counter is fine. For invoicing, you need:</p><ol><li><strong>Exact attribution per request</strong> to a customer instance (via IP-based auth)</li><li><strong>Provider-specific pricing</strong> (Claude Sonnet costs differently than GPT-4o costs differently than DeepSeek)</li><li><strong>Separation of input and output tokens</strong> (output is 3 to 5 times more expensive at most providers)</li><li><strong>Pro-rating at month boundaries</strong> (customer signs up on the 15th, do they pay half?)</li><li> when the ring buffer missed the usage data</li></ol><p>Every LLM request gets stored with instance ID, provider, model, input tokens, output tokens, and exact cost in the database. Each tier includes a token allowance. The included tokens get consumed first. Once they're used up, additional usage gets billed per claw instantly. No waiting until month end, no manual reconciliation. Provider-specific price differences (Claude vs GPT-4 vs DeepSeek) are normalized through a pricing table that gets updated when providers change rates.</p><h2>Provisioning: Snapshot-Based with Pre-Warmed Pool</h2><p>Everything is pre-baked into a <a href=\"https://docs.hetzner.com/cloud/servers/backups-snapshots/overview/\" target=\"_blank\" rel=\"noopener noreferrer\">Hetzner snapshot</a>. Docker, the OpenClaw image (pre-pulled), Playwright/Chromium browsers, fail2ban, SSH hardening. When a VPS boots from the snapshot, cloud-init only regenerates SSH host keys and machine-id, then restarts Docker. About 3 minutes to ready.</p><p>Fly.io described the same problem as <a href=\"https://fly.io/blog/fly-machines/\" target=\"_blank\" rel=\"noopener noreferrer\">\"latency whack-a-mole\"</a>: \"every time you solve one bottleneck, the next one becomes visible.\" They solved it with Firecracker microVMs and separate create/start operations. I use a pre-warmed pool.</p><p>Servers get created from the snapshot in advance, with a placeholder container already running. Customer orders, the code atomically claims a pre-warmed VPS, renames it via the Hetzner API, and deploys the real config. Near-instant.</p><p>A pool manager job (runs every 10 minutes) checks how many free pre-warmed VPS instances are available. When the count drops below a configurable minimum, it automatically orders more. The target pool size is also seasonally adjusted: weekday nights get a higher buffer because that's when signups tend to spike.</p><p>The deployment itself is just SCP config files +  + health check polling +  + SIGUSR1 for hot reload. No packages installed, no images pulled. That's the whole point: everything slow happens at snapshot build time. By deploy time, there's nothing left to install.</p><p>Hetzner recycles IPs from deleted servers. This caused two bugs.</p><p>First: stale SSH known_hosts entries broke connections even with . The fix was <code>UserKnownHostsFile=/dev/null</code>. Second: stale IPs in our database could point to wrong servers. Fix: query the Hetzner metadata service from inside the VPS before trusting SSH.</p><p>The second bug is actually the scarier one. \"Stale IP points to wrong server\" means in the worst case: we deploy a customer's config onto someone else's VPS. That would have been a significant security problem. It never happened because we caught it first. But it was close.</p><p>This topic deserves its own section because it's been the biggest operational pain point. And it still is.</p><p>OpenClaw's config () is a single JSON file with nested keys for LLM providers, messenger tokens, gateway settings, agent behavior, tool permissions. Customers can edit it through OpenClaw's CLI. They make typos, delete required keys, set invalid values, and then their OpenClaw crashes in a loop and they open a support ticket.</p><p>OpenClaw v2026.2.23 changed the gateway to , which requires a specific  flag set to true. Flag missing? Instant crash loop. And OpenClaw's own  command sometimes removes flags that we need. Fixing one thing breaks another.</p><p><strong>Layer 1: controlUi flag protection.</strong> After every config change (even unrelated ones), the system re-downloads the config and verifies that three critical gateway flags are present and true. If  or the customer stripped them, they get restored before the reload happens.</p><p><strong>Layer 2: Automatic health monitoring + repair.</strong> Every running instance gets polled. After 4 consecutive health check failures, a config repair service kicks in automatically. It SSHes to the instance, reads the last 100 lines of container logs, and pattern-matches fixes:</p><ul><li><p>Invalid  value: deletes the bind key</p></li><li><p>\"Cannot parse configuration\": regenerates the entire gateway section from a template</p></li><li><p>\"Unknown configuration key\": runs  with the new version's code</p></li><li><p>\"Permission denied\": chmod fix</p></li></ul><p>After applying fixes it also validates that critical fields aren't empty and restores  to the canonical list.</p><p><strong>Layer 3: Dashboard transparency.</strong> Config state, health status, container logs, VPS metrics (CPU/RAM/disk/network via node_exporter) are all surfaced in the customer dashboard. If their OpenClaw is crash-looping, they can see the error, see which config key is wrong, and at least try fixing it themselves before opening a ticket.</p><h2>OpenClaw Updates and the Config Migration Registry</h2><p>OpenClaw releases new versions frequently, and they like changing config defaults in breaking ways. A key that was optional becomes mandatory. A default changes from permissive to restrictive. If you just update the binary without migrating the config, the gateway doesn't boot.</p><pre><code>REGISTRY = [\n  { version: \"2026.2.22\", key: \"tools.exec.host\", default: \"node\" },\n  { version: \"2026.2.23\", key: \"gateway.controlUi.dangerouslyAllowHostHeaderOriginFallback\",\n    default: true },\n  { version: \"2026.2.23\", key: \"browser.ssrfPolicy.dangerouslyAllowPrivateNetwork\",\n    default: true },\n  { version: \"2026.2.24\", key: \"agents.defaults.sandbox.docker.dangerouslyAllowContainerNamespaceJoin\",\n    default: true },\n  { version: \"2026.2.25\", key: \"agents.defaults.heartbeat.directPolicy\",\n    default: \"allow\" },\n]\n\n</code></pre><p>During updates, the system reads the current config, applies only migrations between the old and new version, and only sets keys that are missing (respects customer customizations). The version gets tracked inside the config itself.</p><p> Upload a pre-built tarball (extracted from the upstream Docker image), stream files into the running container via tar (not  because symlinks), run config migrations, , , health check polling, commit the updated container. Backup image created before, cleaned up after.</p><h2>ZeroTier: One-Way Networking for Local LLMs</h2><p>This one surprised me. Customers wanted their OpenClaw to reach devices on their private ZeroTier network. The number one use case: local LLMs. People run Ollama or LM Studio on their home machine and want their hosted OpenClaw to use it without exposing anything to the public internet. Other use cases: NAS, home servers, internal APIs.</p><p>A second container runs alongside OpenClaw on the same Docker bridge network. It joins the customer's ZeroTier network ID. Then I use  to inject a route into OpenClaw's network namespace:</p><pre><code>nsenter -t &lt;openclaw_pid&gt; -n ip route add &lt;zt_subnet&gt; via &lt;zt_docker_bridge_ip&gt;\n\n</code></pre><p>The ZeroTier container does NAT masquerading for outbound traffic. OpenClaw can reach the ZT network, but the ZT network <strong>cannot initiate connections back into OpenClaw</strong>. No return route. One-way by design.</p><p>The customer's home network stays safe. Their OpenClaw can call their local LLM, but nothing on the ZT side can poke into the container. And the ZeroTier container itself runs inside Docker with no access to the host VPS. Even if a customer's ZeroTier network is compromised, the attacker is stuck inside a container that can't reach the host.</p><p>The whole thing is maybe 50 lines of actual logic.</p><p>I expected weeks of networking pain. Days with , frustrated customers, routing anomalies I couldn't reproduce. Instead: it just worked. The route gets re-injected automatically after any container restart.</p><p>Worth pausing to think about why. ZeroTier does exactly one thing, does it in userspace, and does it well. The  route injection pattern was the only non-trivial decision. Everything else was just configuration.</p><p>A week after launch, I lost the plot. Five instances stuck in \"deploying\" state, three of them for over an hour. Two customers had already filed tickets. The Sidekiq worker handling the deploy job had died mid-run, and the instance had no idea.</p><p>The monitoring system that came out of that afternoon is built directly from that experience.</p><p>A provisioning manager job runs every 5 seconds and catches stuck instances. If something has been in \"deploying\" state but the VPS is actually healthy on port 8080, it marks it running. If the deploy job died, it re-queues it. Instances stuck in \"provisioning\" for 20+ minutes get flagged for manual review.</p><p>After 4 consecutive health failures: automatic config repair. After 5: admin alerts to Telegram and email. New instances get a 10-minute grace period. Every recovery path has been battle-tested by actual failures over the past weeks.</p><p>Docker's own <a href=\"https://docs.docker.com/engine/containers/start-containers-automatically/\" target=\"_blank\" rel=\"noopener noreferrer\">restart policies</a> only help so much here.  triggers only when the container process exits. A container that's running but deadlocked, consuming all memory at the application layer, or unable to connect to its LLM API won't be automatically restarted. You need your own health monitoring layer for that.</p><p>Concretely with Prometheus: I track <code>openclaw_health_check_consecutive_failures</code> per instance. Anything over 3 triggers an escalation. Before I had this, I thought I'd notice problems manually. I was wrong.</p><p>I have roughly 50 paying customers now and about 25 more still in trial. Just from Reddit, no other marketing. I've talked to a lot of them, and a lot of people who didn't convert from trial. The consistent takeaway: it's <a href=\"https://www.index.dev/blog/ai-agents-statistics\" target=\"_blank\" rel=\"noopener noreferrer\">practically impossible</a> for non-coders to run OpenClaw smoothly, or even at all. The config complexity alone filters out 90% of potential users.</p><p>I started as a script kiddy 23 years ago, been a professional developer for over 10 years. Previously built and ran a <a href=\"https://clawhosters.com/en/projects/golem-overlord\">crypto browser game from scratch</a>. Had a large Rocket League tracking site, <a href=\"https://clawhosters.com/en/projects/rltracker\">RLTracker</a>, that funded self-employment for years. But I've never hit this many problems around a single piece of software.</p><p>OpenClaw itself is incredibly unstable. Config formats change between minor versions, defaults flip without warning,  sometimes makes things worse. Building a reliable managed service around it is an enormous job, and that's really the core of what a managed hosting platform does: not run the product yourself, but make it reliably runnable for others.</p><p>Yeah, plenty of competitors popped up before me and even more since. But I know the problems from the inside now: the config migrations, the crash loops, the IP recycling, the SSE buffering. Someone who hasn't debugged those things firsthand builds around those problems, not through them. You can see it in the products.</p><p><a href=\"https://venturebeat.com/infrastructure/railway-secures-usd100-million-to-challenge-aws-with-ai-native-cloud\" target=\"_blank\" rel=\"noopener noreferrer\">Railway chose to build their own data centers</a> instead of running on Google Cloud. That let them maintain 50% lower pricing than hyperscalers. I use the same basic idea with Hetzner directly instead of going through AWS or GCP. Own the stack instead of renting abstractions. The tradeoff is complexity vs control and pricing flexibility.</p><p>If I started over tomorrow, a few things.</p><p><strong>Observability from day one.</strong> I added monitoring after the fact. What that meant in practice: when customer one hit a crash loop, I had no logs, no metrics, nothing. I sat at a terminal and guessed. Prometheus and node_exporter on every VPS from the start would have reduced an hour of debugging to five minutes.</p><p><strong>Config validation before writing, not after the crash.</strong> I now validate before a config change gets applied. If I'd done that from the beginning, I'd have avoided dozens of support tickets. Every one of them was a customer messaging me at 11 PM because their OpenClaw stopped responding.</p><p><strong>Plan the billing system earlier.</strong> Retrofitting a token metering pipeline into a running streaming proxy was painful. The streaming code was optimized for performance, not observability. Refactoring everything without breaking the stream, while customers are actively using it. Don't do that to yourself.</p><p>And maybe, just maybe, I shouldn't have built all of this alongside a full-time job. The support tickets during work hours... let's just say my employer knows and is actually supportive of this kind of thing.</p><p>If you're thinking about building a similar managed hosting platform: the biggest problems don't come from building it. They come from operating it afterward.</p>",
      "contentLength": 22748,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rg4li5/docker_traefik_and_sse_streaming_a_postmortem_on/"
    },
    {
      "title": "Weekly: Share your victories thread",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rg3pb9/weekly_share_your_victories_thread/",
      "date": 1772190043,
      "author": "/u/AutoModerator",
      "guid": 48798,
      "unread": true,
      "content": "<p>Got something working? Figure something out? Make progress that you are excited about? Share here!</p>",
      "contentLength": 98,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Hello my company wants to move it's VMs in gcp to kubernetes",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rg3ock/hello_my_company_wants_to_move_its_vms_in_gcp_to/",
      "date": 1772189975,
      "author": "/u/whatsinaname5021",
      "guid": 48799,
      "unread": true,
      "content": "<p>I am a devops intern in this company and another co worker and I have been given a task to containerise a staging environment vm to kubernetes completely but we have to learn kubernetes via scratch. Can anyone tell how long this process can take? And a proper roadmap on what to learn and the prerequisites?</p>",
      "contentLength": 307,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "What‚Äôs the one Go project that made you stick with the language?",
      "url": "https://www.reddit.com/r/golang/comments/1rg3ml0/whats_the_one_go_project_that_made_you_stick_with/",
      "date": 1772189811,
      "author": "/u/itsme2019asalways",
      "guid": 48820,
      "unread": true,
      "content": "<p>Maybe it was a concurrent script, a simple API, a backend service, or a tooling experiment ‚Äî Go‚Äôs speed and clarity tend to hook people early.</p><p>Which project made you feel Go just ‚Äúgets things done‚Äù?</p>",
      "contentLength": 205,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "What‚Äôs the first Rust project that made you fall in love with the language?",
      "url": "https://www.reddit.com/r/rust/comments/1rg3lby/whats_the_first_rust_project_that_made_you_fall/",
      "date": 1772189692,
      "author": "/u/itsme2019asalways",
      "guid": 48872,
      "unread": true,
      "content": "<p>For many people, it‚Äôs something small ‚Äî a CLI tool, a microservice, or a systems utility ‚Äî that suddenly shows how reliable, fast, and clean Rust feels.</p><p>Which project gave you that ‚Äúwow, this language is different‚Äù moment?</p>",
      "contentLength": 231,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "I never estimate on the call. Best engineering rule I made for myself.",
      "url": "https://l.perspectiveship.com/re-auru",
      "date": 1772189646,
      "author": "/u/dmp0x7c5",
      "guid": 48871,
      "unread": true,
      "content": "<p>It‚Äôs 1:1 with the client. He says it‚Äôs important: ‚ÄúWe need to have this feature on production by the end of today. We count on you, Micha≈Ç. Can you get it done?‚Äù.</p><p>I want to help. After 5 seconds of processing the problem, I say: ‚ÄúYes, of course. You can count on me‚Äù. Fast forward a few hours later and I deeply regret it. The feature is way more complicated than I thought. I end up working until 2 AM.</p><p>I got into trouble because of my rushed answers. I promised to deliver features even though it was impossible in the timeline I gave, I hired people fast and regretted it afterwards.</p><p>I knew that it was my flaw, but I found a cure. Now, I have a set of automatic rules to follow:</p><p>While making commitments:</p><ul><li><p>I don‚Äôt estimate anything during a call with the client.</p></li><li><p>I don‚Äôt make hiring decisions the same day as the final interview.</p></li></ul><ul><li><p>I don‚Äôt schedule meetings back-to-back without at least 15-minute breaks.</p></li><li><p>I don‚Äôt push big changes to production before leaving.</p></li><li><p>I wait 2 days before any impulse purchase.</p></li></ul><div><p><a href=\"https://fs.blog/knowledge-project-podcast/daniel-kahneman-2/\" rel=\"\">Daniel Kahneman</a></p></div><p>When you click to delete a file and the action is irreversible, you get a confirmation dialogue: ‚ÄúDo you really want to delete this file? This action can‚Äôt be undone‚Äù. This simple pause has saved many files on people‚Äôs computers and now in cloud storage.</p><p>It‚Äôs impossible to prevent biases from happening, but using circuit breakers in your processes can stop them from leading to bad decisions.</p><p>I started setting these rules after analysing my past decision logs and trying to learn from them. The most beneficial ones are ones that force me to pause:</p><p>Where can you find ideas to set your own rules? Ask yourself:</p><ul><li><p>When do I feel most pressured to answer when I‚Äôm not confident about?</p></li><li><p>What situations lead me to commit or do things I later regret?</p></li><li><p>Where do I consistently underestimate or overcommit?</p></li></ul><p><strong>What rule would have saved you from your worst decision this month?</strong></p><p>Great articles which I‚Äôve read recently:</p>",
      "contentLength": 1945,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rg3kw1/i_never_estimate_on_the_call_best_engineering/"
    },
    {
      "title": "What's the most idiomatic way to deal with partial borrows/borrow splitting?",
      "url": "https://www.reddit.com/r/rust/comments/1rg3ftw/whats_the_most_idiomatic_way_to_deal_with_partial/",
      "date": 1772189169,
      "author": "/u/philogy",
      "guid": 48939,
      "unread": true,
      "content": "<p>I'm continuously running into this problem when writing Rust and it's seriously making me want to quit. I have some large struct with lots of related data that I want to group in a data structure for convenience with different methods that do different things, however because the borrow checker doesn't understand partial borrows across function boundaries I keep getting errors for code like this:</p><pre><code>struct Data { stuff: Vec&lt;u32&gt;, queue: Vec&lt;u32&gt;, } impl Data { fn process(&amp;mut self, num: u32) { self.queue.push(num); } fn process_all(&amp;mut self) { for &amp;num in &amp;self.stuff { // Error: cannot borrow `self` because I already borrowed `.stuff` self.process(num); } } } </code></pre><p>Do you just say \"f*ck structs\" and pass everything member? Do you manually split members on a case by case basis as needed? How do you deal with this effectively?</p><p>I've been writing Rust for various things for over 2 years now but this is making me seriously consider abandoning the language. I feel very frustrated, structs are meant to be the fundamental unit of abstraction and the way of grouping data. I just want to \"do the thing\".</p><p>It seems I either have to compromise on performance, using intermediary Vecs to accumulate and pass around values or just split things up as needed.</p>",
      "contentLength": 1248,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "oapi-codegen v2.6.0: 7th anniversary release",
      "url": "https://github.com/oapi-codegen/oapi-codegen/releases/tag/v2.6.0",
      "date": 1772188907,
      "author": "/u/profgumby",
      "guid": 48821,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rg3dch/oapicodegen_v260_7th_anniversary_release/"
    },
    {
      "title": "I got the ThinkBook Plus Gen 1 E-ink lid display working on Linux ‚Äî first open-source driver",
      "url": "https://www.reddit.com/r/linux/comments/1rg2y5m/i_got_the_thinkbook_plus_gen_1_eink_lid_display/",
      "date": 1772187422,
      "author": "/u/Still_Complex8652",
      "guid": 48869,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Slok finally can beat Sloth and Pyyra",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rg2mep/slok_finally_can_beat_sloth_and_pyyra/",
      "date": 1772186288,
      "author": "/u/Reasonable-Suit-7650",
      "guid": 48797,
      "unread": true,
      "content": "<p>Slok just reached a level that neither Pyrra nor Pyrra nor Sloth can. The first version of  composition is now available. It is still unstable and under active development, but it works ‚Äî and it opens up a class of SLO modeling that, to my knowledge, no other open-source operator supports today.</p><p>What is  Most SLO tools let you define objectives on individual services. Some, like Slok, let you compose multiple SLOs together ‚Äî for example, taking the worst-performing service in a group (AND/MIN logic). That is already useful. But it doesn‚Äôt model the real world well enough.<p> Real traffic is not uniform. In many systems, different requests follow different paths through your services, and those paths have very different failure characteristics. </p> is built for exactly this.</p><p>The idea is simple: you describe the routes your traffic actually takes, assign a weight to each one (reflecting the traffic share), and Slok computes the overall error rate as a weighted combination of the per-route failure probabilities.</p><pre><code>apiVersion: observability.slok.io/v1alpha1 kind: SLOComposition metadata: name: checkout-weighted namespace: app spec: # Target availability percentage for the composed SLO. target: 99.9 # Observation window. Must match one of the supported windows (7d or 30d). window: 30d # objectives: maps logical aliases to actual Kubernetes SLO resources. # Aliases are referenced in route chains, decoupling logical names # from Kubernetes resource names. objectives: - name: base # alias used in route chains ref: name: checkout-base-slo # ServiceLevelObjective resource name namespace: app # if omitted, inherits the composition namespace - name: payments ref: name: payments-slo namespace: app - name: coupon ref: name: coupon-slo namespace: app composition: type: WEIGHTED_ROUTES params: routes: # Main path: no coupon applied (90% of traffic). # Route success rate = (1 - e_base) * (1 - e_payments) - name: no-coupon weight: 0.9 # value in [0, 1]; all weights must sum to 1.0 chain: - base # aliases defined in objectives, executed in order - payments # Coupon path: coupon service is called between base and payments (10% of traffic). # Route success rate = (1 - e_base) * (1 - e_coupon) * (1 - e_payments) - name: with-coupon weight: 0.1 chain: - base - coupon # inserted between base and payments - payments </code></pre><p>The overall composed error rate is then:</p><pre><code>e_total = 1 - ( 0.9 √ó (1 - e_base) √ó (1 - e_payments) + 0.1 √ó (1 - e_base) √ó (1 - e_coupon) √ó (1 - e_payments) ) </code></pre><p><em>: This post was originally written in Italian and translated with AI assistance to make the concepts clear in English.</em></p>",
      "contentLength": 2604,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Log4j - Addressing AI-slop in security reports",
      "url": "https://github.com/apache/logging-log4j2/discussions/4052",
      "date": 1772185074,
      "author": "/u/FryBoyter",
      "guid": 48812,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rg2ah5/log4j_addressing_aislop_in_security_reports/"
    },
    {
      "title": "Apache Iggy's migration journey to thread-per-core architecture powered by io_uring",
      "url": "https://iggy.apache.org/blogs/2026/02/27/thread-per-core-io_uring/",
      "date": 1772183103,
      "author": "/u/spetz0",
      "guid": 48846,
      "unread": true,
      "content": "<p>At Apache Iggy, performance is one of our core principles. We take pride in being blazingly fast, pushing our systems to reach the absolute limits of the underlying hardware, eventually exhausting all available options within our previous architecture. Thus, a new approach was needed. If you're an active Rust Reddit user, you may have already seen <a href=\"https://www.reddit.com/r/rust/comments/1pn6010/compio_instead_of_tokio_what_are_the_implications/\" rel=\"noreferrer noopener\" target=\"_blank\">this discussion</a>. It predates this blog post, and we wanted to use it as an opportunity to explore the thread-per-core shared-nothing architecture powered by  in more depth.</p><p>To explain the \"whys\" of that decision in detail, a quick primer on the status quo is needed.\nApache Iggy utilized  as its async runtime, which uses a multi-threaded work-stealing executor. While this works great for a lot of applications (work stealing takes care of load balancing), fundamentally it runs into the same problem as many \"high-level\" libraries: a lack of control.</p><p>When  starts, it spins up  worker threads (typically one per core) that continuously execute and reschedule . The scheduler decides on which worker a particular  gets to run, which can lead to task migrations between workers, cache invalidations, and less predictable execution paths. While Rust  and  bounds prevent data-race undefined behavior, they do not prevent higher-level concurrency bugs such as <a href=\"https://github.com/apache/iggy/pull/1567\" rel=\"noreferrer noopener\" target=\"_blank\">deadlocks</a>.</p><p>But even these challenges weren't what finally tipped us over the edge. The way  handles block device I/O was the real dealbreaker. Tokio, following the poll-based Rust  model, uses (depending on the platform) a notification-based mechanism to perform I/O on file descriptors. The runtime subscribes for a readiness notification for a particular descriptor and  the readiness in order to submit the I/O operation. While this works decently well for network sockets, it's completely incompatible for block devices. The Linux kernel considers regular files to be always \"ready\" for reading or writing, meaning  (or similar notification mechanisms) will immediately return, and the subsequent I/O operation will block the executing thread anyway (on page-cache lock contention or other kernel operation). To overcome this issue,  relies on a thread pool approach. It outsources every block device I/O operation to a shared blocking thread pool, where threads are spawned on demand. By default,  allows this blocking thread pool to grow up to 512 threads. A high-performance system can quickly exhaust the capabilities of such a thread pool (leaving aside the overhead from servicing 512 threads), which is why we concluded that  doesn't scale for our needs.</p><p>The thread-per-core shared-nothing architecture is what we landed on when it comes to improving the scalability of Apache Iggy. It has been proven to be successful by high-performance systems such as <a href=\"https://github.com/scylladb/scylladb\" rel=\"noreferrer noopener\" target=\"_blank\">ScyllaDB</a> and <a href=\"https://github.com/redpanda-data/redpanda\" rel=\"noreferrer noopener\" target=\"_blank\">Redpanda</a>, both of those projects utilize the <a href=\"https://github.com/scylladb/seastar\" rel=\"noreferrer noopener\" target=\"_blank\">Seastar</a> framework to achieve their performance goals.</p><p>In short, the core philosophy behind this approach is to pin a single thread to each CPU core, partition your resources based on a heuristic (commonly hashing), eliminate shared state, thereby <a href=\"https://www.scylladb.com/2024/10/21/why-scylladbs-shard-per-core-architecture-matters/\" rel=\"noreferrer noopener\" target=\"_blank\">reduce lock contention and improve cache locality</a> and finally, use message passing for communication between those threads, also known as  in  terminology. Sounds like a good plan, but as with everything, the devil is in the details.</p><p><img alt=\"Diagram of thread per core shared nothing architecture\" loading=\"lazy\" width=\"2760\" height=\"1720\" decoding=\"async\" data-nimg=\"1\" src=\"https://iggy.apache.org/_next/static/media/sharding.b5c5f63d.png\">\nFrom a bird's-eye view, this architecture solves the primary issues of our previous approach: we move from  to . That's a big W, but we were still left with block-device I/O. Using a thread pool for file operations would ultimately negate the performance gains from core pinning, so we needed a truly asynchronous I/O interface, and that is how we discovered .</p><p>There is plethora of materials regarding  as it's the hot thing, but very briefly the interface is straightforward,  rather than being a notification system (readiness based), it's completion-based, you submit the operation and the kernel drives it to completion. The core mechanism revolves around two lock-free ring buffers shared between user space and the kernel: the , where your application enqueues I/O requests, and the , where the kernel places the results once the operations are done. Since that model isn't compatible with how Rust  works (Futures are poll-based), the initial poll of the  is used for the  of the request. A continuation via callback model would fit the completion I/O paradigm better, but it comes with its own caveats, nevertheless the overhead from the impedance mismatch is negligible. As for the  part, it's a simple peek into the CQ, looking for a completion entry that matches the polled  at hand ( allows attaching a usize  cookie to each submission, which is used to identify the corresponding user-space  and wake it up). Everything else, let's pretend for a moment, is .</p><p>With all the design pieces in place, it was time to visit the marketplace of . We evaluated 3 candidates:</p><p>All of them support  as the driver, some exclusively, others as one of several available ones.</p><p>Using the FIFO order - <a href=\"https://github.com/bytedance/monoio\" rel=\"noreferrer noopener\" target=\"_blank\">monoio</a> was our choice for the initial <a href=\"https://github.com/apache/iggy/tree/io_uring_monoio_runtime\" rel=\"noreferrer noopener\" target=\"_blank\">proof-of-concept</a>, it worked pretty well, but as we explored the monstrous API surface of , we realized that it's pretty far behind when it comes to feature parity and doesn't appear to be very actively maintained. Don't get us wrong, the runtime still receives patches, especially after <a href=\"https://www.reddit.com/r/rust/comments/1gfi5r1/async_rust_is_not_safe_with_io_uring/\" rel=\"noreferrer noopener\" target=\"_blank\">incidents like this</a>, but the overall pace of development doesn't keep up with a rapidly evolving interface like .</p><p>Next on the list <a href=\"https://github.com/DataDog/glommio\" rel=\"noreferrer noopener\" target=\"_blank\">glommio</a> - this one is particularly interesting as it was initially developed by , who previously worked at , the creators of the  framework,  significantly differs from the other two runtimes on our list. It's still a thread-per-core runtime, but it uses a proportional-share scheduler, creates 3  instances per thread (a main ring, a latency ring, and a polling ring), and ships with quite a lot of high-level APIs (similar to ) that one can use. Unfortunately, it followed the same fate as ,  it's pretty much unmaintained at this point. On top of that, it's fairly opinionated as a runtime, and we disagreed with some of those opinions (more on that later).</p><p>Finally, <a href=\"https://github.com/compio-rs/compio\" rel=\"noreferrer noopener\" target=\"_blank\">compio</a> - this is what we ended up using. It's very similar to  in terms of architecture, but it stands out for its broad  feature coverage, active maintenance (our patches got <a href=\"https://github.com/compio-rs/compio/pull/440\" rel=\"noreferrer noopener\" target=\"_blank\">merged within hours</a>), and its codebase structure. Unlike , the  codebase is structured in a way where the  is disaggregated from the , meaning that one can build their own executor while still reusing the  driver.</p><p>Notably,  boxes the I/O request that is submitted to the SQ, which means that every I/O request incurs a heap allocation, something that  avoids. In our case, it's not that big of a deal, as those allocations are very small and  is quite good at maintaining a pool for small, predictable allocations. We did raise the question in their  channel about whether it would be feasible to use a  allocator the approach that  takes, but the authors decided against it, as it would introduce a lot of complexity into the executor, which uniformly supports other drivers such as .</p><p>Remember how we mentioned that <strong>the devil is in the details</strong>? Let's give him mic now.</p><p>At first glance since the thread-per-core shared-nothing model all state is local to each shard and anything that requires a  view must be replicated across shards via message passing, it looks like a perfect candidate for , replace your  with  and run with the quick win. If you thought that, I've got bad news, you'd be greeted straight from the ninth circle of Dante's Inferno with:</p><blockquote><p>thread 'shard-8' (496633) panicked at core/server/src/streaming/topics/helpers.rs:298:21:\nRefCell already borrowed</p></blockquote><p>Turns out that holding a  borrow across an  point can cause runtime borrow panics, there is even a clippy lint for that - <code>clippy::await_holding_refcell_ref</code>.</p><p>The Rust  (async working group) seems to be aware of that footgun and describes it in <a href=\"https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_wants_to_use_ghostcell.html\" rel=\"noreferrer noopener\" target=\"_blank\">this story</a>. It  like it should be possible to express statically-checked borrowing for  using primitives such as , they even share a <a href=\"https://crates.io/crates/stakker\" rel=\"noreferrer noopener\" target=\"_blank\">proof-of-concept runtime</a> that does exactly that, but achieving an ergonomic API indistinguishable from normal Rust would probably require significant changes to the compiler and the  passed with .</p><p>We didn't give up (yet) on interior mutability, rather, we reasoned about the underlying problem and attempted to solve it with a better API.</p><p>The issue is that during  points, the executor can potentially yield the execution context to another , and that other  may attempt to borrow the same , causing a panic at runtime since the borrow from the first  is still active. We ran into this often because our data structures followed an OOP-style of <strong>compile time hierarchy that matches the domain model</strong>, which looked akin to that.</p><figure dir=\"ltr\" tabindex=\"-1\"><div role=\"region\" tabindex=\"0\"><pre><code></code></pre></div></figure><p>The  procedure can be split into two parts</p><ul><li>The mutation of the in-memory state</li><li>The I/O operation using </li></ul><p>This way our  can be much more granular, we use it only for the in-memory representation of , while the storage is stored out of bounds, but for that, we needed a bigger gun, let us introduce  (Entity Component System).</p><p>One might be familiar with  from game engines, not from message streaming platforms, personally I think the general idea behind ECS -  (Struct of arrays) is fairly underrated in general.\nWhat we did is split the  (Streams, Topics, Partitions, etc.) into their components, where each component is stored in its own dedicated collection.</p><p>In this case, our components are  and . This allows us to write:</p><figure dir=\"ltr\" tabindex=\"-1\"><div role=\"region\" tabindex=\"0\"><pre><code></code></pre></div></figure><p>We accompany the  ECS with component closures that statically disallow  code inside a mutable borrow and voil√†.</p><p>Well, this approach crumbles just as miserably as the  attempt...</p><p>The thread-per-core shared-nothing architecture requires broadcasting events whenever state changes on one shard. For example, if  receives a  request, once it finishes processing, it broadcasts a  event through a channel to all other shards. On the receiving end, each shard has a background task that polls this channel for incoming events. The crux of the issue lies in the word .</p><p>In our  example, it might not look like a big deal, but in reality our other  were much more complicated, without even introducing other background workers that weren't necessary as part of the thread-per-core shared nothing architecture. A solution to this problem could be using  lock, but those can be <a href=\"https://rfd.shared.oxide.computer/rfd/0400\" rel=\"noreferrer noopener\" target=\"_blank\">footguns aswell</a>.</p><p>To our surprise, the issue persisted even in scenarios where we enforced a single-writer principle (we dedicated one shard to become the serialization point for all requests), which was the final nail in the coffin that led us to conclude the experiment as failure. Maintaining a non-shared but consistent state is much more difficult, than <em>just use message passing bro</em>.</p><p>After a long fight with , we gave up on trying to make fetch happen. Instead, we doubled down on the artifact from the previous iteration (the single-writer principle). We divided our  into two groups: shared, strongly consistent resources and sharded, eventually consistent ones. An example of a sharded resource is , while  and  remain shared and strongly consistent, this split later on coined name (Control Plane/Data Plane).</p><p>For shared resources, we decided to use <a href=\"https://github.com/jonhoo/left-right\" rel=\"noreferrer noopener\" target=\"_blank\"></a>, a concurrent data structure designed for a single writer and multiple readers. It works by maintaining two pointers to the underlying data: one for readers and one for the writer. During a writer commit, those pointers are swapped atomically (greatly simplifying). The single writer is the first shard - , while remaining shards have an  handle to the data. In case if a shard other than  would like mutate the data, it sends the request to  using <a href=\"https://github.com/zesterer/flume\" rel=\"noreferrer noopener\" target=\"_blank\">flume</a> channel.</p><p>As for our partitions, we maintain one shared table (DashMap) called  that functions as barrier to fence requests that would try to access  that is in the process of creation/deletion, the requests are still routed to appropriate shard that contains the , but by consulting the  (during the routing and after the routing), we make sure that the eventual consistency does not come to bite us.</p><p>This design turned out to be a can of worms, or a bottomless pit, if you prefer. There are plenty more questions to answer, for example, load balancing. In the  case, this was fairly simple because it was handled by the task-stealing executor. In our case, if access patterns are unpredictable and some shards become hotspots, we have to deal with that ourselves, a true double-edged sword. A theoretical optimization that we may employ in the future is to shard certain partitions across two or more shards, as proposed by withoutboats - <a href=\"https://without.boats/blog/thread-per-core/\" rel=\"noreferrer noopener\" target=\"_blank\">thread-per-core blog post</a></p><p>We can exploit the fact that our  uses , thus the partition can be sharded even harder based on the segment range and knowledge of which segments are sealed.</p><p>Getting the performance benefits out of  itself is a challenge on its own (it's not enough to just swap  with an  based runtime), in order to fully take advantage of the benefits from the  design one has to heavily batch syscalls, as this is the main advantage of such interface (less context switches, from userspace to kernel space), Rust  can be composed together pretty well to facilitate that, but you have to be careful!</p><p>The following code snippet, submits two I/O operations in one \"batch\", but  does not guarantee that the submission order = completion order!</p><p>This \"chain\" can potentially execute out of order and if your server would crash halfway through, your block device state is broken.</p><figure dir=\"ltr\" tabindex=\"-1\"><div role=\"region\" tabindex=\"0\"><pre><code></code></pre></div></figure><p>To submit a batch while preserving operation order, one must use the io_uring chaining flag  on the submitted SQEs, which brings us to the next point.</p><p>The problem is twofold: at the time of writing this blog post, there is no Rust equivalent of the  framework. That is unfortunate because  attempted to be one, but things changed: Glauber moved on to work on <a href=\"https://github.com/tursodatabase/turso\" rel=\"noreferrer noopener\" target=\"_blank\">Turso</a>, and the Datadog team does not seem to be actively maintaining the runtime while building <a href=\"https://www.datadoghq.com/blog/engineering/rust-timeseries-engine/\" rel=\"noreferrer noopener\" target=\"_blank\">a real-time time-series storage engine in Rust for performance at scale</a>. They mention  a lot there, but why did they decide to use , when they  a runtime that seems like a perfect fit for what they are trying to achieve?</p><p>Secundo problemo is that these runtimes imitate the  library APIs, which is  compliant, while many of 's most powerful features are not, leaving those capabilities out of reach for us mere mortals. Request chaining is only the tip of the iceberg, there is plenty more, for example  APIs for listen/recv, , and so on. Ultimately, , , and  are not the right abstractions. From the point of view of  compliance they are, but we cannot allow  to hold us all hostage.</p><p>It's worth noting that one of the key reasons we ended up going with  is that they want to move with the wind of time by exposing more and more  APIs. Their codebase is structured so that the driver is decoupled from the executor, I would push the pluggability even further. A very hot topic in distributed systems these days is  (Deterministic Simulation Testing): the idea is to replace all non-deterministic sources in your system (network, block devices, time, etc.) with deterministic ones, so that one can re-run the entire execution of the system from a single  value. At this moment, with async Rust, it is very difficult, if not borderline impossible, to achieve total determinism. The main factor is that one cannot easily replace, for example, the time wheel used for timeouts in those executors. If library authors designed their executors so you could plug in different implementations of the time wheel, scheduler, and driver interceptors for network/storage, we could  test our systems deterministically, with zero changes needed to the underlying codebase. No need for interfaces behind , no need for timeout managers that have to be replaced with deterministic ones; we could use all of the goodies that come from the Rust  model while maintaining the ability to test our systems deterministically.</p><p>Scaling is where the thread-per-core architecture truly shines, the more partitions and producers you throw at it, the better it performs.</p><p>The difference wasn't that big,  managed to keep up decently well with 8 producers, but as we increase the load, the gap widens significantly.</p><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div><p>Flush the data to disk on every batch write.</p><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div><div><table><thead><tr></tr></thead><tbody><tr></tr></tbody></table></div><p>Finally, even though we went into significant detail in this blog post, we have only scratched the surface of what is possible, and several subsections could easily be blog posts on their own. If you are interested in learning more about thread-per-core shared-nothing design, check out the  framework, it is the SOTA in this space. For now, we shift our attention to the <a href=\"https://github.com/apache/iggy/releases/tag/server-0.7.0\" rel=\"noreferrer noopener\" target=\"_blank\">ongoing work on clustering</a>, using <a href=\"https://sands.kaust.edu.sa/classes/CS240/F21/papers/vr-revisited.pdf\" rel=\"noreferrer noopener\" target=\"_blank\">Viewstamped Replication</a>.</p><p>Stay tuned a deep-dive blog post on that is coming, and we‚Äôre just getting started üöÄ</p>",
      "contentLength": 16771,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/rust/comments/1rg1qzp/apache_iggys_migration_journey_to_threadpercore/"
    },
    {
      "title": "[D] MICCAI 2026, Submission completed yesterday and saved, but still \"Intention-to-submit registered\"",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rg0xsm/d_miccai_2026_submission_completed_yesterday_and/",
      "date": 1772180094,
      "author": "/u/KingPowa",
      "guid": 48870,
      "unread": true,
      "content": "<p>Hi! I submitted 6 hours ago, before the deadline, however I still have my paper in state \"Intention-to-submit registered\". Just wanted to confirm this is the expected behaviour, it's the first paper I am submitting to this conference. Thanks!</p>",
      "contentLength": 242,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Who believes in vibe-coding?",
      "url": "https://medium.com/ai-in-plain-english/who-believes-in-vibe-coding-1796fdd27b43?sk=790fbf5e16a80ddc825ea3e9750dc451",
      "date": 1772178670,
      "author": "/u/bigbott777",
      "guid": 48796,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rg0jju/who_believes_in_vibecoding/"
    },
    {
      "title": "[D] PhD in AI but no job ‚Äî why not build your own?",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rg0glz/d_phd_in_ai_but_no_job_why_not_build_your_own/",
      "date": 1772178360,
      "author": "/u/EducationalTwo7262",
      "guid": 48763,
      "unread": true,
      "content": "<p>I‚Äôve been hanging around PhD-related subreddits for quite a while now. One thing I‚Äôve noticed is that a lot of people, after finishing their PhD, seem to struggle to find jobs ‚Äî whether that‚Äôs postdoc positions or roles in industry.</p><p>Maybe it‚Äôs the intense competition. Maybe it‚Äôs the post-Covid economic slowdown. Probably a mix of both.</p><p>It makes me wonder: with the level of training, research skills, and technical depth we have (especially those of us in AI/ML), is it really impossible to build something of our own?</p><p>More specifically ‚Äî can we create small projects, niche tools, or focused applications and actually monetize them?</p><p>I‚Äôm not naive. I know no one is going to openly share their exact money-making formula on Reddit. But maybe this could be a space to discuss broader angles ‚Äî potential niches, unmet needs, overlooked applications of AI, or even lessons learned from trying.</p><p>Instead of relying entirely on academic jobs or corporate hiring cycles, is there a realistic path for PhDs (particularly in AI) to build independent income streams or small businesses?</p><p>Curious to hear thoughts ‚Äî especially from people who‚Äôve tried, failed, pivoted, or succeeded.</p>",
      "contentLength": 1189,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "FiTui - A terminal based personal finance manager",
      "url": "https://www.reddit.com/r/linux/comments/1rg02qs/fitui_a_terminal_based_personal_finance_manager/",
      "date": 1772176956,
      "author": "/u/BeingSensitive9177",
      "guid": 48845,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Moving from Node.js to Go for backend ‚Äî need guidance",
      "url": "https://www.reddit.com/r/golang/comments/1rfzjqk/moving_from_nodejs_to_go_for_backend_need_guidance/",
      "date": 1772175092,
      "author": "/u/talhashah20",
      "guid": 48795,
      "unread": true,
      "content": "<div><p>I‚Äôve been building servers with Node.js and recently shifted to Go. Currently learning core concepts and building APIs with .</p><ul><li>How deep should I go into Go fundamentals before building production systems?</li><li>Is Gin a good long-term choice, or should I focus more on ?</li><li>What kind of projects should I build to become production-ready in Go backend?</li></ul><p>My goal is to build high-performance and scalable backend systems.</p><p>Appreciate any suggestions.</p></div>   submitted by   <a href=\"https://www.reddit.com/user/talhashah20\"> /u/talhashah20 </a>",
      "contentLength": 468,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Fed on Reams of Cell Data, AI Maps New Neighborhoods in the Brain",
      "url": "https://www.quantamagazine.org/fed-on-reams-of-cell-data-ai-maps-new-neighborhoods-in-the-brain-20260209/",
      "date": 1772172330,
      "author": "/u/Secure-Technology-78",
      "guid": 48888,
      "unread": true,
      "content": "<p>The algorithm was also able to identify new neighborhoods, regions that previous neuroscience methods, including the Allen Mouse Brain Common Coordinate Framework, had missed. Take the striatum, a striped, vaguely C-shaped structure near the middle of the brain. In maps of the mouse brain, where the striatum is called the caudoputamen, ‚Äúyou just see one huge structure,‚Äù said <a href=\"https://neurobio.ucla.edu/people/hourig-hintiryan-phd\">Hourig Hintiryan</a>, a neuroanatomist at the University of California, Los Angeles who wasn‚Äôt involved in the new project. It‚Äôs known to participate in movement, reward, and overall brain management. How could one piece of brain perform such disparate tasks?</p><p>CellTransformer‚Äôs explanation is that it‚Äôs not one uniform brain region after all. The map confirmed that the caudoputamen is, in fact, subdivided into smaller areas, although researchers have not yet matched each region to a function. Moreover, the new subdivisions corresponded nicely to a map that Hintiryan and colleagues <a href=\"https://www.nature.com/articles/nn.4332\">published in 2016</a> based on an entirely different technique, which traced connections between the caudoputamen and other regions.</p><p>Identifying such subregions across the brain, Hintiryan said, could resolve debates between neuroscientists who assign vastly different functions to the same large brain region. It seems likely that ‚Äúthey‚Äôre both correct, they‚Äôre just looking at different areas,‚Äù she said.</p><p>Abbasi-Asl and Tasic were thrilled with CellTransformer‚Äôs ability to accurately match known brain cartography, and even more excited that the algorithm mapped novel subdivisions. For example, the brainstem‚Äôs midbrain reticular nucleus, which is involved in initiating movement, is a fairly underexplored region, Abbasi-Asl said. CellTransformer picked out four new neighborhoods there. Each of those neighborhoods featured particularly prevalent cell types and specifically activated genes. They also had several cell types that earlier analyses had placed in an entirely different part of the brain.</p><p>The paper serves mainly to introduce the CellTransformer method and show that it can find novel regions; the thousand-plus new neighborhoods still require validation. As with any exploration of new territory, drawing the map is just the beginning. What‚Äôs most exciting is what scientists may be able to do with it. ‚ÄúThe more granular our understanding of structure, the more specific we can get with our interrogations and interventions,‚Äù Hintiryan said.</p><p>Emerging questions center on the functions of all these neural neighborhoods. To pinpoint what each bit does, scientists could eliminate or activate these newly identified regions in lab animals and then check for behavioral changes.</p><p>The real prize will be to apply CellTransformer to human brains. Doege suspects that some neighborhoods will match well between mice and people, while others will diverge. Unfortunately, the quantity of data the algorithm needs to make accurate predictions isn‚Äôt available from human brains ‚Äî at least, not yet. While the mouse brain contains about 100 million cells, the human brain has around 170 billion, and that menagerie is still undergoing genetic analysis. When sufficient amounts of that data become available, Abbasi-Asl and Tasic think CellTransformer will be up to the challenge.</p><p>They are also interested in incorporating other technologies, such as the connection tracing used by Hintiryan, into CellTransformer. This would be like adding streets and highways to the city neighborhoods. And beyond the brain, the same algorithm could offer detailed cell maps of other organs, allowing scientists to compare, for example, healthy versus diabetic kidneys.</p><p>Human scientists simply can‚Äôt sort out these details on their own. ‚ÄúI see AI as kind of a helper for the human,‚Äù Kim said. ‚ÄúDiscovery will be accelerated in a dramatic way.‚Äù</p>",
      "contentLength": 3829,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rfyqfz/fed_on_reams_of_cell_data_ai_maps_new/"
    },
    {
      "title": "Stop Expecting Your Best Engineer to Be a Good Mentor",
      "url": "https://levelup.gitconnected.com/stop-expecting-your-best-engineer-to-be-a-good-mentor-05eba3ff6c98?sk=d91cdc30a50aa785038f159d0c337370",
      "date": 1772166073,
      "author": "/u/Fantastic-Cress-165",
      "guid": 48734,
      "unread": true,
      "content": "<div><h2>Most of them can‚Äôt, and that‚Äôs not a character flaw.</h2></div><p>My son didn‚Äôt understand how to convert a fraction to a decimal.</p><p>I explained it. He nodded. I could tell from the nod that he hadn‚Äôt got it.</p><p>I explained it again, differently. He nodded again. Same nod.</p><p>By the third time, something in my voice had changed. I wasn‚Äôt shouting. But I wasn‚Äôt not-shouting either. My face was doing something I couldn‚Äôt control. He could see it. He‚Äôs eight and he‚Äôs very good at reading my face.</p><p>So he stopped trying to understand and started trying to guess. If he got the right answer, the face would stop.</p><p>No. We‚Äôre not ‚Äî that‚Äôs not ‚Äî look, you divide the top number by the bottom number. One divided by four. What‚Äôs one divided by four?</p><p>He didn‚Äôt know. He was too busy watching my face.</p><p>I know how to convert fractions to decimals. I‚Äôve known for so many years yet I have no idea how to easily explain it so he gets it.</p><p>I learnt there‚Äôs a concept in education called the curse of knowledge: once you know something well enough, you lose reliable‚Ä¶</p>",
      "contentLength": 1059,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rfwpwp/stop_expecting_your_best_engineer_to_be_a_good/"
    },
    {
      "title": "LXD 6.7 released with AMD GPU passthrough support",
      "url": "https://www.phoronix.com/news/LXD-6.7-Released",
      "date": 1772165915,
      "author": "/u/somerandomxander",
      "guid": 48762,
      "unread": true,
      "content": "<p>Michael Larabel is the principal author of Phoronix.com and founded the site in 2004 with a focus on enriching the Linux hardware experience. Michael has written more than 20,000 articles covering the state of Linux hardware support, Linux performance, graphics drivers, and other topics. Michael is also the lead developer of the Phoronix Test Suite, Phoromatic, and OpenBenchmarking.org automated benchmarking software. He can be followed via <a href=\"https://twitter.com/MichaelLarabel\">Twitter</a>, <a href=\"https://www.linkedin.com/in/michaellarabel/\">LinkedIn</a>, or contacted via <a href=\"https://www.michaellarabel.com/\">MichaelLarabel.com</a>.</p>",
      "contentLength": 500,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rfwo0t/lxd_67_released_with_amd_gpu_passthrough_support/"
    },
    {
      "title": "GNU Radio out-of-tree (OOT) module for QRadioLink blocks.",
      "url": "https://www.reddit.com/r/linux/comments/1rfur2z/gnu_radio_outoftree_oot_module_for_qradiolink/",
      "date": 1772160478,
      "author": "/u/erilaz123",
      "guid": 48937,
      "unread": true,
      "content": "<p>What it provides: It's a pretty broad collection of signal processing blocks, all with Python bindings and GRC block definitions:</p><p>Digital modulations/demodulations: 2FSK, 4FSK, 8FSK, GMSK, BPSK, QPSK, SOQPSK, DSSS, DSSS-CDMA (multi-user, configurable spreading factors 32‚Äì512), GDSS (Gaussian-distributed spread spectrum). Analog modulations: AM, SSB (USB/LSB), NBFM, WBFM. Digital voice: FreeDV, M17, DMR (Tier I/II/III), dPMR, NXDN (48 and 96 baud modes). MMDVM protocols: POCSAG, D-STAR, YSF, P25 Phase 1 ‚Äî all with proper FEC (BCH, Golay, Trellis). FEC: Soft-decision LDPC encoder/decoder with configurable code rates and block lengths. Supporting blocks: M17 deframer, RSSI tag block, CESSB.</p><p>Yes, it was made with AI assistance. I have a neurological condition that makes traditional programming impossible ‚Äî this project wouldn't exist otherwise. Before dismissing it as slop, here's the testing picture:</p><p>104+ million libFuzzer executions across 10 fuzz harnesses, zero crashes, zero memory leaks. 757 edges / 893 features discovered through coverage-guided fuzzing. 20/20 C++ unit tests passing (ctest). 41/41 MMDVM protocol tests passing (POCSAG, D-STAR, YSF, P25 protocol validation + block integration). 81 total tests across all suites ‚Äî 0 failures. M17 deframer tested with 34 crafted attack vectors (34 handled correctly, including 14 expected rejections). 42/42 Python-bound blocks tested ‚Äî 100% coverage.</p>",
      "contentLength": 1426,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "is it su-doo or su-doe?",
      "url": "https://www.reddit.com/r/linux/comments/1rfug86/is_it_sudoo_or_sudoe/",
      "date": 1772159667,
      "author": "/u/Vivid-Champion-1367",
      "guid": 48726,
      "unread": true,
      "content": "<p>strictly speaking it‚Äôs \"su-doo\" because \"substitute user do,\" right? but literally everyone i know says \"su-doe\" because \"su-doo\" makes you sound like a literal toddler.</p><p>i feel like the \"su-doo\" crowd is technically correct but morally wrong. what do you guys think?</p><p>no, i don't say \"su-doo\", and i pronounce it as \"su-doe\". just seriously curious</p>",
      "contentLength": 347,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Create simple yaml for debian image",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rftc4a/create_simple_yaml_for_debian_image/",
      "date": 1772156659,
      "author": "/u/dominbdg",
      "guid": 48764,
      "unread": true,
      "content": "<div><p>I have pulled latest debian image and I tried to start it. After 2 seconds image is going to stop.</p><p>I need to have simple script for debian image which will keeps it running.</p><p>Can someone can help me with that ?</p></div>   submitted by   <a href=\"https://www.reddit.com/user/dominbdg\"> /u/dominbdg </a>",
      "contentLength": 238,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "[D] ASURA: Recursive LMs done right",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rfskth/d_asura_recursive_lms_done_right/",
      "date": 1772154616,
      "author": "/u/Competitive-Rub-1958",
      "guid": 48823,
      "unread": true,
      "content": "<p>Recursive models like TRM/CTM/UT have create a lot of buzz lately. But they're rarely used outside of static, toy domains -  language.</p><p>In 2018, we saw \"Universal Transformers\" try this. However, follow-up works reveal that simple RLMs (recursive LMs) don't yield substantial performance gains w.r.t FLOPs spent</p><p>In this work, I argue that using some rather simple tricks, one can unlock huge performance gains and make RLMs outperform  and  baselines</p>",
      "contentLength": 447,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Anthropic rejects latest Pentagon offer: ‚ÄòWe cannot in good conscience accede to their request‚Äô",
      "url": "https://www.cnn.com/2026/02/26/tech/anthropic-rejects-pentagon-offer",
      "date": 1772154549,
      "author": "/u/Gloomy_Nebula_5138",
      "guid": 48718,
      "unread": true,
      "content": "<p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm41tpds000x27pca3bi8av6@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            Anthropic is rejecting the Pentagon‚Äôs latest offer to change their contract, saying the changes do not satisfy the company‚Äôs concerns that AI could be used for mass surveillance or in fully autonomous weapons.\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm421qjj00083b6rc5iitck9@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            The Pentagon and Anthropic <a href=\"https://www.cnn.com/2026/02/24/tech/hegseth-anthropic-ai-military-amodei\">are at odds</a> over restrictions the company places on the use of Claude, the first AI system to be used in the military‚Äôs classified network.\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm42uojo00003b6rvp4p2w2t@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            Defense Secretary Pete Hegseth told Anthropic CEO Dario Amodei on Tuesday that if Anthropic does not allow its AI model to be used ‚Äúfor all lawful purposes,‚Äù the Pentagon would cancel Anthropic‚Äôs $200 million contract. In addition to the contract cancellation, Anthropic would be deemed a ‚Äúsupply chain risk,‚Äù a classification normally reserved for companies connected to foreign adversaries, Pentagon officials said.\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm41x8za00033b6rszg85iyf@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            Anthropic said in a statement that the Pentagon‚Äôs new language was framed as a compromise but ‚Äúwas paired with legalese that would allow those safeguards to be disregarded at will.‚Äù\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm41xgab00063b6ruh1601es@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            In a lengthy <a href=\"https://www.anthropic.com/news/statement-department-of-war\" target=\"_blank\">blog post on Thursday,</a> Amodei wrote: ‚ÄúI believe deeply in the existential importance of using AI to defend the United States and other democracies, and to defeat our autocratic adversaries.‚Äù\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm428o9b000c3b6r2zqnzkob@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            Amodei said Anthropic understands that the Pentagon, ‚Äúnot private companies, makes military decisions.‚Äù But ‚Äúin a narrow set of cases, we believe AI can undermine, rather than defend, democratic values.‚Äù He also said use cases like mass surveillance and autonomous weapons are ‚Äúoutside the bounds of what today‚Äôs technology can safely and reliably do.‚Äù\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm42govz000l3b6rgwcdfg8f@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            Anthropic‚Äôs two exceptions have not slowed ‚Äúadoption and use of our models within our armed forces to date,‚Äù Amodei added.\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm47xnw800003b6r6l53qfrn@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            Amodei said the Pentagon‚Äôs ‚Äúthreats do not change our position: we cannot in good conscience accede to their request.‚Äù\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm4ahm8l00003b6r8wrx098h@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            In response, Emil Michael, the Pentagon‚Äôs Undersecretary for Research and Engineering who had been part of the negotiations, wrote on X: ‚ÄúIt‚Äôs a shame that <a href=\"https://x.com/DarioAmodei\" target=\"_blank\">@DarioAmodei</a> is a liar and has a God-complex. He wants nothing more than to try to personally control the US Military and is ok putting our nation‚Äôs safety at risk. The <a href=\"https://x.com/DeptofWar\" target=\"_blank\">@DeptofWar</a> will ALWAYS adhere to the law but not bend to whims of any one for-profit tech company.‚Äù\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm47ymkq00023b6r143y33hh@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            After Amodei‚Äôs post published, Anthropic staffers began publicly expressing support for their employer.\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm480sst00043b6rpp3lqisd@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            ‚ÄúTime and time again over my three year tenure at Anthropic I‚Äôve seen us stand to our values in ways that are often invisible from the outside. This is a clear instance where it is visible,‚Äù Trenton Bricken, a member of Anthropic‚Äôs technical team for alignment, wrote on X.\n    </p><p data-uri=\"cms.cnn.com/_components/paragraph/instances/cmm48386f00063b6rc2u990zj@published\" data-editable=\"text\" data-component-name=\"paragraph\" data-article-gutter=\"true\">\n            ‚Äú[H]istory is unfolding in front of us it‚Äôs now obvious and evident to everyone with eyes to see why anthropic founding was a crucial fork in the timeline, and how catastrophic the counterfactual would‚Äôve been otherwise,‚Äù wrote Gian Segato, a data science manager at Anthropic.\n    </p>",
      "contentLength": 3141,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rfsjv7/anthropic_rejects_latest_pentagon_offer_we_cannot/"
    },
    {
      "title": "How can I create an IaaS in a computer classroom",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rfs3w5/how_can_i_create_an_iaas_in_a_computer_classroom/",
      "date": 1772153393,
      "author": "/u/Rich_Entertainment68",
      "guid": 48719,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Advice on Learning K8s",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rfr2c3/advice_on_learning_k8s/",
      "date": 1772150742,
      "author": "/u/vegetto404",
      "guid": 48709,
      "unread": true,
      "content": "<p>is it worth it to learn k8s as a tunisian student ?</p><p>as you know k8s is meant for orchestrating in big projects but in tunisia we dont have much of that type.</p><p>I actually learnt some basics about k8s in the last month but still wondering if I have to get deeper or am I just wasting my time.</p><p>(maybe learning something else is more prioritary)</p>",
      "contentLength": 337,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Google API Keys Weren't Secrets. But then Gemini Changed the Rules.",
      "url": "https://trufflesecurity.com/blog/google-api-keys-werent-secrets-but-then-gemini-changed-the-rules",
      "date": 1772150694,
      "author": "/u/Chaoticblue3",
      "guid": 48706,
      "unread": true,
      "content": "<blockquote><p dir=\"auto\"> Google spent over a decade telling developers that Google API keys (like those used in Maps, Firebase, etc.) are not secrets. But that's no longer true: Gemini accepts the same keys to access your private data. We scanned millions of websites and found nearly 3,000 Google API keys, originally deployed for public services like Google Maps, that now also authenticate to Gemini even though they were never intended for it. With a valid key, an attacker can access uploaded files, cached data, and charge LLM-usage to your account. Even Google themselves had old public API keys, which they thought were non-sensitive, that we could use to access Google‚Äôs internal Gemini.</p></blockquote><img alt=\"\" width=\"800\" height=\"500\" src=\"https://framerusercontent.com/images/oFLh01kYhwzmLTqmgBAgUlN94.png\" srcset=\"https://framerusercontent.com/images/oFLh01kYhwzmLTqmgBAgUlN94.png?scale-down-to=512&amp;width=1600&amp;height=1000 512w,https://framerusercontent.com/images/oFLh01kYhwzmLTqmgBAgUlN94.png?scale-down-to=1024&amp;width=1600&amp;height=1000 1024w,https://framerusercontent.com/images/oFLh01kYhwzmLTqmgBAgUlN94.png?width=1600&amp;height=1000 1600w\" sizes=\"(min-width: 1000px) 100vw, (max-width: 999.98px) 100vw\"><p dir=\"ltr\">Google Cloud uses a single API key format () for two fundamentally different purposes:  and .</p><p dir=\"ltr\">For years, Google has explicitly told developers that API keys are safe to embed in client-side code. Firebase's own security checklist states that API keys are not secrets.&nbsp;</p><p dir=\"ltr\">Note: these are distinctly different from Service Account JSON keys used to power GCP.</p><img alt=\"\" width=\"625\" height=\"358\" src=\"https://framerusercontent.com/images/RqMXTB1joHV9KC0Ev6k7bhvOik.png\" srcset=\"https://framerusercontent.com/images/RqMXTB1joHV9KC0Ev6k7bhvOik.png?scale-down-to=512&amp;width=1251&amp;height=716 512w,https://framerusercontent.com/images/RqMXTB1joHV9KC0Ev6k7bhvOik.png?scale-down-to=1024&amp;width=1251&amp;height=716 1024w,https://framerusercontent.com/images/RqMXTB1joHV9KC0Ev6k7bhvOik.png?width=1251&amp;height=716 1251w\" sizes=\"(min-width: 1000px) 100vw, (max-width: 999.98px) 100vw\"><p dir=\"auto\"><a href=\"https://firebase.google.com/support/guides/security-checklist#api-keys-not-secret\" target=\"_blank\" rel=\"noopener\"><em>https://firebase.google.com/support/guides/security-checklist#api-keys-not-secret</em></a></p><p dir=\"ltr\">Google's Maps JavaScript documentation instructs developers to paste their key directly into HTML.&nbsp;</p><img alt=\"\" width=\"512\" height=\"486\" src=\"https://framerusercontent.com/images/wh5NC5mhFxNheNfOY5hH1OG8I.png\" srcset=\"https://framerusercontent.com/images/wh5NC5mhFxNheNfOY5hH1OG8I.png?scale-down-to=512&amp;width=1025&amp;height=973 512w,https://framerusercontent.com/images/wh5NC5mhFxNheNfOY5hH1OG8I.png?scale-down-to=1024&amp;width=1025&amp;height=973 1024w,https://framerusercontent.com/images/wh5NC5mhFxNheNfOY5hH1OG8I.png?width=1025&amp;height=973 1025w\" sizes=\"(min-width: 1000px) 100vw, (max-width: 999.98px) 100vw\"><p dir=\"auto\"><a href=\"https://developers.google.com/maps/documentation/javascript/get-api-key?setupProd=configure#make_request\" target=\"_blank\" rel=\"noopener\"><em>https://developers.google.com/maps/documentation/javascript/get-api-key?setupProd=configure#make_request</em></a></p><p dir=\"ltr\">This makes sense. These keys were designed as project identifiers for billing, and can be further restricted with (bypassable) controls like HTTP referer allow-listing. They were not designed as authentication credentials.&nbsp;</p><img alt=\"\" width=\"783\" height=\"364\" src=\"https://framerusercontent.com/images/Yol1Ipcab0PqV6e7nMFYXGkdnWQ.png\" srcset=\"https://framerusercontent.com/images/Yol1Ipcab0PqV6e7nMFYXGkdnWQ.png?scale-down-to=512&amp;width=1567&amp;height=729 512w,https://framerusercontent.com/images/Yol1Ipcab0PqV6e7nMFYXGkdnWQ.png?scale-down-to=1024&amp;width=1567&amp;height=729 1024w,https://framerusercontent.com/images/Yol1Ipcab0PqV6e7nMFYXGkdnWQ.png?width=1567&amp;height=729 1567w\" sizes=\"(min-width: 1000px) 100vw, (max-width: 999.98px) 100vw\"><p dir=\"ltr\">When you enable the Gemini API (Generative Language API) on a Google Cloud project, existing API keys in that project (including the ones sitting in public JavaScript on your website) can silently gain access to sensitive Gemini endpoints. No warning. No confirmation dialog. No email notification.</p><p dir=\"ltr\">This creates two distinct problems:</p><p dir=\"auto\"><strong>Retroactive Privilege Expansion.</strong> You created a Maps key three years ago and embedded it in your website's source code, exactly as Google instructed. Last month, a developer on your team enabled the Gemini API for an internal prototype. Your public Maps key is now a Gemini credential. Anyone who scrapes it can access your uploaded files, cached content, and rack up your AI bill.&nbsp; Nobody told you.</p><p dir=\"auto\"> When you create a new API key in Google Cloud, it defaults to \"Unrestricted,\" meaning it's immediately valid for every enabled API in the project, including Gemini. The UI shows a warning about \"unauthorized use,\" but the architectural default is wide open.</p><img alt=\"\" width=\"780\" height=\"426\" src=\"https://framerusercontent.com/images/Nf2qsg9A0BCN9PLKytFGkupS2c0.png\" srcset=\"https://framerusercontent.com/images/Nf2qsg9A0BCN9PLKytFGkupS2c0.png?scale-down-to=512&amp;width=1561&amp;height=852 512w,https://framerusercontent.com/images/Nf2qsg9A0BCN9PLKytFGkupS2c0.png?scale-down-to=1024&amp;width=1561&amp;height=852 1024w,https://framerusercontent.com/images/Nf2qsg9A0BCN9PLKytFGkupS2c0.png?width=1561&amp;height=852 1561w\" sizes=\"(min-width: 1000px) 100vw, (max-width: 999.98px) 100vw\"><p dir=\"ltr\"><strong>The result: thousands of API keys that were deployed as benign billing tokens are now live Gemini credentials sitting on the public internet.</strong></p><p dir=\"ltr\">What makes this a privilege escalation rather than a misconfiguration is the sequence of events.&nbsp;</p><ol dir=\"auto\"><li data-preset-tag=\"p\"><p>A developer creates an API key and embeds it in a website for Maps. (At that point, the key is harmless.)&nbsp;</p></li><li data-preset-tag=\"p\"><p>The Gemini API gets enabled on the same project. (Now that same key can access sensitive Gemini endpoints.)&nbsp;</p></li><li data-preset-tag=\"p\"><p>The developer is never warned that the keys' privileges changed underneath it. (The key went from public identifier to secret credential).</p></li></ol><p dir=\"ltr\">While users  restrict Google API keys (by API service and application), the vulnerability lies in the Insecure Default posture (CWE-1188) and Incorrect Privilege Assignment (CWE-269):</p><ul dir=\"auto\"><li data-preset-tag=\"p\"><p> Google retroactively applied sensitive privileges to existing keys that were already rightfully deployed in public environments (e.g., JavaScript bundles).</p></li><li data-preset-tag=\"p\"><p> Secure API design requires distinct keys for each environment (Publishable vs. Secret Keys). By relying on a single key format for both, the system invites compromise and confusion.</p></li></ul><p dir=\"auto\"><strong>Failure of Safe Defaults:</strong> The default state of a generated key via the GCP API panel permits access to the sensitive Gemini API (assuming it‚Äôs enabled). A user creating a key for a map widget is unknowingly generating a credential capable of administrative actions.</p><p dir=\"auto\">The attack is trivial. An attacker visits your website, views the page source, and copies your  key from the Maps embed. Then they run:</p><div data-width=\"fill\"><div><div><div><div><div><pre translate=\"no\"><code></code></pre></div></div></div></div></div></div><p dir=\"ltr\">Instead of a , they get a . From here, the attacker can:</p><ul dir=\"auto\"><li data-preset-tag=\"p\"><p> The  and  endpoints can contain uploaded datasets, documents, and cached context. Anything the project owner stored through the Gemini API is accessible.</p></li><li data-preset-tag=\"p\"><p> Gemini API usage isn't free. Depending on the model and context window, a threat actor maxing out API calls could generate thousands of dollars in charges per day on a single victim account.</p></li></ul><p dir=\"auto\"> This could shut down your legitimate Gemini services entirely.</p><p dir=\"ltr\">The attacker never touches your infrastructure. They just scrape a key from a public webpage.</p><h2 dir=\"ltr\">2,863 Live Keys on the Public Internet</h2><p dir=\"auto\">To understand the scale of this issue, we scanned <a href=\"https://data.commoncrawl.org/crawl-data/CC-MAIN-2025-47/index.html\" rel=\"noopener\">the November 2025 Common Crawl dataset</a>, a massive (~700 TiB) archive of publicly scraped webpages containing HTML, JavaScript, and CSS from across the internet. We identified 2,863 live Google API keys vulnerable to this privilege-escalation vector.</p><img alt=\"\" width=\"781\" height=\"148\" src=\"https://framerusercontent.com/images/gwiYpGErM4jP7RB5zy1RfYNAT4U.png\" srcset=\"https://framerusercontent.com/images/gwiYpGErM4jP7RB5zy1RfYNAT4U.png?scale-down-to=512&amp;width=1563&amp;height=297 512w,https://framerusercontent.com/images/gwiYpGErM4jP7RB5zy1RfYNAT4U.png?scale-down-to=1024&amp;width=1563&amp;height=297 1024w,https://framerusercontent.com/images/gwiYpGErM4jP7RB5zy1RfYNAT4U.png?width=1563&amp;height=297 1563w\" sizes=\"(min-width: 1000px) 100vw, (max-width: 999.98px) 100vw\"><p dir=\"ltr\"><em> Example Google API key in front-end source code used for Google Maps, but also can access Gemini</em></p><p dir=\"auto\">These aren't just hobbyist side projects. The victims included major financial institutions, security companies, global recruiting firms, and, notably, Google itself. If the vendor's own engineering teams can't avoid this trap, expecting every developer to navigate it correctly is unrealistic.</p><h2 dir=\"ltr\">Proof of Concept: Google's Own Keys</h2><p dir=\"ltr\">We provided Google with concrete examples from their own infrastructure to demonstrate the issue. One of the keys we tested was embedded in the page source of a Google product's public-facing website. By checking the Internet Archive, we confirmed this key had been publicly deployed since at least February 2023, well before the Gemini API existed. There was no client-side logic on the page attempting to access any Gen AI endpoints. It was used solely as a public project identifier, which is standard for Google services.</p><img alt=\"\" width=\"781\" height=\"251\" src=\"https://framerusercontent.com/images/ytu85bikTvXkeNJd3hFH5ZVAw4A.png\" srcset=\"https://framerusercontent.com/images/ytu85bikTvXkeNJd3hFH5ZVAw4A.png?scale-down-to=512&amp;width=1562&amp;height=503 512w,https://framerusercontent.com/images/ytu85bikTvXkeNJd3hFH5ZVAw4A.png?scale-down-to=1024&amp;width=1562&amp;height=503 1024w,https://framerusercontent.com/images/ytu85bikTvXkeNJd3hFH5ZVAw4A.png?width=1562&amp;height=503 1562w\" sizes=\"(min-width: 1000px) 100vw, (max-width: 999.98px) 100vw\"><p dir=\"auto\">We tested the key by hitting the Gemini API's  endpoint (which Google confirmed was in-scope) and got a  response listing available models. A key that was deployed years ago for a completely benign purpose had silently gained full access to a sensitive API without any developer intervention.</p><p dir=\"ltr\">We reported this to Google through their Vulnerability Disclosure Program on November 21, 2025.</p><ul dir=\"auto\"><li data-preset-tag=\"p\"><p> We submitted the report to Google's VDP.</p></li><li data-preset-tag=\"p\"><p> Google initially determined this behavior was intended. We pushed back.</p></li><li data-preset-tag=\"p\"><p> After we provided examples from Google's own infrastructure (including keys on Google product websites), the issue gained traction internally.</p></li><li data-preset-tag=\"p\"><p> Google reclassified the report from \"Customer Issue\" to \"Bug,\" upgraded the severity, and confirmed the product team was evaluating a fix. They requested the full list of 2,863 exposed keys, which we provided.</p></li><li data-preset-tag=\"p\"><p> Google shared their remediation plan. They confirmed an internal pipeline to discover leaked keys, began restricting exposed keys from accessing the Gemini API, and committed to addressing the root cause before our disclosure date.</p></li><li data-preset-tag=\"p\"><p> Google classified the vulnerability as \"Single-Service Privilege Escalation, READ\" (Tier 1).</p></li><li data-preset-tag=\"p\"><p> Google confirmed the team was still working on the root-cause fix.</p></li><li data-preset-tag=\"p\"><p> 90 Day Disclosure Window End.</p></li></ul><p dir=\"ltr\">Transparently, the initial triage was frustrating; the report was dismissed as \"Intended Behavior‚Äù. But after providing concrete evidence from Google's own infrastructure, the GCP VDP team took the issue seriously.&nbsp;</p><p dir=\"ltr\">They expanded their leaked-credential detection pipeline to cover the keys we reported, thereby proactively protecting real Google customers from threat actors exploiting their Gemini API keys. They also committed to fixing the root cause, though we haven't seen a concrete outcome .</p><p dir=\"ltr\">Building software at Google's scale is extraordinarily difficult, and the Gemini API inherited a key management architecture built for a different era. Google recognized the problem we reported and took meaningful steps. The open questions are whether Google will inform customers of the security risks associated with their existing keys and whether Gemini will eventually adopt a different authentication architecture.</p><h2 dir=\"ltr\">Where Google Says They're Headed</h2><p dir=\"ltr\">Google publicly documented <a href=\"https://ai.google.dev/gemini-api/docs/troubleshooting#googles_security_measures_for_leaked_keys\" rel=\"noopener\">its roadmap</a>. This is what it says:</p><ul dir=\"auto\"><li data-preset-tag=\"p\"><p> New keys created through AI Studio will default to Gemini-only access, preventing unintended cross-service usage.</p></li><li data-preset-tag=\"p\"><p> They are defaulting to blocking API keys that are discovered as leaked and used with the Gemini API.</p></li><li data-preset-tag=\"p\"><p> They plan to communicate proactively when they identify leaked keys, prompting immediate action.</p></li></ul><p dir=\"ltr\">These are meaningful improvements, and some are clearly already underway. We'd love to see Google go further and retroactively audit existing impacted keys and notify project owners who may be unknowingly exposed, but honestly, that is a monumental task.</p><h2 dir=\"ltr\">What You Should Do Right Now</h2><p dir=\"ltr\">If you use Google Cloud (or any of its services like Maps, Firebase, YouTube, etc), the first thing to do is figure out whether you're exposed. Here's how.</p><p dir=\"ltr\"><strong>Step 1: Check every GCP project for the Generative Language API.</strong></p><p dir=\"ltr\">Go to the GCP console, navigate to APIs &amp; Services &gt; Enabled APIs &amp; Services, and look for the \"Generative Language API.\" Do this for every project in your organization. If it's not enabled, you're not affected by this specific issue.</p><img alt=\"\" width=\"779\" height=\"235\" src=\"https://framerusercontent.com/images/xlkOD29iyoDWFO04pCKhMEx6Syo.png\" srcset=\"https://framerusercontent.com/images/xlkOD29iyoDWFO04pCKhMEx6Syo.png?scale-down-to=512&amp;width=1558&amp;height=470 512w,https://framerusercontent.com/images/xlkOD29iyoDWFO04pCKhMEx6Syo.png?scale-down-to=1024&amp;width=1558&amp;height=470 1024w,https://framerusercontent.com/images/xlkOD29iyoDWFO04pCKhMEx6Syo.png?width=1558&amp;height=470 1558w\" sizes=\"(min-width: 1000px) 100vw, (max-width: 999.98px) 100vw\"><p dir=\"ltr\"><strong>Step 2: If the Generative Language API is enabled, audit your API keys.</strong></p><p dir=\"ltr\">Navigate to APIs &amp; Services &gt; Credentials. Check each API key's configuration. You're looking for two types of keys:</p><ul dir=\"auto\"><li data-preset-tag=\"p\"><p>Keys that have a warning icon, meaning they are set to unrestricted</p></li><li data-preset-tag=\"p\"><p>Keys that explicitly list the Generative Language API in their allowed services</p></li></ul><p dir=\"ltr\">Either configuration allows the key to access Gemini.</p><img alt=\"\" width=\"779\" height=\"279\" src=\"https://framerusercontent.com/images/7V9bS4iNFPLgtPyDVZym8oCA.png\" srcset=\"https://framerusercontent.com/images/7V9bS4iNFPLgtPyDVZym8oCA.png?scale-down-to=512&amp;width=1558&amp;height=558 512w,https://framerusercontent.com/images/7V9bS4iNFPLgtPyDVZym8oCA.png?scale-down-to=1024&amp;width=1558&amp;height=558 1024w,https://framerusercontent.com/images/7V9bS4iNFPLgtPyDVZym8oCA.png?width=1558&amp;height=558 1558w\" sizes=\"(min-width: 1000px) 100vw, (max-width: 999.98px) 100vw\"><p dir=\"ltr\"><strong>Step 3: Verify none of those keys are public.</strong></p><p dir=\"ltr\">This is the critical step. If a key with Gemini access is embedded in client-side JavaScript, checked into a public repository, or otherwise exposed on the internet, you have a problem. Start with your oldest keys first. Those are the most likely to have been deployed publicly under the old guidance that API keys are safe to share, and then retroactively gained Gemini privileges when someone on your team enabled the API.</p><p dir=\"ltr\">If you find an exposed key, rotate it.</p><p dir=\"ltr\"><strong>Bonus: Scan with TruffleHog.</strong></p><p dir=\"auto\">You can also use TruffleHog to scan your code, CI/CD pipelines, and web assets for leaked Google API keys. TruffleHog will verify whether discovered keys are live , so you'll know exactly which keys are exposed and active, not just which ones match a regular expression.</p><div data-width=\"fill\"><div><div><div><div><div><pre translate=\"no\"><code> //// ---</code></pre></div></div></div></div></div></div><p dir=\"auto\">The pattern we uncovered here (public identifiers quietly gaining sensitive privileges) isn't unique to Google. As more organizations bolt AI capabilities onto existing platforms, the attack surface for legacy credentials expands in ways nobody anticipated. </p><p dir=\"auto\">Webinar: <a href=\"https://trufflesecurity.com/webinars/google-api-keys-werent-secrets-but-gemini-changed-the-rules\" target=\"_blank\" rel=\"noopener\">Google API Keys Weren't Secrets. But then Gemini Changed the Rules.</a></p>",
      "contentLength": 10758,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rfr1jg/google_api_keys_werent_secrets_but_then_gemini/"
    },
    {
      "title": "Visualizing how HTTPS, OAuth, Git, and TCP actually work",
      "url": "https://toolkit.whysonil.dev/how-it-works",
      "date": 1772149828,
      "author": "/u/nulless",
      "guid": 48708,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/kubernetes/comments/1rfqoo6/visualizing_how_https_oauth_git_and_tcp_actually/"
    },
    {
      "title": "Anyone managing K8s clusters with limited or no internet access? What's your tooling like?",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rfpnbc/anyone_managing_k8s_clusters_with_limited_or_no/",
      "date": 1772147315,
      "author": "/u/lepton99",
      "guid": 48701,
      "unread": true,
      "content": "<p>We keep hearing from teams that claim they run clusters in restricted environments. Air-gapped, behind strict firewalls, limited egress, no cloud dependencies. Military, finance, healthcare, government, the usual suspects.</p><p>We're building K8s tooling (Kunobi, etc.. ) and planning restricted-environment support such as no server-side deployment, no telemetry, no external dependencies. Just a binary and your kubeconfig. Avoid SSO or SAML,etc. </p><p>Curious to hear from people (if any) who actually operate in these environments:</p><p>- What does your current tooling look like? kubectl + k9s and that's it? do you vet the software before? </p><p>- Ever tried other tools and given up because they don't work well without internet?</p><p>- What's the update/patch story when you can't pull from the internet?</p>",
      "contentLength": 782,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "A Wasm to Go Translator",
      "url": "https://github.com/ncruces/wasm2go",
      "date": 1772145422,
      "author": "/u/ncruces",
      "guid": 48738,
      "unread": true,
      "content": "<p>I've spent the past couple of weeks building a Wasm-to-Go translator. It supports a subset of Wasm useful enough to translate SQLite into 600k LoC (~20 MiB) of Go code. It already passes all of my Go SQLite driver's tests across the 20 platforms I support.</p><p>Performance compared to <a href=\"https://wazero.io/\">wazero</a> is a bit of a mixed bag: code that frequently crosses the Go-Wasm boundary improves, but code that spends most of its time in \"Wasm land\" doesn't.</p><p>There's probably room for improvement (I'd love to hear your ideas), but this is also a testament to how good the wazero AOT compiler actually is.</p><p>You can get a feel for the generated code by checking the <a href=\"https://github.com/ncruces/wasm2go/tree/main/testdata\">test data</a>.</p><p>I should eventually spend some time ensuring the translator passes the spectest, though I suspect that'll be far less fun than building the translator itself was.</p>",
      "contentLength": 809,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rfou6m/a_wasm_to_go_translator/"
    },
    {
      "title": "Offlining a Live Game With .NET Native AOT",
      "url": "https://sephnewman.substack.com/p/offlining-a-live-game-with-net-native",
      "date": 1772140718,
      "author": "/u/Seph13",
      "guid": 48914,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rfmrl4/offlining_a_live_game_with_net_native_aot/"
    },
    {
      "title": "The proposal for generic methods for Go, from Robert Griesemer himself, has been officially accepted",
      "url": "https://github.com/golang/go/issues/77273#issuecomment-3962618141",
      "date": 1772140205,
      "author": "/u/rodrigocfd",
      "guid": 48660,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rfmjbq/the_proposal_for_generic_methods_for_go_from/"
    },
    {
      "title": "[D] First time reviewer. I got assigned 9 papers. I'm so nervous. What if I mess up. Any advice?",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rfle5p/d_first_time_reviewer_i_got_assigned_9_papers_im/",
      "date": 1772137689,
      "author": "/u/rjmessibarca",
      "guid": 48661,
      "unread": true,
      "content": "<div><p>I've been working on tech industry for about 7ish year and this is my first time ever reviewing. I looked at my open review tasks and see I have 9 papers assigned to me.</p><ol><li>What is acceptable? Am I allowed to use ai to help me review or not</li><li>Since it is my first time reviewing i have no priors. What if my review quality is super bad. How do I even make sure it is bad?</li><li>Can I ask the committee to give me fewer papers to review because it's my first time</li></ol><p>Overall I'm super nervous and am facing massive imposter syndrome üò≠üò≠üò≠</p><p>Any and every advice would be really helpful</p></div>   submitted by   <a href=\"https://www.reddit.com/user/rjmessibarca\"> /u/rjmessibarca </a>",
      "contentLength": 605,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Is Kubernetes a Distributed Lisp?",
      "url": "https://bigconfig.it/blog/the-yaml-trap-escaping-greenspun-s-tenth-rule-with-bigconfig/",
      "date": 1772135763,
      "author": "/u/amiorin",
      "guid": 48940,
      "unread": true,
      "content": "<p>Greenspun‚Äôs Tenth Rule is a famous (and delightfully cynical) adage in computer science. While it was born in the era of C and Fortran, it has never been more relevant than it is today in the world of Platform Engineering.</p><p>If you‚Äôve ever felt like your CI/CD pipeline is held together by duct tape, YAML-indentation prayers, and sheer willpower, you‚Äôve lived this rule.</p><p>In the early 90s, Philip Greenspun stated:</p><blockquote><p>‚ÄúAny sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.‚Äù</p></blockquote><p>The core insight is that once a system reaches a certain level of complexity, it inevitably requires high-level abstraction, automation, and dynamic logic. Instead of starting with a powerful, established language (like Lisp) built for those tasks, developers often ‚Äúaccidentally‚Äù reinvent a mediocre version of one using brittle configuration files and makeshift scripts.</p><p>In DevOps, we strive for Infrastructure as Code (IaC). However, because we started with static configuration formats (YAML/JSON) and tried to force them to perform complex logic, we‚Äôve essentially proven Greenspun right.</p><p>Tools like Terraform, Ansible, Helm, and GitHub Actions began as simple configuration formats. But as users demanded loops, conditionals, and variables, these tools evolved into ‚Äúaccidental‚Äù languages.</p><ul><li> You end up writing complex business logic inside strings within a YAML file.</li><li> You are using a ‚Äúbug-ridden implementation‚Äù of a real programming language, but without the benefit of a debugger, a compiler, or proper unit testing.</li></ul><p>Some architects argue that Kubernetes is the ultimate manifestation of this rule. Its control loop the constant cycle of reconciling desired state vs. actual state mimics the recursive nature of Lisp environments. It is, in essence, a programmable platform designed to manage other programs.</p><p>The industry has invested massive human capital into building Ansible roles, Helm charts, and Terraform modules. We shouldn‚Äôt throw them away, but we must stop trying to make them do things they weren‚Äôt designed for.</p><p>How do we escape Greenspun‚Äôs trap without rebuilding everything from scratch? By assimilating these tools (to borrow a 90s Star Trek reference).</p><p>This is the core design principle of BigConfig. Instead of fighting against limited YAML DSLs, BigConfig uses Clojure a modern, production-grade Lisp to wrap and orchestrate existing tools.</p><blockquote><p><strong>The BigConfig Philosophy:</strong> Express infrastructure logic with the most powerful dynamic language available, while still leveraging the ecosystem you already have.</p></blockquote><p>The Tenth Rule is a warning: Don‚Äôt reinvent the wheel poorly. If your infrastructure requires complex logic, stop forcing it into a flat config file.</p><p>While a standard Helm package is limited strictly to Kubernetes, a <a href=\"https://bigconfig.it/api/package/\" target=\"_blank\" rel=\"noopener noreferrer\"> BigConfig package </a> is a Clojure function. Because BigConfig assimilates Ansible and Terraform alongside Helm, it isn‚Äôt siloed.</p><ul><li> A Kubernetes application that requires specific cloud resources (like an S3 bucket or an RDS instance) can be abstracted into a single, cohesive unit.</li><li> In BigConfig, everything is a function. This leads to a fractal architecture where every layer from a single container to a multi-region cloud deployment is governed by the same recursive logic: Observe, Diff, and Act.</li></ul><p>Operations is a hard problem. YAML is too rigid, and Go is too low-level for rapid infrastructure iteration. While Python and JavaScript are popular, they lack the REPL-driven development flow that makes infrastructure-as-code feel truly interactive.</p><p>Clojure is the most robust Lisp available today and it won‚Äôt let you down.</p><p>Greenspun‚Äôs Tenth Rule isn‚Äôt just a witty observation; it‚Äôs a technical debt warning. When we try to solve 21st-century infrastructure challenges using static configuration files, we inevitably end up building ‚Äúshadow‚Äù programming languages that are difficult to test, impossible to debug, and fragile to scale.</p><p>By embracing a functional, Lisp-based approach through BigConfig, we stop fighting the limitations of YAML and start leveraging the power of actual logic. Instead of building a ‚Äúbug-ridden implementation of half of Common Lisp,‚Äù we use the real thing Clojure to orchestrate, automate, and scale.</p><p>The goal of Platform Engineering shouldn‚Äôt be to write more scripts; it should be to create elegant, recursive systems that can manage themselves. It‚Äôs time to move past the duct tape and prayers and give our infrastructure the robust, dynamic foundation it deserves.</p><p>Would you like to have a follow-up on this topic? What are your thoughts? I‚Äôd love to <a href=\"https://www.albertomiorin.com/contact#form\" target=\"_blank\" rel=\"noopener noreferrer\"> hear </a> your experiences.</p>",
      "contentLength": 4656,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/kubernetes/comments/1rfkj2c/is_kubernetes_a_distributed_lisp/"
    },
    {
      "title": "Invisible characters hidden in text can trick AI agents into following secret instructions ‚Äî we tested 5 models across 8,000+ cases",
      "url": "https://www.moltwire.com/research/reverse-captcha-zw-steganography",
      "date": 1772133266,
      "author": "/u/thecanonicalmg",
      "guid": 48672,
      "unread": true,
      "content": "<h3>3.1 Tool Use Is the Primary Amplifier</h3><p>The single largest finding: <strong>tool access transforms invisible Unicode from an ignorable artifact to a decodable instruction channel.</strong></p><div><svg viewBox=\"0 0 720 370\" xmlns=\"http://www.w3.org/2000/svg\"></svg></div><p>Without tools, all models resist hidden instructions at high rates (0.1‚Äì16.9% compliance). With tools enabled, compliance increases dramatically ‚Äî Claude Haiku jumps from 0.8% to 49.2% (odds ratio 115.1, Cohen's h = 1.37). Models write Python code to decode the invisible characters, converting the task from pattern recognition to string manipulation.</p><h3>3.2 Provider-Specific Encoding Preferences</h3><p>A striking discovery: <strong>encoding vulnerability is provider-specific.</strong></p><div><svg viewBox=\"0 0 720 330\" xmlns=\"http://www.w3.org/2000/svg\"></svg></div><p>GPT-5.2 achieves 69‚Äì70% on zero-width binary (hint_full) but near-zero on Unicode Tags. Claude Opus achieves  on Tags (codepoints and full hints) but only 48‚Äì68% on zero-width binary. This likely reflects differences in tokenizer design. <strong>An attacker must tailor their encoding to the target model's provider.</strong></p><div><svg viewBox=\"0 0 720 380\" xmlns=\"http://www.w3.org/2000/svg\"></svg></div><p>Chi-squared tests confirm that scheme significantly affects compliance for every model (p &lt; 10‚Åª‚Å∑ for all). The gradient is consistent: <strong>unhinted &lt;&lt; codepoint hints &lt; full hints.</strong></p><p>No model decodes either encoding when unhinted. With tools but no hints, compliance remains near-zero (0‚Äì11%), indicating that tool access alone is insufficient. <strong>The critical enabler is the combination of tool access and decoding instructions.</strong></p><p>The adversarial \"Ignore all previous instructions\" payload has model-dependent effects:\n</p><li>: Injection  compliance (Opus: 32.0% to 23.9%, p=0.004; GPT-5.2: 11.8% to 6.1%, p=0.002), suggesting training against explicit injection language</li><li>: Injection  compliance (43.7% to 59.6%, p&lt;0.001)</li><li>: No significant difference (p=0.058)</li><h3>3.5 Pairwise Model Comparisons</h3><p>All 10 pairwise comparisons are statistically significant after Bonferroni correction (p_corrected &lt; 0.05). Overall compliance ranking (tools ON):</p><p><strong>Sonnet (47.4%) &gt; Opus (30.1%) &gt; Haiku (25.0%) &gt; GPT-5.2 (10.3%) &gt; GPT-4o-mini (0.9%)</strong></p><p>Largest effect: Sonnet vs GPT-4o-mini (Cohen's h = 1.33, OR = 103.8).</p>",
      "contentLength": 2017,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rfjew5/invisible_characters_hidden_in_text_can_trick_ai/"
    },
    {
      "title": "AI=true is an Anti-Pattern",
      "url": "https://keleshev.com/ai-equals-true-is-an-anti-pattern",
      "date": 1772132167,
      "author": "/u/keleshev",
      "guid": 48643,
      "unread": true,
      "content": "<p>One programming trend that surpised me a lot recently, something that happens both at work and in open-source, is people  starting doing the following:</p><ul><li>Writing a lot of relevant, long-overdue, sharp, concise, to-the-point documentation‚Ä¶ but placing it in  or  files.</li><li>Implementing extremely valuable workflows, but exposing them in form of  or  servers.</li><li>Improving output of tests and command-line tools, but enabling it only under AI-oriented flags and environmental variables (like ).</li></ul><p>Well, I think we need to take deep breath and take a step back.</p><p>Yes, good documentation  valuable for AI agents, especially if it is not part of the training data set. A good documentation  is often even more important, because it takes less of the context window. But‚Ä¶ that documentation is equally valuable for humans, and we have a limited context window too, and benefit from good summaries equally.</p><p>Moreover, we should strive to place the documentation where it is well discoverable by both humans and AI agents.  files is one such choice.</p><p>I know that there are a few technicalities involved, for example, some tools will pre-load files like  into the context, but the actual conventions are changing rapidly, and often are vendor-specific (i.e.&nbsp;not to be relied upon), and most of the benefit can be obtained by placing ‚ÄúSee ‚Äù in the right place.</p><p>First, there are tools that are mostly human-oriented, tools with graphical user interfaces. Then there are new kinds of tools that are primarily AI-oriented, the MCP tools. However, there‚Äôs a set of tools that both developers and AI agents can use alike: command-line tools and APIs. They are scriptable, composable, text-oriented, and can perfectly expose functionality to both developers and AI agents. Why not default to them?</p><p>I‚Äôm obviously biased towards command-line, but I use my share of GUI tools too. However, when it comes to MCP, I am yet to see a single case when it is supperior to a command-line tool. Maybe the time will prove me wrong.</p><p>One example: I‚Äôve seen an MCP tool being introduced because the actual command-line tool took a lot of time to execute, was producing no output and was‚Äîbacause of that‚Äîoften mistakingly terminated early by the agent. That reminds me of someone else who is also prone to that‚Ä¶ I am! Well, who else, when running a new tool and presented with a hanging command-line, doesn‚Äôt just Ctrl-C out of it, if nothing happens for straight 10 seconds?</p><p>Or the opposite‚Äîwho is not overwhelmed when a tool produces tons of unnecessary output? I am. And same thing, it makes AI context window slide and leave out potentially more useful information. Mental overload, anyone?</p><p>Who likes it when tests execute fast and, if they fail, produce output that allows to easily narrow down the problem? You get the idea‚Ä¶ What‚Äôs good for the goose is good for the gander.</p><p>Making a new internal tool? Why not make a web app‚Ä¶ and see developers always complain about missing functionality while you try to manage scope creep. Or make an API first. Even better, wrap it into a command-line too and see developers and AI agents alike mixing, matching, scripting away, and automating the workflows you would have never imagined, and being on top of their needs.</p><ol type=\"1\"><li>Place documentation where both human developers and AI agents can expect it. For example, in , not .</li><li>Prefer exposing functionality as command-line tools and APIs, which are well accessible to developers and AI agents alike, over GUI and MCP tools.</li><li>Avoid parameters (command-line, environment, etc.) that segregate workflows between humans and AI agents, for example, avoid , prefer  or‚Äî‚Äîdesign your tools with limited context/mental-overload in mind.</li><li>In general, avoid making workflows that are available to AI but hard to access for humans, and vice-versa.</li></ol><p>I don‚Äôt normally write on topics like this, but this has been my cry to try to turn the tide of programming practice towards unification of human and AI workflows.</p><p>There‚Äôs enough similarity between us to maintain the same textual interfaces and conventions. We should try to stay interoperable as far as possible, but the ramifications are not lost on me.</p>",
      "contentLength": 4154,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rfiwf5/aitrue_is_an_antipattern/"
    },
    {
      "title": "I'm trying to create a map that hold two data types",
      "url": "https://www.reddit.com/r/golang/comments/1rfilyt/im_trying_to_create_a_map_that_hold_two_data_types/",
      "date": 1772131538,
      "author": "/u/PeterHickman",
      "guid": 48733,
      "unread": true,
      "content": "<p>I'm trying to create a map that hold two data types. As a small cheat I have a struct that contains two separate maps for the types I want</p><p><code> type MixedMap struct { String map[string]string Number map[string]float64 } </code></p><p>Additionally I have a type to handle this <code>type MixedType interface { string | float64 }</code>. With the aid of this type and reflect I have a single method, <code>func Add[V MixedType](m MixedMap, k string, v V) {...}</code> that allows me to add either type (string or float64) to the correct map. It's nice to have only one function to add elements. So I though it would also be nice to have something like <code>func Get[V MixedType](m MixedMap, k string) V {...}</code> to return values from MixedMap. But here are the issues. When It returns a string, , it complains that it is not a float64, when it returns a float64, , is complains that it is not a string</p><p><code> ./maybe.go:55:12: cannot convert sv (variable of type string) to type V: cannot convert string to type float64 (in V) ./maybe.go:60:12: cannot convert nv (variable of type float64) to type V: cannot convert float64 to type string (in V) </code></p><p>Am I missing something or am I trying to bend Go out of shape</p><p>It's not that I can't just have receiver methods on MixedMap especially with there being only two types but a single method to handle the Add or the Get would keep things cleaner</p>",
      "contentLength": 1323,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Making WebAssembly a first-class language on the Web",
      "url": "https://hacks.mozilla.org/2026/02/making-webassembly-a-first-class-language-on-the-web/",
      "date": 1772130450,
      "author": "/u/fitzgen",
      "guid": 48645,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/rust/comments/1rfi46h/making_webassembly_a_firstclass_language_on_the/"
    },
    {
      "title": "Structured logs are great‚Ä¶ until you actually have to read them in dev",
      "url": "https://www.reddit.com/r/golang/comments/1rfi1e6/structured_logs_are_great_until_you_actually_have/",
      "date": 1772130274,
      "author": "/u/General_Apartment582",
      "guid": 48618,
      "unread": true,
      "content": "<p>I love structured logging in theory: clean fields, searchable context, machine-friendly output, all the good stuff. In practice (at least in my day-to-day), I spend way too much time staring at a terminal full of json soup, pretending my brain is a parser</p><p>I tried a couple of open-source viewers (best was github.com/control-theory/gonzo). Some parts were nice, but on my machine it felt laggy, and I kept tripping over features I didn‚Äôt really need. Meanwhile all I wanted was readable timestamps, colorful levels/tags ; logs I can scan like a human, not a parser</p><p>So after one particularly dramatic \"why is this request slow?\" debugging session, I did the most reasonable developer thing. I complained for 10 minutes, made tea, and wrote a tiny local tool in one evening.</p><p>It follows a zerolog-like style, mostly focused on making everyday dev logs readable and fast to scan.</p><pre><code>{\"ts\":\"2025-06-15T10:32:01Z\",\"level\":\"info\",\"msg\":\"server started\",\"port\":8080} {\"ts\":\"2025-06-15T10:32:05Z\",\"level\":\"error\",\"msg\":\"connection failed\",\"host\":\"db\",\"retry\":3} </code></pre><pre><code>10:32:01 [INF] server started port=8080 10:32:05 [ERR] connection failed host=db retry=3 </code></pre><p>Not posting this as look at my amazing product. This is mostly a small rant: structured logs without a good viewing layer are painful, and I keep running into this problem across projects.</p>",
      "contentLength": 1325,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Benchmarking 18 years of Intel laptop CPUs: Panther Lake as much as 95x the speed of Penryn",
      "url": "https://www.phoronix.com/review/intel-penryn-to-panther-lake",
      "date": 1772129524,
      "author": "/u/Fcking_Chuck",
      "guid": 48673,
      "unread": true,
      "content": "<p>For those curious how far Intel laptop CPU performance has evolved over the past nearly two decades, here are power and performance numbers when re-benchmarking all of the Intel-powered laptop CPUs I have on hand that are still operational from Penryn to Panther Lake. A ThinkPad from 2008 with the Core 2 Duo T9300 \"Penryn\" was still firing up and working with the latest upstream Intel open-source Linux driver support on Ubuntu 26.04 development. On a geo mean basis over the past 18 years from Penryn to Panther Lake, the performance was at 21.5x in over 150 benchmarks. At the most extreme was a 95x difference going from Intel's 45nm Penryn to the 18A Panther Lake.</p><p>With being fairly impressed by the power efficiency and generational performance gains of Intel <a href=\"https://www.phoronix.com/search/Panther+Lake\">Panther Lake</a> on Linux, especially when it comes to the Xe3 graphics with the <a href=\"https://www.phoronix.com/search/Arc+B390\">Arc B390</a>, over the past month I have been re-benchmarking all the old laptops in my lab for seeing exactly how far the Intel laptop CPU performance on Linux has evolved over the past two decades.</p><p>Earlier this month I looked at <a href=\"https://www.phoronix.com/review/intel-gen9-xe3-b390-graphics\">how the the Arc B390 graphics have evolved since the Skylake / Gen9 graphics era</a>. Today's article is looking just at the CPU side and going all the way back to Penryn. It doesn't make sense testing the graphics performance pre-Gen9 since there the Intel integrated graphics are simply too slow and also lack reliable Vulkan driver support that makes it rather difficult to effectively compare the modern graphics performance of Xe3 to these very old generations. So see the prior article in case you missed it and interested in seeing how Intel laptop integrated graphics have evolved since the Gen9 area.</p><p>Complementing all the modern Intel Core (Ultra) and AMD Ryzen laptop testing is the big Intel generational CPU comparison look back to Penryn. This comparison was based on the hardware I had available in freshly re-testing all of the hardware atop a modern Linux stack for comparable results and always re-testing hardware at Phoronix for the most representative and accurate experience. Given these oldest Intel laptops are no longer supported on the latest Microsoft Windows releases, it's a real treat on Linux seeing how far the Intel laptop CPU performance has come with the modern Ubuntu 26.04 development software stack across the board.</p><p>The laptops tested included:</p><p><strong>Core 2 Duo T9300 - ThinkPad T61</strong> - The oldest laptop I had that still was powering up and working was a Lenovo ThinkPad T61 with the Core 2 Duo T9300 Penryn processor. The Core 2 Duo T9300 features two physical cores without any Hyper Threading and clocked up to 2.5GHz while having a 35 Watt TDP. This ThinkPad T61 had 4GB of DDR2 memory.</p><p><strong>Core i7 720QM - ThinkPad W510</strong> - Another very vintage laptop in the mix was the Core i7 720QM for the first-generation Clarksfield quad-core CPU from 2009. This 45nm processor has four physical cores plus Hyper Threading and clocking up to 2.8GHz and a 45 Watt default TDP. This laptop had 4GB of DDR3-1066 memory.</p><p><strong>Core i5 2520M - HP EliteBook 8460p</strong> - Sandy Bridge! This laptop was one of Intel's Software Development Vehicles for Sandy Bridge. The Core i5 2520M features two cores plus Hyper Threading, 2.5GHz base frequency with 3.2GHz Turbo, and a 35 Watt TDP. It's also with this CPU and newer where Intel supports RAPL/PowerCap for exposing CPU power sensors for being able to monitor the CPU power consumption and in turn performance-per-Watt in these benchmarks. This laptop had 4GB of DDR3-1333 memory.</p><p><strong>Core i7 3517U - ASUS UX32VDA</strong> - This Core i7 Ivy Bridge featured two cores plus HT, 1.9GHz base frequency, 3.0GHz turbo frequency, and a 17 Watt TDP. This ASUS laptop was equipped with 4GB of DDR3-1600 memory.</p><p><strong>Core i7 4558U - ASUS UX301LAA</strong> - Still good memories of this Haswell laptop. The Core i7 4558U Haswell CPU has two cores plus HT, 2.8GHz base frequency, 3.3GHz turbo frequency, and a 28 Watt TDP. This laptop had 8GB of DDR3-1600 memory.</p><p><strong>Core i7 5600U - ThinkPad X1 Carbon G3</strong> - This Broadwell laptop CPU was two cores / four threads with a 2.6GHz base frequency, 3.2GHz turbo frequency, and a 15 Watt TDP.  This early ThinkPad X1 Carbon model had 8GB of DDR3-1600 memory.</p><p><strong>Core i7 8550U - Dell XPS 13 9370</strong> - This Kabylake CPU has four cores / eight threads with a 1.8GHz base frequency and 4.0GHz turbo frequency with a 15 Watt default TDP. This Dell XPS laptop had 8GB of LPDDR3-1867 memory.</p><p><strong>Core i7 8565U - Dell XPS 13 9380</strong> - The Core i7 Whiskey Lake CPU was four cores / eight threads with a 1.8GHz base frequency and 4.6GHz turbo frequency with a 15 Watt TDP. This 14nm CPU was paired with 16GB LPDDR3-2133 memory.</p><p><strong>Core i7 1065G7 - Dell XPS 13 7390</strong> - The Ice Lake laptop CPI has four cores / eight threads, 1.3GHz base frequency, 3.9GHz turbo frequency, and a 15 Watt TDP. This Dell XPS laptop had 16GB of LPDDR4-3733 memory.</p><p><strong>Core i7 1165G7 - Dell XPS 13 9310</strong> - This Tiger Lake quad core + HT CPU has a 3.0GHz base frequency and 4.8GHz turbo frequency with a 28 Watt TDP. The Tiger Lake laptop was paired with 16GB of LPDDR4-4267 memory.</p><p><strong>Core i7 1280P - MSI Prestige 14Evo</strong> - The Alder Lake laptop CPU has 14 cores of 6 P cores and 8 E cores. The P cores have Hyper Threading for a total of 20 threads. The Core i7 1280P has a 28 Watt TDP. The MSI Alder Lake laptop is paired with 16GB of LPDDR4-4267 memory.</p><p><strong>Core i5 1334U - Framework 12</strong> - This Raptor Lake U laptop has ten cores between two P cores and eight E cores for a total of 12 threads. The max turbo frequency is 4.6GHz and the i5-1334U has a base TDP of 15 Watts. This Framework Laptop has a single channel of DDR5-5200 memory.</p><p><strong>Core Ultra 7 155H - Acer Swift 14</strong> - This Meteor Lake laptop CPU has 6 P cores, 8 E cores, and 2 LPE cores for a total of 16 cores / 22 threads with a max turbo frequency of 4.8GHz while having a 28 Watt base power rating. The Meteor Lake CPU was paired with 16GB of LPDDR5-6400 memory.</p><p><strong>Core Ultra 7 256V - Zenbook S14</strong> - This Lunar Lake CPU has eight cores between 4 P cores and 4 LPRE cores. The Core Ultra 7 256V has a 4.8GHz maximum turbo frequency and a 17 Watt base power rating. This Lunar Lake CPU has 16GB LPDDR5-8533 memory.</p><p><strong>Core Ultra X7 358H - MSI Prestige 14</strong> - Lastly is the sole Panther Lake laptop in the lab at the moment. The Core Ultra X7 358H has 4 P cores, 8 E cores, and 4 LPE cores for a total of 16 cores/threads. There is a maximum turbo frequency of 4.8GHz and a 25 Watt base power rating. This MSI Prestige 14 Flip AI D3MTG MS-14T2 laptop has 32GB of LPDDR5-8533 memory.</p><p>All laptops were tested on the Ubuntu 26.04 development state over the past two months for a fresh kernel and other software packages.</p><p>Besides looking at the raw performance, the CPU power consumption was also monitored on a per-test basis for Sandy Bridge and newer where the PowerCap/RAPL interfaces are available for being able to read the CPU power consumption to avoid factoring in the laptop panel, cooling, and other differences between these different laptop models.</p><p>Over 150 benchmarks were run on each of these laptops under test for looking at the performance and power efficiency across all these laptop models as far back as Penryn and through the exciting days of especially Sandy Bridge, Haswell, Broadwell, etc, and now kicking off 2026 with the new and very exciting Panther Lake.</p>",
      "contentLength": 7268,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rfhoyj/benchmarking_18_years_of_intel_laptop_cpus/"
    },
    {
      "title": "is it the year of the linux yet?",
      "url": "https://www.reddit.com/r/linux/comments/1rfhcl1/is_it_the_year_of_the_linux_yet/",
      "date": 1772128790,
      "author": "/u/West-Amphibian-2343",
      "guid": 48619,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Making WebAssembly a first-class language on the Web",
      "url": "https://hacks.mozilla.org/2026/02/making-webassembly-a-first-class-language-on-the-web/",
      "date": 1772128014,
      "author": "/u/ketralnis",
      "guid": 48621,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rfgzit/making_webassembly_a_firstclass_language_on_the/"
    },
    {
      "title": "Burger King will use AI to check if employees say ‚Äòplease‚Äô and ‚Äòthank you‚Äô. AI chatbot ‚ÄòPatty‚Äô is going to live inside employees‚Äô headsets.",
      "url": "https://www.theverge.com/ai-artificial-intelligence/884911/burger-king-ai-assistant-patty",
      "date": 1772124545,
      "author": "/u/esporx",
      "guid": 48576,
      "unread": true,
      "content": "<div><p>Burger King is launching an AI chatbot that will live in the headsets used by employees. The voice-enabled chatbot, called ‚ÄúPatty,‚Äù is part of an overarching BK Assistant platform that will not only assist employees with meal preparation but also evaluate their interactions with customers for ‚Äúfriendliness.‚Äù</p></div><div><p>Thibault Roux, Burger King‚Äôs chief digital officer, tells  that the company compiled information from franchisees and guests on how to measure friendliness, resulting in the fast food chain training its AI system to recognize certain words and phrases, such as ‚Äúwelcome to Burger King,‚Äù ‚Äúplease,‚Äù and ‚Äúthank you.‚Äù Managers can then ask the AI assistant how their location is performing on friendliness. ‚ÄúThis is all meant to be a coaching tool,‚Äù Roux says, adding that the company is ‚Äúiterating‚Äù on capturing the tone of conversations as well.</p></div><div><p>The OpenAI-powered Patty serves as the ‚Äúvoice‚Äù of the BK Assistant platform, which combines data across drive-thru conversations, kitchen equipment, inventory, and other areas of the Burger King business. Employees can ask Patty questions, such as how many strips of bacon to put on a Maple Bourbon BBQ Whopper, or for instructions on how to clean the shake machine.</p></div><div><p>Because it‚Äôs integrated with the new cloud point-of-sale system, the AI assistant will also alert managers if a machine is down for maintenance or when an item is out of stock. ‚ÄúWithin 15 minutes, the entire ecosystem will remove it from stock ‚Äî whether you‚Äôre walking into a restaurant to order from the kiosk, whether you‚Äôre going to the drive-thru, the digital menu board will be updated,‚Äù Roux says.</p></div><div><p>Burger King may be building a chatbot into employees‚Äô headsets, but it doesn‚Äôt seem like the brand is ready to widely launch AI drive-thrus just yet ‚Äî something we‚Äôve seen chains like <a href=\"https://www.theverge.com/2024/6/16/24179679/mcdonalds-ending-ai-chatbot-drive-thru-ordering-test-ibm\">McDonald‚Äôs</a>, <a href=\"https://www.theverge.com/2023/5/9/23716825/wendys-ai-drive-thru-google-llm\">Wendy‚Äôs</a>, and <a href=\"https://www.theverge.com/news/767421/taco-bell-ai-drive-thru-trolls-glitches\">Taco Bell</a> attempt. ‚ÄúWe‚Äôre tinkering with it, we‚Äôre playing around with it, but it‚Äôs still a risky bet,‚Äù Roux says. ‚ÄúNot every guest is ready for this.‚Äù He adds that the company is currently testing the AI drive-thru technology in fewer than 100 restaurants.</p></div><div><p>Burger King plans on launching its BK Assistant web and app platform to all restaurants in the US by the end of 2026, while Patty is piloting in 500 restaurants.</p></div><div><ul></ul></div>",
      "contentLength": 2320,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rffcup/burger_king_will_use_ai_to_check_if_employees_say/"
    },
    {
      "title": "[P] Implementing Better Pytorch Schedulers",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rfer1y/p_implementing_better_pytorch_schedulers/",
      "date": 1772123254,
      "author": "/u/shivvorz",
      "guid": 48634,
      "unread": true,
      "content": "<p> Current schedulers in PyTorch are limited to just learning rate () changes and often lead to hardcoded, error-prone logic in training loops for anything more complex. I built a flexible suite for scheduling  optimizer hyperparam (LR, momentum, betas, etc.), with support for custom functions, presets, cyclic patterns, and per-group overrides. It's stateless where possible, picklable for checkpointing, and well-tested.</p><p>It currently lives in my <a href=\"https://github.com/shivvor2/research-monorepo/tree/master/src/research_lib/training/scheduling\">research monorepo</a>, but I can separate it into a standalone package if there's enough interest. Would love feedback!</p><p>I've been working on replicating (a subset of) training techniques from <a href=\"https://github.com/KellerJordan/modded-nanogpt\"><code>KellerJordan/modded-nanogpt</code></a> for <a href=\"https://github.com/shivvor2/research-monorepo/tree/master/experiments/01_nanogpt_base\">my baseline experiments</a>, and realized I needed a reusable scheduling suite. But looking at how scheduling is typically done, and how it's done in modded-nanogpt, neither approach looked particularly reusable.</p><p>Everyone knows that when you create a PyTorch optimizer, its hyperparameters are stored in , which is a list of dicts where each dict holds params and their hyperparams for a group of model parameters.</p><p>For example, here's a realistic setup where you might want different weight decay for feature extractors vs. classifiers (common in fine-tuning scenarios):</p><pre><code>import torch.optim as optim model = SomeLargeModel() # e.g., a vision transformer optimizer = optim.AdamW([ {'params': model.feature_extractor.parameters(), 'weight_decay': 0.1}, # Group 0: High decay for stability {'params': model.classifier.parameters(), 'weight_decay': 0.01} # Group 1: Lower decay for faster adaptation ], lr=1e-3, weight_decay=0.05) # Default values overridden per-group # Per-group overrides take precedence over defaults assert optimizer.param_groups[0]['weight_decay'] == 0.1 assert optimizer.param_groups[1]['weight_decay'] == 0.01 </code></pre><p>You are allowed (and its common) to tweak these  mid-training to implement scheduling. For instance, you might decay weight decay over time or adjust betas in Adam for better convergence.</p><p>Here is how you would typically perform such a change manually:</p><pre><code># Manual mid-training adjustment (common pattern when Trainer/scheduler isn't flexible enough) for epoch in range(num_epochs): for batch in dataloader: # ... compute loss, backward optimizer.step() # Manual mid-training tweak: reduce weight decay after warmup if global_step &gt; warmup_steps: for group in optimizer.param_groups: group['weight_decay'] *= 0.99 # Simple decay </code></pre><p>This is straightforward for basic cases, but things get messy with more complexity. For example, look at <a href=\"https://github.com/KellerJordan/modded-nanogpt/blob/master/train_gpt.py\"><code>KellerJordan/modded-nanogpt</code></a>. They use a combined NorMuon+Adam optimizer where different parameter groups need different scheduling: projection matrices use Muon with momentum warmup/cooldown, while embeddings use Adam with higher weight decay. The scheduling logic is spread across:</p><p>This is a real research codebase with many contributors, and the coupling between scheduling and training logic makes it hard to experiment with different schedules without touching multiple files.</p><p>This leads to \"smelly\" code: the scheduling logic is coupled with the training loop, which makes the scheduling logic hard to change and test.</p><p>Enter PyTorch's built-in , it's meant to clean this up for LR specifically. Basic usage mirrors the manual tweak but abstracts it:</p><pre><code>from torch.optim.lr_scheduler import StepLR optimizer = optim.AdamW(model.parameters(), lr=1e-3) scheduler = StepLR(optimizer, step_size=30, gamma=0.1) # Decay LR every 30 epochs by 0.1x for epoch in range(num_epochs): for batch in dataloader: # ... compute loss, backward optimizer.step() scheduler.step() # Updates LR after epoch (not per-batch in this case) </code></pre><p>Under the hood, when you call , it calls  (defined in  base class at <a href=\"https://github.com/pytorch/pytorch/blob/main/torch/optim/lr_scheduler.py#L284\">L284</a>), which:</p><ol><li>Calls  to compute the new learning rates for each param group</li><li>Iterates through  and calls <code>_update_param_group_val(param_group, \"lr\", lr)</code> to set each group's  key</li></ol><p>The key point:  (defined at <a href=\"https://github.com/pytorch/pytorch/blob/main/torch/optim/lr_scheduler.py#L83\">L83</a>) is just a helper that does  (with special handling for Tensor LRs).</p><p>As a result, these schedulers are hardcoded to  handle LR, not momentum, betas, weight decay, or anything else you might want to schedule (which, as seen in the modded-nanogpt example, people do all the time). <strong>hardcoded instead of allowing any</strong><strong>key? It's literally just a string argument.</strong> This limitation is artificial forces everyone to reimplement scheduling for non-LR hyperparams from scratch.</p><p>Now, onto the design of other PyTorch schedulers themselves. Most derive from  and implement their own  method. Functionally, many could be expressed as  with an appropriate lambda.</p><p>For instance,  is equivalent to a lambda that drops by  every  epochs, and  is equivalent to a cosine lambda. However, they're implemented as separate classes with their own closed-form formulas (via ), which can be more efficient and readable.</p><p>(Btw  isn't even a subclass of , it's a callback that monitors metrics.).</p><p> is the most flexible among all PyTorch schedulers. However, usage of the class is inconvenient for multi-group setups.</p><p>For example, if you want a custom lambda for group 2, you  provide dummies for groups 0 and 1 (constants, which aren't \"real\" schedules):</p><pre><code>from torch.optim.lr_scheduler import LambdaLR def constant_lambda(_): return 1.0 # Dummy def decay_lambda(epoch): return 1.0 - epoch / 100 # Actual for group 2 scheduler = LambdaLR(optimizer, lr_lambda=[constant_lambda, constant_lambda, decay_lambda]) </code></pre><p>Clunky, right? Changing total training length? Your lambdas hardcode it, so tweaks mean rewriting (though factories/partials help, it's still boilerplate). Advanced schemes like cyclic schedules? <code>CosineAnnealingWarmRestarts</code> exists, but it's LR-only and inflexible for custom cycles or non-LR params.</p><p>So, what  is a schedule? At its core, it's a pure function: <code>f(step: int, total_steps: int) -&gt; value</code> (any type, not just float). It maps progress to a param value, and you apply it to <code>optimizer.param_groups[i][param_name] = value</code>. No state, no side effects, just deterministic computation (great for reproducibility).</p><p>In my suite, this primitive is user-facing via  (end users are expected to use it directly):</p><pre><code>from research_lib.training.scheduling import ParamSchedule def linear_decay(step: int, total_steps: int) -&gt; float: return 1.0 - (step / total_steps) * 0.9 # Decays from 1.0 to 0.1 lr_schedule = ParamSchedule(param_name=\"lr\", schedule_fn=linear_decay) value = lr_schedule(500, 1000) # 0.55 </code></pre><p>For common patterns, presets (subclasses of the primitive) are provided: e.g., <code>WarmupStableDecaySchedule</code> for warmup ‚Üí stable ‚Üí decay:</p><pre><code>from research_lib.training.scheduling import WarmupStableDecaySchedule lr_schedule = WarmupStableDecaySchedule( param_name=\"lr\", warmup_steps=100, cooldown_frac=0.5, min_value=0.0, max_value=1.0, decay_type=\"cosine\" ) </code></pre><p>Need reusable patterns? Subclass the primitive and override the schedule_fn attribute</p><p>For cyclic schedules e.g. for continual training, enter \"wrapper land\" (via  submodule). These are composable callables that wrap a :</p><pre><code>from research_lib.training.scheduling import wrappers as sw base_fn = ... # e.g., a decay schedule cyclic_fn = sw.Cyclic(base_fn, cycle_steps=1000) # Repeats every 1000 steps lr_schedule = ParamSchedule(\"lr\", cyclic_fn) </code></pre><p>Finally, the runtime layer:  binds it all, tracks state for checkpointing, and supports global + per-group overrides:</p><pre><code>from research_lib.training.scheduling import ParamScheduler scheduler = ParamScheduler( optimizer=optimizer, global_schedules=[lr_schedule, momentum_schedule], group_overrides={1: [slow_lr_schedule]}, # Override for group 1 total_steps=10000 ) # In loop optimizer.step() scheduler.step() # Applies all, increments internal step # Checkpoint: scheduler.state_dict() / load_state_dict() </code></pre><p>When designing this, I followed these design choices:</p><ul><li>\"No restriction on action space\" (schedules can do anything PyTorch allows),</li><li>\"Make illegal states unrepresentable\" (required args aren't optional; validation at )</li><li>Minimize coupling (schedules are pure, optimizer bound at runtime).</li></ul><p>It's tested thoroughly (e.g., pickling, validation checks like monotonicity). Thoughts? Does this solve pains you've hit? Link to submodule <a href=\"https://github.com/shivvor2/research-monorepo/tree/master/src/research_lib/training/scheduling\">here</a>: LMK if I should extract it!</p>",
      "contentLength": 8115,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "A VC and some big-name programmers are trying to solve open source‚Äôs funding problem, permanently",
      "url": "https://techcrunch.com/2026/02/26/a-vc-and-some-big-name-programmers-are-trying-to-solve-open-sources-funding-problem-permanently/",
      "date": 1772122264,
      "author": "/u/Outrageous-Baker5834",
      "guid": 48578,
      "unread": true,
      "content": "<p>A group of notable open source programmers are joining with a VC investor to launch a nonprofit called the <a href=\"https://endowment.dev/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Open Source Endowment</a> in hopes of permanently solving the perennial issue with developing open source software: funding.&nbsp;</p><p>The nonprofit, which just achieved formal 501(c)(3) status, has currently raised more than $750,000 in commitments. But if things go according to the plan of its founder, <a href=\"https://kvinogradov.com/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Konstantin Vinogradov</a>, it will have $100 million in assets within seven years.&nbsp;</p><p>Vinogradov is a venture investor specializing in open source, AI, and infrastructure software, and was previously a general partner at Runa Capital. As such, he has ‚Äúsome experience with university endowments,‚Äù which are some of the largest investors in venture capital funds, he told TechCrunch.&nbsp;&nbsp;</p><p>Vinogradov says as he scoured the world for open source projects, one complaint kept popping up: ‚ÄúThere is no source of sustainable funding for open source maintainers. And that‚Äôs a really big problem.‚Äù&nbsp;(‚ÄúMaintainer‚Äù refers to the developers who work on open source projects, such as debugging, choosing and verifying features submitted by the community, or programming new features themselves.)</p><p>The endowment will support projects based on criteria such as its number of users, or how many other projects rely on that specific software to operate. It will also choose projects that are not already well-supported by grants, donations, or umbrella organizations such as Linux‚Äôs Alpha-Omega.&nbsp;Vinogradov has already assembled a board for the nonprofit.</p><h2>Cash strapped, burned out</h2><p>The lack of money in open source is hardly new. Open source software is typically given away, and since the community often contributes time and efforts freely, up to 86% of open source developers <a href=\"https://itsfoss.com/news/open-source-developers-are-exhausted/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">are not paid for their work.</a></p><p>This isn‚Äôt much of a problem for hobbyists or for professional developers paid by their companies to maintain projects,&nbsp;but such a system stands on shaky ground. Open source software is the bedrock upon which the internet stands, and virtually every large company uses open source tools in some way. In fact, open source software accounts for <a href=\"https://www.linuxfoundation.org/research/world-of-open-source-global-2025?hsLang=en&amp;_gl=1*3pooru*_up*MQ..*_ga*NjUzMTQ0MDA1LjE3NzE5NjEyMDM.*_ga_BKD8K5CRV0*czE3NzE5NjEyMDIkbzEkZzAkdDE3NzE5NjEyMDIkajYwJGwwJGgw*_ga_FBYHX832ZD*czE3NzE5NjEyMDIkbzEkZzAkdDE3NzE5NjEyMDIkajYwJGwwJGgw\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">up to 55% of the tech stack in organizations</a>, and is present in everything from databases to operating systems.&nbsp;</p><p>There is, and has been for decades, a core of developers who volunteer their time and efforts for free to manage popular, important, and critical projects. And many of them are <a href=\"https://opensourcepledge.com/blog/burnout-in-open-source-a-structural-problem-we-can-fix-together/?ref=itsfoss.com\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">burned out.</a></p><p>This issue came into the public‚Äôs consciousness briefly in 2014, with the <a href=\"https://techcrunch.com/2014/04/07/massive-security-bug-in-openssl-could-effect-a-huge-chunk-of-the-internet/\">OpenSSL Heartbleed disaster,</a> where a bug was found in an open source security project, used by most of the internet, that was maintained by a single developer.&nbsp;</p><p>There have been many attempts to fix the funding situation over the years. Some projects take donations from corporate sponsors. For instance, The Linux Foundation, which brought in about <a href=\"https://www.phoronix.com/news/Linux-Foundation-2025-Report\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">$300 million last year</a> largely from corporate sponsors, doles out grants to select projects through its Alpha-Omega Project. In 2025, Alpha-Omega issued $5.8 million to 14 projects, it said.&nbsp;&nbsp;</p><p>Still, not every developer wants to take corporate donations, as there are worries of granting too much influence to donor companies.&nbsp;For instance, there was a big hubbub last year in the Ruby community surrounding some long-time maintainers leaving and its big sponsor Shopify, <a href=\"https://www.theregister.com/2025/09/25/open_source_to_closed_doors/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">The Register reported.</a></p><p>The Open Source Endowment hopes to support projects while displacing such risks.&nbsp;</p><p>‚ÄúThe only way to support open source sustainably is private funds,‚Äù says Vinogradov.&nbsp;</p><p>Why hasn‚Äôt an endowment been tried before? Endowments require patience, Vinogradov says. They invest many of their assets, spending only a fraction of their income in any given year, and require years or even decades to grow to a meaningful size.</p><p>But if done right, that patience will result in an independent fund that could support critical open source projects forever.</p>",
      "contentLength": 3910,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rfeaei/a_vc_and_some_bigname_programmers_are_trying_to/"
    },
    {
      "title": "A VC and some big-name programmers are trying to solve open source's funding problem, permanently",
      "url": "https://techcrunch.com/2026/02/26/a-vc-and-some-big-name-programmers-are-trying-to-solve-open-sources-funding-problem-permanently/",
      "date": 1772122031,
      "author": "/u/whit537",
      "guid": 48605,
      "unread": true,
      "content": "<p>A group of notable open source programmers are joining with a VC investor to launch a nonprofit called the <a href=\"https://endowment.dev/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Open Source Endowment</a> in hopes of permanently solving the perennial issue with developing open source software: funding.&nbsp;</p><p>The nonprofit, which just achieved formal 501(c)(3) status, has currently raised more than $750,000 in commitments. But if things go according to the plan of its founder, <a href=\"https://kvinogradov.com/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Konstantin Vinogradov</a>, it will have $100 million in assets within seven years.&nbsp;</p><p>Vinogradov is a venture investor specializing in open source, AI, and infrastructure software, and was previously a general partner at Runa Capital. As such, he has ‚Äúsome experience with university endowments,‚Äù which are some of the largest investors in venture capital funds, he told TechCrunch.&nbsp;&nbsp;</p><p>Vinogradov says as he scoured the world for open source projects, one complaint kept popping up: ‚ÄúThere is no source of sustainable funding for open source maintainers. And that‚Äôs a really big problem.‚Äù&nbsp;(‚ÄúMaintainer‚Äù refers to the developers who work on open source projects, such as debugging, choosing and verifying features submitted by the community, or programming new features themselves.)</p><p>The endowment will support projects based on criteria such as its number of users, or how many other projects rely on that specific software to operate. It will also choose projects that are not already well-supported by grants, donations, or umbrella organizations such as Linux‚Äôs Alpha-Omega.&nbsp;Vinogradov has already assembled a board for the nonprofit.</p><h2>Cash strapped, burned out</h2><p>The lack of money in open source is hardly new. Open source software is typically given away, and since the community often contributes time and efforts freely, up to 86% of open source developers <a href=\"https://itsfoss.com/news/open-source-developers-are-exhausted/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">are not paid for their work.</a></p><p>This isn‚Äôt much of a problem for hobbyists or for professional developers paid by their companies to maintain projects,&nbsp;but such a system stands on shaky ground. Open source software is the bedrock upon which the internet stands, and virtually every large company uses open source tools in some way. In fact, open source software accounts for <a href=\"https://www.linuxfoundation.org/research/world-of-open-source-global-2025?hsLang=en&amp;_gl=1*3pooru*_up*MQ..*_ga*NjUzMTQ0MDA1LjE3NzE5NjEyMDM.*_ga_BKD8K5CRV0*czE3NzE5NjEyMDIkbzEkZzAkdDE3NzE5NjEyMDIkajYwJGwwJGgw*_ga_FBYHX832ZD*czE3NzE5NjEyMDIkbzEkZzAkdDE3NzE5NjEyMDIkajYwJGwwJGgw\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">up to 55% of the tech stack in organizations</a>, and is present in everything from databases to operating systems.&nbsp;</p><p>There is, and has been for decades, a core of developers who volunteer their time and efforts for free to manage popular, important, and critical projects. And many of them are <a href=\"https://opensourcepledge.com/blog/burnout-in-open-source-a-structural-problem-we-can-fix-together/?ref=itsfoss.com\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">burned out.</a></p><p>This issue came into the public‚Äôs consciousness briefly in 2014, with the <a href=\"https://techcrunch.com/2014/04/07/massive-security-bug-in-openssl-could-effect-a-huge-chunk-of-the-internet/\">OpenSSL Heartbleed disaster,</a> where a bug was found in an open source security project, used by most of the internet, that was maintained by a single developer.&nbsp;</p><p>There have been many attempts to fix the funding situation over the years. Some projects take donations from corporate sponsors. For instance, The Linux Foundation, which brought in about <a href=\"https://www.phoronix.com/news/Linux-Foundation-2025-Report\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">$300 million last year</a> largely from corporate sponsors, doles out grants to select projects through its Alpha-Omega Project. In 2025, Alpha-Omega issued $5.8 million to 14 projects, it said.&nbsp;&nbsp;</p><p>Still, not every developer wants to take corporate donations, as there are worries of granting too much influence to donor companies.&nbsp;For instance, there was a big hubbub last year in the Ruby community surrounding some long-time maintainers leaving and its big sponsor Shopify, <a href=\"https://www.theregister.com/2025/09/25/open_source_to_closed_doors/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">The Register reported.</a></p><p>The Open Source Endowment hopes to support projects while displacing such risks.&nbsp;</p><p>‚ÄúThe only way to support open source sustainably is private funds,‚Äù says Vinogradov.&nbsp;</p><p>Why hasn‚Äôt an endowment been tried before? Endowments require patience, Vinogradov says. They invest many of their assets, spending only a fraction of their income in any given year, and require years or even decades to grow to a meaningful size.</p><p>But if done right, that patience will result in an independent fund that could support critical open source projects forever.</p>",
      "contentLength": 3910,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rfe6od/a_vc_and_some_bigname_programmers_are_trying_to/"
    },
    {
      "title": "paqet ‚Äì a Go proxy that bypasses the OS network stack entirely",
      "url": "https://www.reddit.com/r/golang/comments/1rfdo1k/paqet_a_go_proxy_that_bypasses_the_os_network/",
      "date": 1772120893,
      "author": "/u/zerodawntodusk",
      "guid": 48577,
      "unread": true,
      "content": "<p>The approach is kind of wild, instead of using the normal OS networking stack, it hooks in at the packet level via pcap + gopacket, crafting and injecting raw TCP packets directly. That means no SYN/SYN-ACK/ACK handshake at all, the OS never even knows a connection exists. As a side effect, host firewalls like ufw are completely bypassed since pcap grabs packets before netfilter ever sees them. KCP runs on top for reliable encrypted transport, and the whole thing presents as a SOCKS5 proxy.</p><p>Still alpha but a really interesting read if you're into low-level networking in Go. </p>",
      "contentLength": 580,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Process external files in const fn: no build.rs, no proc macros, no binary bloat",
      "url": "https://www.reddit.com/r/rust/comments/1rfdek3/process_external_files_in_const_fn_no_buildrs_no/",
      "date": 1772120305,
      "author": "/u/carlk22",
      "guid": 48644,
      "unread": true,
      "content": "<p>Here‚Äôs a fun Rust trick I‚Äôve been experimenting with for embedded work:</p><p>You can use  inside a , to process file contents at compile time, and keep only the final result in your binary.</p><p>No . No proc macros. No runtime cost.</p><pre><code>const fn sum_u16s() -&gt; u128 { let data: &amp;[u8; 8] = include_bytes!(\"data.bin\"); assert!(data.len() % 2 == 0); let mut i = 0; let mut acc: u128 = 0; while i &lt; data.len() { // interpret two bytes as little-endian u16 let value = (data[i] as u16) | ((data[i + 1] as u16) &lt;&lt; 8); acc += value as u128; i += 2; } acc } static SUM: u128 = sum_u16s(); </code></pre><ul><li> reads the file at compile time.</li><li>The loop runs entirely in const evaluation.</li><li>The compiler computes SUM during compilation.</li><li>Only the u128 result is stored in the final binary.</li></ul><p>If you remove the static SUM, the file contributes zero bytes to the binary (release build). It‚Äôs just compile-time input.</p><p>For embedded Rust, this effectively gives you a tiny compile-time asset pipeline:</p><ul><li>Read raw data files (audio, lookup tables, calibration data, etc.)</li><li>Transform them (even some audio compression)</li><li>Materialize only the final representation you actually need</li></ul><p>And you only pay flash space for what you explicitly store. It‚Äôs surprisingly powerful and it‚Äôs all stable Rust today.</p>",
      "contentLength": 1234,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "PULS v0.8.0 Released - A unified system monitoring and management tool for Linux",
      "url": "https://github.com/word-sys/puls/releases/tag/0.8.0",
      "date": 1772118578,
      "author": "/u/word-sys",
      "guid": 48700,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rfcn4q/puls_v080_released_a_unified_system_monitoring/"
    },
    {
      "title": "What are your favorite kubectl plugins?",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rfceo0/what_are_your_favorite_kubectl_plugins/",
      "date": 1772118051,
      "author": "/u/_racy",
      "guid": 48534,
      "unread": true,
      "content": "<div><p>Thinking about writing one I would love good examples to follow</p></div>   submitted by   <a href=\"https://www.reddit.com/user/_racy\"> /u/_racy </a>",
      "contentLength": 91,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Developers Are Safe‚Ä¶ Thanks to Corporate Red Tape",
      "url": "https://azamsharp.com/2026/02/26/developers-are-safe.html",
      "date": 1772117486,
      "author": "/u/Select_Bicycle4711",
      "guid": 48674,
      "unread": true,
      "content": "<p>By the end of 2026, AI will write most of the code and software developers will be obsolete. There is no need to learn programming because you will be replaced by an AI agent. We have all heard these kinds of crazy headlines. I am here to tell you that the reality is quite different.</p><p>This post is a result of my <a href=\"https://x.com/azamsharp/status/2026853270526816687?s=20\">tweet</a> that got 80K+ views and 258 plus comments. The responses were passionate, but they also confirmed something I have seen over and over again in real enterprise environments. The world of corporate software development does not move at the speed of Twitter headlines.</p><div role=\"region\" aria-label=\"SwiftUI Architecture Book Banner\"><div><div><p>SwiftUI Architecture Book</p><h3>Patterns and Practices for Building Scalable Applications</h3><p>\n        A practical guide to building SwiftUI apps that stay clean as they grow.\n      </p></div></div></div><h3>jQuery Exception Paper Work</h3><p>Let me first tell you a little story. Long time ago, I was working at an oil and gas company in Houston, Texas. The codebase had been implemented by an offshore company and it was an absolute mess. It was a .NET web application with hundreds of JavaScript files, and each file contained at least 5000 lines of code. A lot of that code was simply recreating effects and user interface components that could have easily been implemented using a third party library like jQuery. Yes, this was a long time ago.</p><p>After working with the code for a couple of days, I suggested that we should use jQuery to speed up development and avoid rebuilding the same things over and over again. My manager told me that we could not use any third party dependencies unless I filled out an exception paper work request. I had to indicate in detail the purpose of the library, where it would be used, which functions would be used, and which files would be altered. It was not a casual approval. It was a formal process.</p><p>I completed the paper work. Two weeks later, jQuery was granted an exception and I was allowed to continue the work, this time moving much faster. Two weeks for a tiny JavaScript library. That was the reality.</p><p>You might think this was an isolated incident. Unfortunately, it was not.</p><p>Here is another one. I was working at a very large oil and gas company and was tasked with creating an iPhone app. This was during the Objective C days, around iOS 3. The app was meant to be deployed internally using an Apple Enterprise account. After I finished the app, I discussed deployment with my manager. I told them that I had deployed personal apps before using a personal account, but I had never done an Enterprise deployment.</p><p>I suggested that they log into the Enterprise account and sit with me so I could see the interface and guide them through the process. They refused. They would not allow me to see the Enterprise account login due to security concerns. Instead, they made me stand outside their office while they logged in. They described what they saw on the screen, and I had to tell them what to click. If you see a Next button, click that. Enter the app name. Upload the build. I deployed an enterprise app by listening to someone narrate the screen from behind a door.</p><h3>Agile Development Is Not for Us</h3><p>At another very large finance company, I was consulting on a greenfield iOS project. The company was not familiar with Agile principles, so we conducted an introduction session explaining sprints, scrum, velocity, and iterative development. We walked them through how Agile could improve feedback cycles and delivery speed.</p><p>After the session, they told us that Agile seemed too complicated and that they would rather stick with their existing process, which was waterfall. This was for a brand new mobile project, yet they preferred the comfort of a rigid, document heavy approach over adaptive development. Change, even when beneficial, was seen as risk.</p><h3>Pandas, Matplotlib, Scikit Learn Oh My</h3><p>One of my friends who works at an enterprise company told me that they had to go through several levels of clearance just to install and use Pandas, NumPy, and Matplotlib. The concern was that these libraries might somehow steal data. These are widely used open source libraries that power research, analytics, and machine learning around the world, yet they were treated as potential threats requiring formal approval.</p><p>The point of these real stories is simple. When tools as basic as jQuery require weeks of approvals, how can we assume that the same companies will welcome AI tools with open arms? These are the same companies that provide limited access to online AI tools. These are the same companies where YouTube and Stack Overflow are blocked. These are the same companies that built their own internal code repository instead of using GitHub.</p><p>You might say that these companies will eventually be replaced by forward thinking organizations that embrace AI agents and automation. That sounds nice in theory. In reality, I am talking about insanely large companies. Their coffee budget is larger than some smaller competitors‚Äô entire operating budgets. They are not disappearing anytime soon.</p><p>And let me be clear. The stories I shared are only a few examples. This kind of red tape is extremely common, especially in non IT companies such as oil and gas, healthcare, finance, manufacturing, and other highly regulated industries. In these environments, compliance, risk management, security audits, and approval chains are not optional. They are built into the culture. Nothing moves fast. Every new tool, every dependency, every external service goes through layers of review. AI will not magically bypass that structure.</p><p>As much as we may complain about how slowly these organizations move and how resistant they are to adopting new technologies, that same resistance is what slows down radical change. These will be the companies that move cautiously with AI agents. These will be the companies that continue to rely on experienced human developers who understand business rules, compliance requirements, risk management, and the real consequences of mistakes.</p><p>AI will absolutely change how we work. It will make us faster and more productive. But the idea that developers will be wiped out overnight ignores how corporate systems actually function.</p><p>Stay strong and keep coding üòâ</p>",
      "contentLength": 6164,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rfc62c/developers_are_safe_thanks_to_corporate_red_tape/"
    },
    {
      "title": "Rerun 0.30 - blazingly fast visualization toolbox for Robotics",
      "url": "https://github.com/rerun-io/rerun/releases/tag/0.30.0",
      "date": 1772116306,
      "author": "/u/Fickle-Conference-87",
      "guid": 48824,
      "unread": true,
      "content": "<p>Rerun is an easy-to-use visualization toolbox and database for multimodal and temporal data. It's written in Rust, using wgpu and egui. Try it live at <a href=\"https://rerun.io/viewer\">https://rerun.io/viewer</a>. You can use rerun as a Rust library, or as a standalone binary (rerun a_mesh.g1b).</p><p>With this release you can plot arbitrary scalar data directly in time series views (floats, ints, uints, bools, including nested Arrow data) even without predefined semantics.</p><p>The release also introduces a new extension model: you can register custom visualizers directly into existing 2D/3D/Map views, define your own archetypes, and use fully custom shaders ‚Äî without forking the Viewer. That means domain-specific GPU renderers (e.g., height fields, cost maps, learned fields) can live inside the standard app.</p><p>The Viewer now supports on-demand streaming when connected to a Rerun server or Rerun Cloud, fetching only what you‚Äôre viewing and evicting stale data as you scrub. This enables working with recordings larger than RAM ‚Äî including in the web viewer beyond the 4 GiB Wasm limit.</p>",
      "contentLength": 1052,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/rust/comments/1rfboaa/rerun_030_blazingly_fast_visualization_toolbox/"
    },
    {
      "title": "[P] PerpetualBooster v1.9.0 - GBM with no hyperparameter tuning, now with built-in causal ML, drift detection, and conformal prediction",
      "url": "https://www.reddit.com/r/MachineLearning/comments/1rfb6yq/p_perpetualbooster_v190_gbm_with_no/",
      "date": 1772115119,
      "author": "/u/mutlu_simsek",
      "guid": 48727,
      "unread": true,
      "content": "<p>Posted about Perpetual at v1.1.2 - here's an update. For those who missed it: it's a gradient boosting machine in Rust where you replace hyperparameter tuning with a single  parameter. Set it, call , done.</p><p><code>python model = PerpetualBooster(objective=\"SquaredLoss\", budget=1.0) model.fit(X, y) </code></p><p>Since then the Rust core basically doubled (~16.5k lines added). Here's what's new:</p><p> - full suite built into the same Rust core: Double Machine Learning, meta-learners (S/T/X), uplift (R-learner), instrumental variables, policy learning, fairness-aware objectives. Not a wrapper ‚Äî the causal estimators use the same budget-based generalization. Causal effect estimation without hyperparameter tuning.</p><p> - data drift and concept drift detection using the trained tree structure. No ground truth labels or retraining needed.</p><p> - conformalized quantile regression (CQR) for prediction intervals with marginal and conditional coverage. Isotonic calibration for classification. Train once, calibrate on holdout, get intervals at any alpha without retraining. [predict_intervals(), predict_sets(), predict_distribution()].</p><p> - regression (Squared, Huber, AdaptiveHuber, Absolute, Quantile, Poisson, Gamma, Tweedie, MAPE, Fair, SquaredLog), classification (LogLoss, Brier, CrossEntropy, Hinge), ranking (ListNet), plus custom objectives.</p><p> -  for multi-target problems. </p><p> - improved to O(n) from O(n¬≤).</p><p>vs. Optuna + LightGBM (100 trials): matches accuracy with up to . vs. AutoGluon v1.2 (best quality, AutoML benchmark leader): Perpetual won , inferred up to 5x faster, and didn't OOM on 3 tasks where AutoGluon did.</p><p>The only single GBM package I know of shipping causal ML, calibration, drift monitoring, ranking, and 19 objectives together. Pure Rust, Python/R bindings, Apache 2.0.</p><p>Happy to answer questions about the algorithm or benchmarks.</p>",
      "contentLength": 1819,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "The MySQL-to-Postgres Migration That Saved $480K/Year: A Step-by-Step Guide",
      "url": "https://medium.com/@dusan.stanojevic.cs/the-mysql-to-postgres-migration-that-saved-480k-year-a-step-by-step-guide-4b0fa9f5bdb7",
      "date": 1772114957,
      "author": "/u/narrow-adventure",
      "guid": 48550,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rfb4lj/the_mysqltopostgres_migration_that_saved_480kyear/"
    },
    {
      "title": "Rust Is Eating JavaScript",
      "url": "https://leerob.com/rust",
      "date": 1772113918,
      "author": "/u/Active-Fuel-49",
      "guid": 48551,
      "unread": true,
      "content": "<a href=\"https://leerob.com/\">2021 (updated 2026) ‚Äì Lee Robinson</a><p><a href=\"https://www.rust-lang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Rust</a> is a fast, reliable, and memory-efficient programming language. It‚Äôs been voted the <a href=\"https://survey.stackoverflow.co/2024/#technology-admired-and-desired\" target=\"_blank\" rel=\"noopener noreferrer\">most admired programming language</a> for a decade. Created by Mozilla, it‚Äôs now used at <a href=\"https://engineering.fb.com/2021/04/29/developer-tools/rust/\" target=\"_blank\" rel=\"noopener noreferrer\">Meta</a>, <a href=\"https://twitter.com/oskargroth/status/1301502690409709568\" target=\"_blank\" rel=\"noopener noreferrer\">Apple</a>, <a href=\"https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/\" target=\"_blank\" rel=\"noopener noreferrer\">Amazon</a>, <a href=\"https://twitter.com/ryan_levick/status/1171830191804551168\" target=\"_blank\" rel=\"noopener noreferrer\">Microsoft</a>, and <a href=\"https://security.googleblog.com/2021/04/rust-in-android-platform.html\" target=\"_blank\" rel=\"noopener noreferrer\">Google</a> for systems infrastructure, encryption, virtualization, and more low-level programming.</p><p>Why is Rust now being used to replace parts of the JavaScript web ecosystem like minification (Terser), transpilation (Babel), formatting (Prettier), bundling (webpack), linting (ESLint), and more?</p><p>Rust helps developers write fast software that‚Äôs memory-efficient. It‚Äôs a modern replacement for languages like C++ or C with a focus on code safety and concise syntax.</p><p>Rust is quite different than JavaScript. JavaScript tries to find variables or objects not in use and automatically clears them from memory. This is called <a href=\"https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)\" target=\"_blank\" rel=\"noopener noreferrer\">Garbage Collection</a>. The language abstracts the developer from thinking about manual memory management.</p><p>With Rust, developers have more control over memory allocation, without it being as painful as C++.</p><blockquote><p>Rust uses a relatively unique memory management approach that incorporates the idea of memory \"ownership‚Äù. Basically, Rust keeps track of who can read and write to memory. It knows when the program is using memory and immediately frees the memory once it is no longer needed. It enforces memory rules at compile time, making it virtually impossible to have runtime memory bugs. You do not need to manually keep track of memory. The compiler takes care of it. ‚Äì <a href=\"https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f\" target=\"_blank\" rel=\"noopener noreferrer\">Discord</a></p></blockquote><p>On top of the companies mentioned above, Rust is also being used for popular open-source libraries like:</p><ul></ul><blockquote><p>Rust has been a force multiplier for our team, and betting on Rust was one of the best decisions we made. More than performance, its ergonomics and focus on correctness has helped us tame sync‚Äôs complexity. We can encode complex invariants about our system in the type system and have the compiler check them for us. ‚Äì <a href=\"https://dropbox.tech/infrastructure/rewriting-the-heart-of-our-sync-engine\" target=\"_blank\" rel=\"noopener noreferrer\">Dropbox</a></p></blockquote><p>JavaScript is the most widely used programming language, operating on every device with a web browser. Over the past ten years, a massive ecosystem has been built around JavaScript:</p><ul><li> bundle multiple JavaScript files into one.</li><li> write modern JavaScript while supporting older browsers.</li><li> generate the smallest possible file sizes.</li><li> format code in an opinionated way.</li><li> find issues with their code before deploying.</li></ul><p>Millions of lines of code have been written and even more bugs have been fixed to create the bedrock for shipping web applications of today. All of these tools are written with JavaScript or TypeScript. This has worked well, but we've reached peak optimization with JS. This has inspired a new class of tools, designed to drastically improve the performance of building for the web.</p><p><a href=\"http://swc.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">SWC</a>, created in 2017, is an extensible Rust-based platform for the next generation of fast developer tools. It‚Äôs used by tools like Next.js, Parcel, and Deno, as well as companies like Vercel, ByteDance, Tencent, Shopify, and more.</p><p>SWC can be used for compilation, minification, bundling, and more ‚Äì and is designed to be extended. It‚Äôs something you can call to perform code transformations (either built-in or custom). Running those transformations happens through higher-level tools like Next.js.</p><p><a href=\"https://deno.land/\" target=\"_blank\" rel=\"noopener noreferrer\">Deno</a>, created in 2018, is a simple, modern, and secure runtime for JavaScript and TypeScript that uses <a href=\"https://v8.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">V8</a> and is built with Rust. It‚Äôs an attempt to replace Node.js, written by the original creators of Node.js. While it was created in 2018, it didn‚Äôt hit <a href=\"https://deno.com/blog/v1\" target=\"_blank\" rel=\"noopener noreferrer\">v1.0 until May 2020</a>.</p><p>Deno‚Äôs linter, code formatter, and docs generator are <a href=\"https://twitter.com/devongovett/status/1369033422002389000\" target=\"_blank\" rel=\"noopener noreferrer\">built using SWC</a>.</p><p><a href=\"https://esbuild.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">esbuild</a>, created in January 2020, is a JavaScript bundler and minifier 10-100x faster than existing tools, written in Go.</p><blockquote><p>I‚Äôm trying to create a build tool that A) works well for a given sweet spot of use cases (bundling JavaScript, TypeScript, and maybe CSS) and B) <strong>resets the expectations of the community for what it means for a JavaScript build tool to be fast</strong>. Our current tools are way too slow in my opinion. ‚Äì Evan, Creator of esbuild (<a href=\"https://news.ycombinator.com/item?id=22336334\" target=\"_blank\" rel=\"noopener noreferrer\">Source</a>)</p></blockquote><p>Building JavaScript tooling with systems programming languages, like Go and Rust, was fairly niche until esbuild was released. In my opinion, esbuild sparked a wider interest in trying to make developer tools faster. Evan chose to use Go:</p><blockquote><p>The Rust version probably could be made to work at an equivalent speed with enough effort. But at a high level, Go was much more enjoyable to work with. This is a side project and it has to be fun for me to work on it. ‚Äì Evan, Creator of esbuild (<a href=\"https://news.ycombinator.com/item?id=22336284\" target=\"_blank\" rel=\"noopener noreferrer\">Source</a>)</p></blockquote><p>Some argue Rust could perform better, but both could achieve Evan‚Äôs original goal of influencing the community:</p><blockquote><p>Even with just basic optimization, Rust was able to outperform the hyper hand-tuned Go version. This is a huge testament to how easy it is to write efficient programs with Rust compared to the deep dive we had to do with Go. ‚Äì <a href=\"https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f\" target=\"_blank\" rel=\"noopener noreferrer\">Discord</a></p></blockquote><p><a href=\"https://rome.tools/blog/2020/08/08/introducing-rome\" target=\"_blank\" rel=\"noopener noreferrer\">Rome</a>, created in August 2020,&nbsp;is a linter, compiler, bundler, test runner, and more, for JavaScript, TypeScript, HTML, JSON, Markdown, and CSS. They aim to replace and unify the entire frontend development toolchain. It‚Äôs created by <a href=\"https://twitter.com/sebmck\" target=\"_blank\" rel=\"noopener noreferrer\">Sebastian</a>, who also created Babel.</p><p>Why rewrite everything, then?</p><blockquote><p>Making the necessary modifications to Babel to allow for it to be a reliable base for other tools would have required changes to absolutely everything. The architecture is bound to the initial design choices I made in 2014 when I was learning about parsers, ASTs, and compilers. - Sebastian (<a href=\"https://rome.tools/blog/2020/08/08/introducing-rome\" target=\"_blank\" rel=\"noopener noreferrer\">Source</a>)</p></blockquote><p>Rome is currently written in TypeScript and runs on Node.js. But they're now working on <a href=\"https://rome.tools/blog/2021/09/21/rome-will-be-rewritten-in-rust\" target=\"_blank\" rel=\"noopener noreferrer\">rewriting in Rust</a> using RSLint parser and their own visitor system for AST traversal.</p><p>Rust‚Äôs integration with Node.js is better than other low-level languages.</p><p><a href=\"https://napi.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">napi-rs</a> allows you to build pre-compiled Node.js add-ons with Rust. It provides an out-of-the-box solution for cross-compilation and publishing native binaries to NPM, without needing  or  scripts.</p><p>You can build a Rust module that can be called directly from Node.js, without needing to create a child process like esbuild.</p><p><a href=\"https://webassembly.org/docs/use-cases/\" target=\"_blank\" rel=\"noopener noreferrer\">WebAssembly</a>&nbsp;(WASM) is a portable low-level language that Rust can compile to. It runs in the browser, is interoperable with JavaScript, and is supported in all major modern browsers.</p><blockquote><p>WASM is definitely a lot faster than JS, but not quite native speed. In our tests, Parcel runs 10-20x slower when compiled to WASM than with native binaries. ‚Äì <a href=\"https://twitter.com/devongovett\" target=\"_blank\" rel=\"noopener noreferrer\">Devon Govett</a></p></blockquote><p>While WASM isn‚Äôt the perfect solution yet, it  help developers create extremely fast web experiences. The Rust team is <a href=\"https://www.rust-lang.org/what/wasm\" target=\"_blank\" rel=\"noopener noreferrer\">committed</a> to a high-quality and cutting-edge WASM implementation. For developers, this means you could have the performance advantages of Rust (vs. Go) while still compiling for the web (using WASM).</p><p>Some early libraries and frameworks in this space:</p><ul></ul><p>These Rust-based web frameworks that compile to WASM aren‚Äôt trying to replace JavaScript, but work alongside it. While we aren‚Äôt there yet, it‚Äôs interesting to see Rust coming after the web on both sides: <strong>making existing JavaScript tooling faster</strong>.</p><p>It‚Äôs Rust all the way down.</p><p>Rust has a steep learning curve. It‚Äôs a lower level of abstraction than what most web developers are used to.</p><p>Once you're on native code (through Rust, Go, Zig, or other low-level languages),\nthe algorithms and data structures are <a href=\"https://twitter.com/devongovett/status/1457945506332692482\" target=\"_blank\" rel=\"noopener noreferrer\">more important</a> than the language choice. It‚Äôs not a silver bullet.</p><blockquote><p>Rust makes you think about dimensions of your code that matter tremendously for systems programming. It makes you think about how memory is shared or copied. It makes you think about real but unlikely corner cases and make sure that they're handled. It helps you write code that‚Äôs incredibly efficient in every possible way. ‚Äì Tom MacWright (<a href=\"https://macwright.com/2021/01/15/rust.html\" target=\"_blank\" rel=\"noopener noreferrer\">Source</a>)</p></blockquote><p>Further, Rust‚Äôs usage in the web community is still niche. It hasn‚Äôt reached critical adoption. Even though learning Rust for JavaScript tooling will be a barrier to entry, interestingly developers would rather have a <a href=\"https://twitter.com/devongovett/status/1261379312898306048\" target=\"_blank\" rel=\"noopener noreferrer\">faster tool that‚Äôs harder to contribute to</a>. <a href=\"https://craigmod.com/essays/fast_software/\" target=\"_blank\" rel=\"noopener noreferrer\">Fast software wins</a>.</p><p>Currently, it‚Äôs hard to find a Rust library or framework for your favorite services (things like working with authentication, databases, payments, and more). I do think that once Rust and WASM reach critical adoption, this will resolve itself. But not yet. <strong>We need existing JavaScript tools to help us bridge the gap and incrementally adopt performance improvements</strong>.</p><h2>The Future of JavaScript Tooling</h2><p>I believe Rust is the future of JavaScript tooling. <a href=\"http://nextjs.org/12\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js 12</a> started our transition to fully replace Babel (transpilation) and Terser (minification) with SWC and Rust. Why?</p><ul><li> SWC can be used as a Crate inside Next.js, without having to fork the library or workaround design constraints.</li><li> We were able to achieve ~3x faster Fast Refresh and ~5x faster builds in Next.js by switching to SWC, with more room for optimization still in progress.</li><li> Rust‚Äôs support for WASM is essential for supporting all possible platforms and taking Next.js development everywhere.</li><li> The Rust community and ecosystem are amazing and only growing.</li></ul><p>It‚Äôs not just Next.js adopting SWC, either:</p><ul></ul><blockquote><p>Parcel uses SWC like a library. Before we used Babel‚Äôs parser and custom transforms written in JS. Now, we use SWC‚Äôs parser and <a href=\"https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/js/core/src\" target=\"_blank\" rel=\"noopener noreferrer\">custom transforms in Rust</a>. This includes a full scope hoisting implementation, dependency collection, and more. It‚Äôs similar in scope to how Deno built on top of SWC. ‚Äì <a href=\"https://twitter.com/devongovett\" target=\"_blank\" rel=\"noopener noreferrer\">Devon Govett</a></p></blockquote><p>It‚Äôs early days for Rust ‚Äì a few important pieces are still being figured out:</p><ul><li> Writing plugins in Rust isn‚Äôt as approachable for many JavaScript developers. At the same time, exposing a plugin system in JavaScript could negate performance gains. A definitive solution hasn‚Äôt emerged yet. Ideally, the future combines both JavaScript and Rust. If you want to write a plugin with JavaScript, it‚Äôs possible with a tradeoff for speed. Need more performance? Use the Rust plugin API.</li><li> One interesting area of development is , which is SWC‚Äôs replacement for Webpack. It‚Äôs still under development but could be very promising.</li><li> As mentioned above, the prospect of writing Rust and compiling to WASM is enticing, but there‚Äôs still work to be done.</li></ul><p>Regardless, I‚Äôm confident Rust will continue to have a major impact on the JavaScript ecosystem for the next 1-2 years and into the future. Imagine a world where all of the build tools used in Next.js are written in Rust, giving you optimal performance. Then, Next.js could be distributed as a <a href=\"https://en.wikipedia.org/wiki/Static_build\" target=\"_blank\" rel=\"noopener noreferrer\">static binary</a> you'd download from NPM.</p><p>That‚Äôs the world I want to live (and develop) in.</p><p>There was more investment into new Rust tooling in the JavaScript ecosystem. A few notable Rust projects include:</p><ul><li>: Rome, previously mentioned in this post, has became Biome</li><li>: New bundler with webpack compat</li><li>: New bundler for Vite (replacing esbuild and rollup)</li><li>: Similar to Biome: parser, linter, formatter, transpiler, minifier, etc</li><li>: New CSS parser, transformer, bundler, and minifier.</li></ul><p>Further, <a href=\"https://bun.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">Bun 1.0</a> was released, putting Zig on the map and working to speed up the entire JavaScript ecosystem.</p><p>When I wrote this post in 2021, Rust replacing JavaScript tooling was my lofty prediction. In 2026, nearly every major JavaScript build tool now has a Rust-based alternative or has been rewritten in Rust. Many of the projects listed in the 2023 update above have shipped stable releases, including:</p><ul><li>: Hit <a href=\"https://rolldown.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">1.0 RC</a> in January 2026. The Rust bundler replacing both esbuild and Rollup inside Vite, 10-30x faster than Rollup. <a href=\"https://vite.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">Vite 7</a> uses it as the default.</li><li>: <a href=\"https://oxc.rs/blog/2026-02-24-oxfmt-beta\" target=\"_blank\" rel=\"noopener noreferrer\">Oxfmt</a> (formatter) reached beta with 100% Prettier compatibility at 30x the speed. <a href=\"https://oxlint.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">Oxlint</a> is used by Vue.js, Turborepo, Sentry, and Hugging Face.</li><li>: The first JS/TS linter with <a href=\"https://biomejs.dev/blog/biome-v2\" target=\"_blank\" rel=\"noopener noreferrer\">type-aware linting</a> that doesn't require the TypeScript compiler. GritQL plugins and monorepo support.</li><li>: Hit <a href=\"https://rspack.dev/blog/announcing-1-0-alpha\" target=\"_blank\" rel=\"noopener noreferrer\">1.0</a> in August 2024 with full webpack API compatibility. Used in production by TikTok, Discord, Microsoft, and Amazon.</li><li>: Released January 2025 with the Oxide engine, using Rust for computationally expensive operations plus <a href=\"https://lightningcss.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">Lightning CSS</a>. Full builds 5x faster, incremental builds 8x faster.</li><li>: Shipped October 2024 with full Node.js and npm backwards compatibility, so its Rust-based formatter, linter, and tooling now work for mainstream Node projects too.</li></ul><p>This pattern has spread to other ecosystems. In Python, <a href=\"https://github.com/astral-sh/uv\" target=\"_blank\" rel=\"noopener noreferrer\">uv</a> (a Rust-based package manager, 10-100x faster than pip) and <a href=\"https://github.com/astral-sh/ruff\" target=\"_blank\" rel=\"noopener noreferrer\">Ruff</a> (linter and formatter replacing Flake8, Black, and isort) have taken off. Rust is eating developer tooling everywhere, not just JavaScript.</p><p>In the esbuild section above, Evan You (creator of Vue and Vite) is quoted saying Go \"was much more enjoyable to work with\" than Rust. In 2025, Evan <a href=\"https://voidzero.dev/posts/announcing-series-a\" target=\"_blank\" rel=\"noopener noreferrer\">raised $12.5M</a> and founded <a href=\"https://voidzero.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">VoidZero</a> to build a unified Rust-based JavaScript toolchain. Vite, Vitest, Rolldown, and Oxc are all under this umbrella.</p><p>Rust is also proving to be a great language for AI coding agents to write. I recently <a href=\"https://leerob.com/pixo\">built a Rust-based image compressor</a> using only coding agents. It was 38,000 lines of Rust with zero runtime dependencies. Rust's strict compiler is a natural fit for AI-generated code: if it compiles, it's much closer to correctness than other languages. Rust has grown  in the past 6 months because of coding agents.</p><p>The world I described in 2021, where all JavaScript build tools are written in Rust, has largely arrived.</p>",
      "contentLength": 13298,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/rust/comments/1rfapa1/rust_is_eating_javascript/"
    },
    {
      "title": "quaternion-core: A simple quaternion library written in Rust",
      "url": "https://www.reddit.com/r/rust/comments/1rfak2s/quaternioncore_a_simple_quaternion_library/",
      "date": 1772113544,
      "author": "/u/Ancient-Sale3089",
      "guid": 48707,
      "unread": true,
      "content": "<p>I created  and wanted to share it here.</p><p>This crate provides quaternion operations and conversions between several rotation representations (as shown in the attached image). It's designed to be simple and practical.</p><ul><li>Generic functions supporting both f32 and f64</li><li>Works in no_std environments</li><li>Can convert between 24 different Euler angles (I don't think many libraries can do this!)</li></ul><p>I started building it for attitude estimation on microcontrollers, so the functions are designed to minimize computational cost without overcomplicating the implementation.</p><p>I also made a Tennis Racket Theorem simulation using this crate:</p><p>Thanks for reading, and I hope you give it a try!</p>",
      "contentLength": 660,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Linux 7.1 Looks To Support Extended Attributes On Sockets For New GNOME & systemd Functionality",
      "url": "https://www.phoronix.com/news/Linux-7.1-Looks-xattrs-Sockets",
      "date": 1772112894,
      "author": "/u/adriano26",
      "guid": 48518,
      "unread": true,
      "content": "<p>Michael Larabel is the principal author of Phoronix.com and founded the site in 2004 with a focus on enriching the Linux hardware experience. Michael has written more than 20,000 articles covering the state of Linux hardware support, Linux performance, graphics drivers, and other topics. Michael is also the lead developer of the Phoronix Test Suite, Phoromatic, and OpenBenchmarking.org automated benchmarking software. He can be followed via <a href=\"https://twitter.com/MichaelLarabel\">Twitter</a>, <a href=\"https://www.linkedin.com/in/michaellarabel/\">LinkedIn</a>, or contacted via <a href=\"https://www.michaellarabel.com/\">MichaelLarabel.com</a>.</p>",
      "contentLength": 500,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/linux/comments/1rfaaxs/linux_71_looks_to_support_extended_attributes_on/"
    },
    {
      "title": "Number of active Bazzite Linux users Weekly",
      "url": "https://www.reddit.com/r/linux/comments/1rf9hl8/number_of_active_bazzite_linux_users_weekly/",
      "date": 1772110740,
      "author": "/u/Right-Grapefruit-507",
      "guid": 48498,
      "unread": true,
      "content": "<p>\"Classic DNF based operating systems can use the <a href=\"https://dnf.readthedocs.io/en/latest/conf_ref.html#countme-label\">DNF Count Me feature</a> to anonymously report how long a system has been running without impacting the user privacy. This is implemented as an additional  variable added to requests made to fetch RPM repository metadata. On those systems, this value is added randomly to requests made automatically via the  or via explicit calls to  or \"</p>",
      "contentLength": 384,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Lneto - Go networking with no operating system",
      "url": "https://github.com/soypat/lan8720",
      "date": 1772107667,
      "author": "/u/whittileaks",
      "guid": 48549,
      "unread": true,
      "content": "<p>Small 8USD setup to host a HTTP server at <a href=\"http://gsan.whittileaks.com\">http://gsan.whittileaks.com</a>, ! Change address bar http:// to http:// manually if it does not work.</p><p>The networking stack used is <a href=\"https://github.com/soypat/lneto\">Lneto</a>.</p>",
      "contentLength": 175,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rf8ge0/lneto_go_networking_with_no_operating_system/"
    },
    {
      "title": "Should you re-check the database on every request with session auth?",
      "url": "https://www.reddit.com/r/golang/comments/1rf83w8/should_you_recheck_the_database_on_every_request/",
      "date": 1772106591,
      "author": "/u/Minimum-Ad7352",
      "guid": 48497,
      "unread": true,
      "content": "<p>I‚Äôm using session-based authentication. When a user logs in, I generate a UUID session ID, store it as session_id -&gt; user_id, and return it in an HTTP-only cookie. On each request, middleware validates the session and extracts the user_id.</p><p>My question is: after getting the user_id from the session store, should I also query the main database to make sure the user still exists (or isn‚Äôt deactivated)? Or is trusting the session layer enough?</p><p>How do you usually handle this ?</p>",
      "contentLength": 478,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Let's Implement Consistent Hashing From Scratch in Golang",
      "url": "https://sushantdhiman.dev/lets-implement-consistent-hashing/",
      "date": 1772104402,
      "author": "/u/Sushant098123",
      "guid": 48496,
      "unread": true,
      "content": "<p>Recently I've been learning about distributed systems and I came across a very interesting concept \"Consistent Hashing\". It is one of the most basic thing in Distributed Systems.<strong>What is Consistent Hashing?</strong><p>Consistent hashing is a key distribution technique that ensures easy and smooth mapping of keys to servers to minimize data movement when nodes are added or removed. Unlike traditional hashing methods, where adding or removing a server changes the hash distribution significantly, consistent hashing reduces this impact.</p><p>It goes with mapping both servers (nodes) and keys to a circular hash space. When a request comes in, the system moves clockwise along the ring to find the closest node, which will be responsible for that key. It will store key and value data and can also be used while retrieving the same.</p></p><ul><li>Consistent hashing is widely used in distributed systems. </li><li>Load Balancing: Make sure that incoming requests are uniformly distributed among available servers so no server gets overwhelming resquests. </li><li>Distributed Caching (e.g., Memcached, Redis Cluster): Helps in mapping cache keys to specific nodes. </li><li>Database Sharding: Efficiently distributes and save database records across multiple database servers.</li></ul><p><strong>Why is Consistent Hashing Important?</strong><p>Imagine you have a set of servers handling API requests. A traditional hash function could distribute these requests among servers, but as soon as a server is added or removed, the entire mapping breaks, and most of the data needs to be rebalanced. This causes cache misses that increases latency and unnecessary load on the system.</p><p>Consistent hashing solves this by ensuring that only a small fraction of keys need to be remapped when a server is added or removed. This makes the system highly scalable and resilient.</p><p>Now, let‚Äôs talk about the implementation of consistent hashing in Golang. My implementation involves a ConsistentHashRing that maintains a sorted list of node hashes and efficiently assigns keys to nodes. Here‚Äôs how it works:</p></p><pre><code>type Node struct {\n\tID   string\n\tKeys map[string]string\n}\n\ntype ConsistentHashRing struct {\n\tmu     sync.RWMutex\n\tnodes  map[uint32]*Node\n\thashes []uint32\n}\n\nfunc NewConsistentHashRing() *ConsistentHashRing {\n\treturn &amp;ConsistentHashRing{\n\t\tnodes:  make(map[uint32]*Node),\n\t\thashes: []uint32{},\n\t}\n}</code></pre><div data-layout=\"minimal\"><div><div><a href=\"https://sushantdhiman.substack.com\">\n                            Subscribe\n                        </a></div></div></div><p><p>I used Murmur3 as my hashing function because it provides better distribution and performance than FNV or MD5.</p></p><pre><code>func hashFunction(key string) uint32 {\n  return murmur3.Sum32([]byte(key))\n}</code></pre><p><strong>2. Adding Nodes to the Ring</strong><p>When a new server is added, it is assigned a hash value and placed on the ring.</p></p><pre><code>func (chr *ConsistentHashRing) AddNode(id string) {\n  chr.mu.Lock()\n  defer chr.mu.Unlock()\n  hash := hashFunction(id)\n  chr.nodes[hash] = &amp;Node{\n    ID:   id,\n    Keys: make(map[string]string),\n  }\n  chr.hashes = append(chr.hashes, hash)\n  slices.Sort(chr.hashes)\n}</code></pre><p><strong>3. Finding the Nearest Node</strong><p>To locate the closest node for a given key, I move clockwise along the sorted list of hashes.</p></p><pre><code>func (chr *ConsistentHashRing) GetNextNodeIndex(hash uint32) int {\n  for i, h := range chr.hashes {\n    if h &gt; hash {\n      return i\n    }\n  }\n  return 0 // Wrap around to the first node\n}</code></pre><p><strong>4. Storing and Retrieving Data</strong><p>Each node holds a set of keys. When a key-value pair is stored, it is mapped to the correct node.</p></p><pre><code>func (chr *ConsistentHashRing) StoreKey(key, val string) {\n  node := chr.GetNode(key)\n  if node != nil {\n    node.Keys[key] = val\n  }\n}</code></pre><pre><code>func (chr *ConsistentHashRing) RetrieveKey(key string) (string, error) {\n  node := chr.GetNode(key)\n  if node == nil {\n    return \"\", errors.New(\"no node found\")\n  }\n  val, ok := node.Keys[key]\n  if !ok {\n    return \"\", errors.New(\"key not found\")\n  }\n  return val, nil\n}</code></pre><p><p>When a server is removed, its keys must be transferred to the next available node.</p></p><pre><code>func (chr *ConsistentHashRing) RemoveNode(id string) {\n  chr.mu.Lock()\n  defer chr.mu.Unlock()\n\n  hash := hashFunction(id)\n  node, exists := chr.nodes[hash]\n  if !exists {\n    return\n  }\n\n  nextNodeIndex := chr.GetNextNodeIndex(hash)\n  nextNode := chr.nodes[chr.hashes[nextNodeIndex]]\n  maps.Copy(nextNode.Keys, node.Keys)\n\n  delete(chr.nodes, hash)\n\n  for i, h := range chr.hashes {\n    if h == hash {\n      chr.hashes = slices.Delete(chr.hashes, i, i+1)\n      break\n    }\n  }\n}</code></pre><pre><code>func (chr *ConsistentHashRing) PrintRing() {\n\tfor _, h := range chr.hashes {\n\t\tfmt.Printf(\"Node: %s \\t\\t Hash: %d \\t\\t Total Keys: %v\\n\", chr.nodes[h].ID, h, len(chr.nodes[h].Keys))\n\t}\n}</code></pre><div data-layout=\"minimal\"><div><div><a href=\"https://sushantdhiman.substack.com\">\n                            Subscribe\n                        </a></div></div></div><p><p>Consistent hashing is a powerful technique that improves load distribution in distributed systems. My implementation efficiently assigns keys to nodes and ensures minimal disruption when nodes are added or removed.</p><p>If you have suggestions to optimize this implementation, drop them in the comments. I am always looking to improve my code.</p><p>Thank you for reading, and don‚Äôt forget to subscribe if you want more deep-dive posts like this!</p></p>",
      "contentLength": 5004,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/golang/comments/1rf7gcg/lets_implement_consistent_hashing_from_scratch_in/"
    },
    {
      "title": "Is kubent dead?",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rf7ar3/is_kubent_dead/",
      "date": 1772103860,
      "author": "/u/BojanKomazec",
      "guid": 48456,
      "unread": true,
      "content": "   submitted by   <a href=\"https://www.reddit.com/user/BojanKomazec\"> /u/BojanKomazec </a>",
      "contentLength": 35,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Weekly: This Week I Learned (TWIL?) thread",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rf788d/weekly_this_week_i_learned_twil_thread/",
      "date": 1772103632,
      "author": "/u/AutoModerator",
      "guid": 48636,
      "unread": true,
      "content": "<p>Did you learn something new this week? Share here!</p>",
      "contentLength": 50,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "Built a free Go module health checker. Paste your go.mod, see archived deps and version freshness.",
      "url": "https://www.reddit.com/r/golang/comments/1rf74nv/built_a_free_go_module_health_checker_paste_your/",
      "date": 1772103275,
      "author": "/u/Jzzck",
      "guid": 48604,
      "unread": true,
      "content": "<p>I had gorilla/mux in 3 different projects for months after the gorilla org archived everything. Never noticed until I randomly checked GitHub one day. Figured I should automate that.</p><p> Paste your  file. It parses every dependency, checks version freshness, flags archived modules (all gorilla/* packages, plus a few others), and shows you your Go version status.</p><p> - Go version health check (1.25 and 1.26 are supported, older versions flagged) - Each module gets a freshness grade and direct/indirect label - Archived module warnings (gorilla/mux, gorilla/websocket, gorilla/handlers, etc.) - Badge integration showing real-time health data from endoflife.date - Copy the full report as markdown</p><p>Runs entirely in your browser. Nothing is sent to any server. Your go.mod stays local.</p><p>There's also a CLI version if you want to scan your whole project:  picks up go.mod plus any other config files in the directory. No install needed.</p><p>Self-promo: I built this as part of ReleaseRun (release lifecycle tracking). Free tool, no signup. Feedback welcome, especially if there are archived or deprecated modules I should add to the detection list.</p>",
      "contentLength": 1133,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "vCluster in Docker has Changed the Way we Build and Share Local Kubernetes Developer Environments",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rf6nfk/vcluster_in_docker_has_changed_the_way_we_build/",
      "date": 1772101543,
      "author": "/u/wineandcode",
      "guid": 48552,
      "unread": true,
      "content": "<div><p><a href=\"https://itnext.io/vcluster-in-docker-has-changed-the-way-we-build-and-share-local-kubernetes-developer-environments-d4d8f4c57406?source=friends_link&amp;sk=c18dba8ab36bdc481362e90d81bc5b5e\">This post</a> explains how to run vCluster directly inside Docker (vind) as Standalone and how to securely share local Kubernetes cluster with your team using Tailscale with zero configuration.</p></div>   submitted by   <a href=\"https://www.reddit.com/user/wineandcode\"> /u/wineandcode </a>",
      "contentLength": 223,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "I geolocated a blurry pic from the Paris protests down to the exact coordinates using AI",
      "url": "https://v.redd.it/9f6i1crj9tlg1",
      "date": 1772099477,
      "author": "/u/Open_Budget6556",
      "guid": 48453,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/artificial/comments/1rf631t/i_geolocated_a_blurry_pic_from_the_paris_protests/"
    },
    {
      "title": "KDE supports the \"Keep Android Open\" campaign",
      "url": "https://www.reddit.com/r/linux/comments/1rf5wlz/kde_supports_the_keep_android_open_campaign/",
      "date": 1772098803,
      "author": "/u/Bro666",
      "guid": 48447,
      "unread": true,
      "content": "",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "eBPF Foundation Funding eBPF Focused Meetups",
      "url": "https://ebpf.foundation/introducing-the-ebpf-meetup-program/",
      "date": 1772098696,
      "author": "/u/xmull1gan",
      "guid": 48646,
      "unread": true,
      "content": "<!DOCTYPE html>",
      "contentLength": 0,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/kubernetes/comments/1rf5vly/ebpf_foundation_funding_ebpf_focused_meetups/"
    },
    {
      "title": "How GitHub blocks external images in SVGs ‚Äî and how to work around it with base64 encoding",
      "url": "http://github.com/readme-SVG/readme-SVG-youtube-preview",
      "date": 1772098190,
      "author": "/u/DazzlingChicken4893",
      "guid": 48454,
      "unread": true,
      "content": "<p>While building a small tool that generates YouTube preview cards for GitHub READMEs, I ran into something that wasn't obvious at all. Maybe it saves someone else an hour.</p><p>I wanted to embed a YouTube thumbnail inside an SVG. Locally it worked perfectly. But on GitHub ‚Äî blank. Just an empty card. I spent way too long thinking it was a bug in my code before I figured out what was actually happening.</p><p>GitHub's Markdown sanitizer strips external URLs from  tags inside SVGs. This is a security measure to prevent tracking pixels and mixed-content issues. The SVG itself renders fine, but any external resource referenced inside it gets silently blocked. It's not documented very prominently, which is why it catches a lot of people off guard.</p><p>Instead of linking to the image URL directly, you fetch the image server-side and convert it to a base64 data URI before embedding it into the SVG. Since the image data now lives inside the SVG string itself rather than as an external URL, GitHub renders it without any issues. The trade-off is that base64 increases response size by roughly 33% ‚Äî for a typical YouTube thumbnail around 20KB, that's about 27KB extra. Worth it if you need the image to actually show up.</p><p>While building this I also discovered that YouTube has a public oEmbed endpoint that returns a video's title and thumbnail URL with zero authentication ‚Äî no API key, no quota, no developer account needed. I had no idea this existed. You just hit <a href=\"http://youtube.com/oembed?url=VIDEO_URL&amp;format=json\"><code>youtube.com/oembed?url=VIDEO_URL&amp;format=json</code></a> and get back everything you need. Useful well beyond this specific use case.</p><p>I ended up turning this into a small open-source tool that generates these cards as a deployable service ‚Äî if anyone's curious the repo is linked in the comments. But the base64 trick works for any situation where you need images inside SVGs to actually render on GitHub.</p><p>Happy to answer questions about the implementation.</p>",
      "contentLength": 1904,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": "https://www.reddit.com/r/programming/comments/1rf5qua/how_github_blocks_external_images_in_svgs_and_how/"
    },
    {
      "title": "Awesome Kubernetes Architecture Diagrams",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rf5g7k/awesome_kubernetes_architecture_diagrams/",
      "date": 1772097030,
      "author": "/u/Philippe_Merle",
      "guid": 48500,
      "unread": true,
      "content": "<p>The <a href=\"https://github.com/philippemerle/Awesome-Kubernetes-Architecture-Diagrams\">Awesome Kubernetes Architecture Diagrams</a> repo studies  that auto-generate Kubernetes architecture diagrams from manifests, Helm charts, or cluster state. These tools are compared in depth via many criteria such as license, popularity (#stars and #forks), activity (1st commit, last commit, #commits, #contributors), implementation language, usage mode (CLI, GUI, SaaS), inputs formats supported, Kubernetes resource kinds supported, output formats. Moreover, diagrams generated by these tools for a well-known WordPress use case are shown, and diagram strengths/weaknesses are discussed. The whole should help practitioners to select which diagram generation tools to use according to their requirements.</p>",
      "contentLength": 708,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    },
    {
      "title": "How do you trace slow Spark jobs back to code on EMR on EKS?",
      "url": "https://www.reddit.com/r/kubernetes/comments/1rf5e1r/how_do_you_trace_slow_spark_jobs_back_to_code_on/",
      "date": 1772096794,
      "author": "/u/Upper_Caterpillar_96",
      "guid": 48449,
      "unread": true,
      "content": "<p>We run two EMR on EKS clusters with event logs written to one S3 bucket. One Spark History Server reads from it and that part works fine.</p><p>The problem is when a job takes 45 minutes instead of 20. You open SHS, look at the stages, look at the timings. Something is off. But figuring out which part of the code caused it is not obvious at all.</p><p>Shuffle spill shows up. GC pressure shows up. But there is no line saying this came from that transformation. You end up guessing.</p><p>Comparing the same job across two runs means digging through multiple completed apps by hand. It gets old fast.</p><p>We tried custom Spark listeners and some Prometheus scraping. A lot of glue work for something that still does not tell you what actually went wrong.</p><p>What are people using in Kubernetes environments to get from \"this job was slow\" to something more concrete? How do you correlate SHS metrics, pod logs, or Prometheus data back to specific code paths or transformations?</p>",
      "contentLength": 949,
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": "",
      "commentsUrl": null
    }
  ],
  "tags": [
    "reddit"
  ]
}